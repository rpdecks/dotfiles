{"version":3,"sources":["webpack://vim/webpack/universalModuleDefinition","webpack://vim/./node_modules/diff-match-patch/index.js","webpack://vim/./node_modules/lodash/lodash.js","webpack://vim/./node_modules/os-browserify/browser.js","webpack://vim/./node_modules/path-browserify/index.js","webpack://vim/./node_modules/process/browser.js","webpack://vim/./node_modules/setimmediate/setImmediate.js","webpack://vim/./extensionBase.ts","webpack://vim/./src/actions/base.ts","webpack://vim/./src/actions/baseMotion.ts","webpack://vim/./src/actions/commands/actions.ts","webpack://vim/./src/actions/commands/commandLine.ts","webpack://vim/./src/actions/commands/digraphs.ts","webpack://vim/./src/actions/commands/insert.ts","webpack://vim/./src/actions/commands/put.ts","webpack://vim/./src/actions/commands/replace.ts","webpack://vim/./src/actions/commands/search.ts","webpack://vim/./src/actions/include-main.ts","webpack://vim/./src/actions/motion.ts","webpack://vim/./src/actions/operator.ts","webpack://vim/./src/actions/plugins/easymotion/easymotion.cmd.ts","webpack://vim/./src/actions/plugins/easymotion/easymotion.ts","webpack://vim/./src/actions/plugins/easymotion/markerGenerator.ts","webpack://vim/./src/actions/plugins/easymotion/types.ts","webpack://vim/./src/actions/plugins/sneak.ts","webpack://vim/./src/actions/wrapping.ts","webpack://vim/./src/cmd_line/commandLine.ts","webpack://vim/./src/cmd_line/commands/bang.ts","webpack://vim/./src/cmd_line/commands/bufferDelete.ts","webpack://vim/./src/cmd_line/commands/close.ts","webpack://vim/./src/cmd_line/commands/deleteRange.ts","webpack://vim/./src/cmd_line/commands/digraph.ts","webpack://vim/./src/cmd_line/commands/file.ts","webpack://vim/./src/cmd_line/commands/fileInfo.ts","webpack://vim/./src/cmd_line/commands/goto.ts","webpack://vim/./src/cmd_line/commands/history.ts","webpack://vim/./src/cmd_line/commands/jumps.ts","webpack://vim/./src/cmd_line/commands/marks.ts","webpack://vim/./src/cmd_line/commands/nohl.ts","webpack://vim/./src/cmd_line/commands/only.ts","webpack://vim/./src/cmd_line/commands/put.ts","webpack://vim/./src/cmd_line/commands/quit.ts","webpack://vim/./src/cmd_line/commands/read.ts","webpack://vim/./src/cmd_line/commands/register.ts","webpack://vim/./src/cmd_line/commands/setoptions.ts","webpack://vim/./src/cmd_line/commands/sh.ts","webpack://vim/./src/cmd_line/commands/smile.ts","webpack://vim/./src/cmd_line/commands/sort.ts","webpack://vim/./src/cmd_line/commands/substitute.ts","webpack://vim/./src/cmd_line/commands/tab.ts","webpack://vim/./src/cmd_line/commands/undo.ts","webpack://vim/./src/cmd_line/commands/wall.ts","webpack://vim/./src/cmd_line/commands/write.ts","webpack://vim/./src/cmd_line/commands/writequit.ts","webpack://vim/./src/cmd_line/commands/writequitall.ts","webpack://vim/./src/cmd_line/lexer.ts","webpack://vim/./src/cmd_line/node.ts","webpack://vim/./src/cmd_line/parser.ts","webpack://vim/./src/cmd_line/scanner.ts","webpack://vim/./src/cmd_line/subparser.ts","webpack://vim/./src/cmd_line/subparsers/bang.ts","webpack://vim/./src/cmd_line/subparsers/bufferDelete.ts","webpack://vim/./src/cmd_line/subparsers/close.ts","webpack://vim/./src/cmd_line/subparsers/deleteRange.ts","webpack://vim/./src/cmd_line/subparsers/digraph.ts","webpack://vim/./src/cmd_line/subparsers/file.ts","webpack://vim/./src/cmd_line/subparsers/fileInfo.ts","webpack://vim/./src/cmd_line/subparsers/history.ts","webpack://vim/./src/cmd_line/subparsers/marks.ts","webpack://vim/./src/cmd_line/subparsers/put.ts","webpack://vim/./src/cmd_line/subparsers/quit.ts","webpack://vim/./src/cmd_line/subparsers/read.ts","webpack://vim/./src/cmd_line/subparsers/register.ts","webpack://vim/./src/cmd_line/subparsers/setoptions.ts","webpack://vim/./src/cmd_line/subparsers/sort.ts","webpack://vim/./src/cmd_line/subparsers/substitute.ts","webpack://vim/./src/cmd_line/subparsers/tab.ts","webpack://vim/./src/cmd_line/subparsers/wall.ts","webpack://vim/./src/cmd_line/subparsers/write.ts","webpack://vim/./src/cmd_line/subparsers/writequit.ts","webpack://vim/./src/cmd_line/subparsers/writequitall.ts","webpack://vim/./src/cmd_line/token.ts","webpack://vim/./src/common/matching/matcher.ts","webpack://vim/./src/common/matching/quoteMatcher.ts","webpack://vim/./src/common/matching/tagMatcher.ts","webpack://vim/./src/common/motion/position.ts","webpack://vim/./src/common/motion/range.ts","webpack://vim/./src/common/number/numericString.ts","webpack://vim/./src/completion/lineCompletionProvider.ts","webpack://vim/./src/configuration/configuration.ts","webpack://vim/./src/configuration/configurationValidator.ts","webpack://vim/./src/configuration/decoration.ts","webpack://vim/./src/configuration/iconfigurationValidator.ts","webpack://vim/./src/configuration/notation.ts","webpack://vim/./src/configuration/remapper.ts","webpack://vim/./src/configuration/validators/inputMethodSwitcherValidator.ts","webpack://vim/./src/configuration/validators/remappingValidator.ts","webpack://vim/./src/editorIdentity.ts","webpack://vim/./src/error.ts","webpack://vim/./src/globals.ts","webpack://vim/./src/history/historyFile.ts","webpack://vim/./src/history/historyTracker.ts","webpack://vim/./src/jumps/jump.ts","webpack://vim/./src/jumps/jumpTracker.ts","webpack://vim/./src/mode/mode.ts","webpack://vim/./src/mode/modeHandler.ts","webpack://vim/./src/mode/modeHandlerMap.ts","webpack://vim/./src/platform/browser/constants.ts","webpack://vim/./src/platform/browser/fs.ts","webpack://vim/./src/platform/browser/history.ts","webpack://vim/./src/platform/browser/loggerImpl.ts","webpack://vim/./src/register/register.ts","webpack://vim/./src/state/compositionState.ts","webpack://vim/./src/state/globalState.ts","webpack://vim/./src/state/recordedState.ts","webpack://vim/./src/state/remapState.ts","webpack://vim/./src/state/replaceState.ts","webpack://vim/./src/state/searchState.ts","webpack://vim/./src/state/substituteState.ts","webpack://vim/./src/state/vimState.ts","webpack://vim/./src/statusBar.ts","webpack://vim/./src/taskQueue.ts","webpack://vim/./src/textEditor.ts","webpack://vim/./src/textobject/paragraph.ts","webpack://vim/./src/textobject/sentence.ts","webpack://vim/./src/textobject/textobject.ts","webpack://vim/./src/textobject/util.ts","webpack://vim/./src/textobject/word.ts","webpack://vim/./src/transformations/execute.ts","webpack://vim/./src/transformations/transformations.ts","webpack://vim/./src/transformations/transformer.ts","webpack://vim/./src/util/clipboard.ts","webpack://vim/./src/util/externalCommand.ts","webpack://vim/./src/util/logger.ts","webpack://vim/./src/util/os.ts","webpack://vim/./src/util/path.ts","webpack://vim/./src/util/specialKeys.ts","webpack://vim/./src/util/statusBarTextUtils.ts","webpack://vim/./src/util/util.ts","webpack://vim/./src/util/vscodeContext.ts","webpack://vim/./node_modules/untildify/index.js","webpack://vim/./node_modules/util/node_modules/inherits/inherits_browser.js","webpack://vim/./node_modules/util/support/isBufferBrowser.js","webpack://vim/./node_modules/util/util.js","webpack://vim/external \"vscode\"","webpack://vim/webpack/bootstrap","webpack://vim/webpack/runtime/global","webpack://vim/webpack/runtime/node module decorator","webpack://vim/./extensionWeb.ts"],"names":["root","factory","exports","module","define","amd","a","i","self","diff_match_patch","this","Diff_Timeout","Diff_EditCost","Match_Threshold","Match_Distance","Patch_DeleteThreshold","Patch_Margin","Match_MaxBits","DIFF_DELETE","Diff","op","text","prototype","diff_main","text1","text2","opt_checklines","opt_deadline","Number","MAX_VALUE","Date","getTime","deadline","Error","checklines","commonlength","diff_commonPrefix","commonprefix","substring","diff_commonSuffix","commonsuffix","length","diffs","diff_compute_","unshift","push","diff_cleanupMerge","longtext","shorttext","indexOf","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","concat","diff_lineMode_","diff_bisect_","diff_linesToChars_","chars1","chars2","linearray","lineArray","diff_charsToLines_","diff_cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","splice","subDiff","j","pop","text1_length","text2_length","max_d","Math","ceil","v_offset","v_length","v1","Array","v2","x","delta","front","k1start","k1end","k2start","k2end","d","k1","k1_offset","y1","x1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","chars","lineStart","lineEnd","lineArrayLength","line","hasOwnProperty","undefined","String","fromCharCode","maxLines","charCodeAt","join","pointermin","pointermax","min","pointermid","pointerstart","floor","pointerend","diff_commonOverlap_","text_length","best","pattern","found","dmp","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","changes","equalities","equalitiesLength","lastEquality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","max","diff_cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","match","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","diff_cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","diff_xIndex","loc","last_chars1","last_chars2","diff_prettyHtml","html","pattern_amp","pattern_lt","pattern_gt","pattern_para","replace","diff_text1","diff_text2","diff_levenshtein","levenshtein","insertions","deletions","data","diff_toDelta","encodeURI","diff_fromDelta","diffsLength","tokens","split","param","decodeURI","ex","n","parseInt","isNaN","match_main","match_bitap_","s","match_alphabet_","match_bitapScore_","e","accuracy","proximity","abs","score_threshold","best_loc","lastIndexOf","bin_min","bin_mid","matchmask","last_rd","bin_max","start","finish","rd","charMatch","patch_addContext_","patch","start2","length1","padding","prefix","suffix","start1","length2","patch_make","opt_b","opt_c","patches","patch_obj","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","diff_type","diff_text","patch_deepCopy","patchesCopy","patchCopy","patch_apply","nullPadding","patch_addPadding","patch_splitMax","results","start_loc","expected_loc","end_loc","index2","index1","mod","paddingLength","extraLength","patch_size","bigpatch","precontext","empty","shift","postcontext","patch_toText","patch_fromText","textline","textPointer","patchHeader","m","sign","toString","FUNC_ERROR_TEXT","HASH_UNDEFINED","PLACEHOLDER","WRAP_PARTIAL_FLAG","WRAP_ARY_FLAG","INFINITY","MAX_SAFE_INTEGER","NAN","MAX_ARRAY_LENGTH","wrapFlags","argsTag","arrayTag","boolTag","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reEmptyStringLeading","reEmptyStringMiddle","reEmptyStringTrailing","reEscapedHtml","reUnescapedHtml","reHasEscapedHtml","RegExp","source","reHasUnescapedHtml","reEscape","reEvaluate","reInterpolate","reIsDeepProp","reIsPlainProp","rePropName","reRegExpChar","reHasRegExpChar","reTrim","reTrimStart","reTrimEnd","reWrapComment","reWrapDetails","reSplitDetails","reAsciiWord","reEscapeChar","reEsTemplate","reFlags","reIsBadHex","reIsBinary","reIsHostCtor","reIsOctal","reIsUint","reLatin","reNoMatch","reUnescapedString","rsComboRange","rsComboMarksRange","rsLowerRange","rsUpperRange","rsBreakRange","rsMathOpRange","rsBreak","rsCombo","rsDigits","rsLower","rsMisc","rsFitz","rsNonAstral","rsRegional","rsSurrPair","rsUpper","rsMiscLower","rsMiscUpper","rsOptContrLower","rsOptContrUpper","reOptMod","rsModifier","rsOptVar","rsSeq","rsEmoji","rsSymbol","reApos","reComboMark","reUnicode","reUnicodeWord","reHasUnicode","reHasUnicodeWord","contextProps","templateCounter","typedArrayTags","cloneableTags","stringEscapes","freeParseFloat","parseFloat","freeParseInt","freeGlobal","g","Object","freeSelf","Function","freeExports","nodeType","freeModule","moduleExports","freeProcess","process","nodeUtil","require","types","binding","nodeIsArrayBuffer","isArrayBuffer","nodeIsDate","isDate","nodeIsMap","isMap","nodeIsRegExp","isRegExp","nodeIsSet","isSet","nodeIsTypedArray","isTypedArray","apply","func","thisArg","args","call","arrayAggregator","array","setter","iteratee","accumulator","index","value","arrayEach","arrayEachRight","arrayEvery","predicate","arrayFilter","resIndex","result","arrayIncludes","baseIndexOf","arrayIncludesWith","comparator","arrayMap","arrayPush","values","offset","arrayReduce","initAccum","arrayReduceRight","arraySome","asciiSize","baseProperty","baseFindKey","collection","eachFunc","key","baseFindIndex","fromIndex","fromRight","strictIndexOf","baseIsNaN","baseIndexOfWith","baseMean","baseSum","object","basePropertyOf","baseReduce","current","baseTimes","baseUnary","baseValues","props","cacheHas","cache","has","charsStartIndex","strSymbols","chrSymbols","charsEndIndex","countHolders","placeholder","deburrLetter","escapeHtmlChar","escapeStringChar","chr","hasUnicode","string","test","mapToArray","map","size","forEach","overArg","transform","arg","replaceHolders","setToArray","set","setToPairs","stringSize","lastIndex","unicodeSize","stringToArray","unicodeToArray","asciiToArray","unescapeHtmlChar","_","runInContext","context","uid","defaults","pick","TypeError","arrayProto","funcProto","objectProto","coreJsData","funcToString","idCounter","maskSrcKey","exec","keys","IE_PROTO","nativeObjectToString","objectCtorString","oldDash","reIsNative","Buffer","Symbol","Uint8Array","allocUnsafe","getPrototype","getPrototypeOf","objectCreate","create","propertyIsEnumerable","spreadableSymbol","isConcatSpreadable","symIterator","iterator","symToStringTag","toStringTag","defineProperty","getNative","ctxClearTimeout","clearTimeout","ctxNow","now","ctxSetTimeout","setTimeout","nativeCeil","nativeFloor","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","isBuffer","nativeIsFinite","isFinite","nativeJoin","nativeKeys","nativeMax","nativeMin","nativeNow","nativeParseInt","nativeRandom","random","nativeReverse","reverse","DataView","Map","Promise","Set","WeakMap","nativeCreate","metaMap","realNames","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","symbolToString","lodash","isObjectLike","isArray","LazyWrapper","LodashWrapper","wrapperClone","baseCreate","proto","isObject","baseLodash","chainAll","__wrapped__","__actions__","__chain__","__index__","__values__","__dir__","__filtered__","__iteratees__","__takeCount__","__views__","Hash","entries","clear","entry","ListCache","MapCache","SetCache","__data__","add","Stack","arrayLikeKeys","inherited","isArr","isArg","isArguments","isBuff","isType","skipIndexes","isIndex","arraySample","baseRandom","arraySampleSize","shuffleSelf","copyArray","baseClamp","arrayShuffle","assignMergeValue","eq","baseAssignValue","assignValue","objValue","assocIndexOf","baseAggregator","baseEach","baseAssign","copyObject","baseAt","paths","skip","get","number","lower","upper","baseClone","bitmask","customizer","stack","isDeep","isFlat","isFull","constructor","input","initCloneArray","tag","getTag","isFunc","cloneBuffer","initCloneObject","getSymbolsIn","copySymbolsIn","keysIn","baseAssignIn","getSymbols","copySymbols","symbol","Ctor","cloneArrayBuffer","dataView","buffer","byteOffset","byteLength","cloneDataView","cloneTypedArray","regexp","cloneRegExp","initCloneByTag","stacked","subValue","getAllKeysIn","getAllKeys","baseConformsTo","baseDelay","wait","baseDifference","includes","isCommon","valuesLength","outer","computed","valuesIndex","templateSettings","getMapData","pairs","LARGE_ARRAY_SIZE","createBaseEach","baseForOwn","baseEachRight","baseForOwnRight","baseEvery","baseExtremum","isSymbol","baseFilter","baseFlatten","depth","isStrict","isFlattenable","baseFor","createBaseFor","baseForRight","baseFunctions","isFunction","baseGet","path","castPath","toKey","baseGetAllKeys","keysFunc","symbolsFunc","baseGetTag","isOwn","unmasked","getRawTag","objectToString","baseGt","other","baseHas","baseHasIn","baseIntersection","arrays","othLength","othIndex","caches","maxLength","Infinity","seen","baseInvoke","parent","last","baseIsArguments","baseIsEqual","equalFunc","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","equalArrays","name","message","convert","isPartial","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","objProps","objLength","objStacked","othStacked","skipCtor","othValue","compared","objCtor","othCtor","equalObjects","baseIsEqualDeep","baseIsMatch","matchData","noCustomizer","srcValue","COMPARE_PARTIAL_FLAG","baseIsNative","baseIteratee","identity","baseMatchesProperty","baseMatches","property","baseKeys","isPrototype","baseLt","baseMap","isArrayLike","getMatchData","matchesStrictComparable","isKey","isStrictComparable","hasIn","baseMerge","srcIndex","mergeFunc","safeGet","newValue","isTyped","isArrayLikeObject","isPlainObject","toPlainObject","baseMergeDeep","baseNth","baseOrderBy","iteratees","orders","getIteratee","comparer","sort","objCriteria","criteria","othCriteria","ordersLength","compareAscending","compareMultiple","baseSortBy","basePickBy","baseSet","basePullAll","basePullAt","indexes","previous","baseUnset","baseRepeat","baseRest","setToString","overRest","baseSample","baseSampleSize","nested","baseSetData","baseSetToString","constant","baseShuffle","baseSlice","end","baseSome","baseSortedIndex","retHighest","low","high","mid","baseSortedIndexBy","valIsNaN","valIsNull","valIsSymbol","valIsUndefined","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","setLow","baseSortedUniq","baseToNumber","baseToString","baseUniq","createSet","seenIndex","baseUpdate","updater","baseWhile","isDrop","baseWrapperValue","actions","action","baseXor","baseZipObject","assignFunc","valsLength","castArrayLikeObject","castFunction","stringToPath","castRest","castSlice","id","slice","copy","arrayBuffer","typedArray","valIsDefined","valIsReflexive","composeArgs","partials","holders","isCurried","argsIndex","argsLength","holdersLength","leftIndex","leftLength","rangeLength","isUncurried","composeArgsRight","holdersIndex","rightIndex","rightLength","isNew","createAggregator","initializer","createAssigner","assigner","sources","guard","isIterateeCall","iterable","createCaseFirst","methodName","trailing","createCompounder","callback","words","deburr","createCtor","arguments","thisBinding","createFind","findIndexFunc","createFlow","flatRest","funcs","prereq","thru","wrapper","getFuncName","funcName","getData","isLaziable","plant","createHybrid","partialsRight","holdersRight","argPos","ary","arity","isAry","isBind","isBindKey","isFlip","getHolder","holdersCount","newHolders","createRecurry","fn","reorder","createInverter","toIteratee","baseInverter","createMathOperation","operator","defaultValue","createOver","arrayFunc","createPadding","charsLength","createRange","step","toFinite","baseRange","createRelationalOperation","toNumber","wrapFunc","isCurry","newData","setData","setWrapToString","createRound","precision","toInteger","pair","noop","createToPairs","baseToPairs","createWrap","srcBitmask","newBitmask","isCombo","mergeData","createCurry","createPartial","createBind","customDefaultsAssignIn","customDefaultsMerge","customOmitClone","arrLength","arrStacked","arrValue","flatten","otherFunc","type","getValue","stubArray","hasPath","hasFunc","isLength","ArrayBuffer","resolve","ctorString","isMaskable","stubFalse","otherArgs","oldArray","shortOut","reference","details","insertWrapDetails","updateWrapDetails","getWrapDetails","count","lastCalled","stamp","remaining","rand","memoize","quote","subString","clone","difference","differenceBy","differenceWith","findIndex","findLastIndex","head","intersection","mapped","intersectionBy","intersectionWith","pull","pullAll","pullAt","union","unionBy","unionWith","unzip","group","unzipWith","without","xor","xorBy","xorWith","zip","zipWith","chain","interceptor","wrapperAt","countBy","find","findLast","forEachRight","groupBy","invokeMap","keyBy","partition","sortBy","before","bind","bindKey","WRAP_BIND_FLAG","debounce","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","invokeFunc","time","leadingEdge","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","cancel","flush","defer","delay","resolver","memoized","Cache","negate","overArgs","transforms","funcsLength","partial","partialRight","rearg","gt","gte","isError","isInteger","isNumber","isString","lt","lte","toArray","next","done","iteratorToArray","remainder","toLength","isBinary","assign","assignIn","assignInWith","assignWith","at","propsIndex","propsLength","defaultsDeep","mergeWith","invert","invertBy","invoke","nativeKeysIn","isProto","baseKeysIn","merge","omit","CLONE_DEEP_FLAG","basePick","pickBy","prop","toPairs","toPairsIn","camelCase","word","toLowerCase","capitalize","upperFirst","kebabCase","lowerCase","lowerFirst","snakeCase","startCase","upperCase","toUpperCase","hasUnicodeWord","unicodeWords","asciiWords","attempt","bindAll","methodNames","flow","flowRight","method","methodOf","mixin","over","overEvery","overSome","basePropertyDeep","range","rangeRight","augend","addend","divide","dividend","divisor","multiply","multiplier","multiplicand","round","subtract","minuend","subtrahend","after","castArray","chunk","compact","cond","conforms","baseConforms","properties","curry","curryRight","drop","dropRight","dropRightWhile","dropWhile","fill","baseFill","filter","flatMap","flatMapDeep","flatMapDepth","flattenDeep","flattenDepth","flip","fromPairs","functions","functionsIn","initial","mapKeys","mapValues","matches","matchesProperty","nthArg","omitBy","once","orderBy","propertyOf","pullAllBy","pullAllWith","reject","remove","rest","sampleSize","setWith","shuffle","sortedUniq","sortedUniqBy","separator","limit","spread","tail","take","takeRight","takeRightWhile","takeWhile","tap","throttle","toPath","isArrLike","unary","uniq","uniqBy","uniqWith","unset","update","updateWith","valuesIn","wrap","zipObject","zipObjectDeep","entriesIn","extend","extendWith","clamp","cloneDeep","cloneDeepWith","cloneWith","conformsTo","defaultTo","endsWith","target","position","escape","escapeRegExp","every","findKey","findLastKey","forIn","forInRight","forOwn","forOwnRight","inRange","baseInRange","isBoolean","isElement","isEmpty","isEqual","isEqualWith","isMatch","isMatchWith","isNative","isNil","isNull","isSafeInteger","isUndefined","isWeakMap","isWeakSet","strictLastIndexOf","maxBy","mean","meanBy","minBy","stubObject","stubString","stubTrue","nth","noConflict","pad","strLength","padEnd","padStart","radix","floating","temp","reduce","reduceRight","repeat","sample","some","sortedIndex","sortedIndexBy","sortedIndexOf","sortedLastIndex","sortedLastIndexBy","sortedLastIndexOf","startsWith","sum","sumBy","template","settings","isEscaping","isEvaluating","imports","importsKeys","importsValues","interpolate","reDelimiters","evaluate","sourceURL","escapeValue","interpolateValue","esTemplateValue","evaluateValue","variable","times","toLower","toSafeInteger","toUpper","trim","trimEnd","trimStart","truncate","omission","search","global","newEnd","unescape","uniqueId","each","eachRight","first","VERSION","isFilter","takeName","dropName","checkIteratee","isTaker","lodashFunc","retUnwrapped","isLazy","useLazy","isHybrid","isUnwrapped","onlyLazy","chainName","dir","isRight","view","getView","iterLength","takeCount","iterIndex","commit","wrapped","toJSON","endianness","hostname","location","loadavg","uptime","freemem","totalmem","cpus","release","navigator","appVersion","networkInterfaces","getNetworkInterfaces","arch","platform","tmpdir","tmpDir","EOL","homedir","assertPath","JSON","stringify","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","lastSlashIndex","posix","cwd","resolvedPath","resolvedAbsolute","normalize","isAbsolute","trailingSeparator","joined","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","matchedSlash","basename","ext","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","base","_format","parse","ret","delimiter","win32","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","marker","runClearTimeout","Item","nextTick","title","browser","env","argv","version","versions","on","addListener","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","chdir","umask","setImmediate","registerImmediate","channel","messagePrefix","onGlobalMessage","nextHandle","tasksByHandle","currentlyRunningATask","doc","document","attachTo","handle","runIfPresent","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","canUsePostMessage","event","addEventListener","attachEvent","MessageChannel","port1","port2","createElement","documentElement","script","onreadystatechange","removeChild","appendChild","task","clearImmediate","extensionContext","previousActiveEditorId","lastClosedModeHandler","async","getAndUpdateModeHandler","forceSyncAndUpdate","activeTextEditor","vscode","window","isClosed","activeEditorId","EditorIdentity","fromEditor","curHandler","ModeHandlerMap","getOrCreate","subscriptions","vimState","editor","syncCursors","updateView","drawSelection","revealRange","focusChanged","loadConfiguration","validatorResults","configuration","load","Logger","configChanged","logger","debug","numErrors","validatorResult","level","error","warn","toggleExtension","isDisabled","compositionState","VSCodeContext","mh","handleKeyEvent","SpecialKeys","ExtensionDisable","reset","ExtensionEnable","overrideCommand","command","disposable","commands","registerCommand","disableExtension","executeCommand","uri","requiresActiveEditor","registerEventListener","listener","exitOnExtensionDisable","exitOnTests","Globals","isTesting","taskQueue","enqueueTask","forceStopRecursiveRemap","remapState","isCurrentlyPerformingRecursiveRemapping","forceStopRecursiveRemapping","handleLocal","StatusBar","Register","loadFromDisk","all","commandLine","globalState","filepathComponents","fileName","putByKey","workspace","onDidChangeConfiguration","onDidChangeTextDocument","changeEvent","contentChanges","jumpTracker","handleTextDeleted","textWasAdded","handleTextAdded","contentChangeHandler","modeHandler","currentMode","Mode","Insert","historyTracker","currentContentChanges","mockModeHandler","getAll","isDirty","isUntitled","HistoryTracker","onDidCloseTextDocument","closedDocument","documents","textDocuments","editorIdentity","getKeys","shouldDelete","delete","onDidSaveTextDocument","vimrc","enable","showInformationMessage","onDidChangeActiveTextEditor","mhPrevious","oldFileRegister","relativePath","asRelativePath","RegisterMode","CharacterWise","handleFileJump","Jump","fromStateNow","onDidChangeTextEditorSelection","textEditor","kind","TextEditorSelectionChangeKind","Mouse","selectionsHash","selections","hash","anchor","character","active","idx","selectionsChanged","ourSelections","ignoreIntermediateSelections","EasyMotionMode","handleSelectionChange","onDidChangeTextEditorVisibleRanges","CompositionState","isInComposition","composingText","insertedText","substr","replaceCharCnt","cursorStopPosition","selection","cursorStartPosition","handleMultipleKeyEvents","PromptAndRun","Notation","NormalizeKey","leader","Run","openTextDocument","showTextDocument","boundKey","boundKeyCombinations","startInInsertMode","cursors","cursor","eolColumn","lineAt","stop","withNewStop","with","BaseAction","isMotion","isOperator","isCommand","isJump","canBeRepeatedWithDot","multicursorIndex","mustBeFirstKey","keysPressed","recordedState","commandWithoutCountPrefix","modes","CompareKeypressSequence","keysSlice","is2DArray","sequence","left","right","isSingleNumber","isSingleAlpha","IsControlKey","KeypressState","isCompleteAction","runsOnceForEachCountPrefix","timesToRepeat","runsOnceForEveryCursor","transformation","transformer","transformations","isTextTransformation","cursorIndex","resultingCursors","cursorsToIterateOver","Range","b","actionMap","isPotentialMatch","possibleActionsForMode","actionType","doesActionApply","actionKeys","couldActionApply","WaitingOnKeys","NoPossibleMatch","actionInstance","modeName","isIMovement","o","SelectionType","failedMovement","failed","BaseMovement","isRepeat","super","Normal","Visual","VisualLine","VisualBlock","setsDesiredColumnToEOL","minCount","maxCount","selectionType","Concatenating","execAction","Position","prevResult","firstMovementStart","firstIteration","lastIteration","createMovementResult","adjustPosition","execActionForOperator","getRightThroughLineBreaks","DocumentContentChangeAction","compressChanges","positionDiff","diff","firstTextDiff","replaceRange","originalLeftBoundary","rightBoundary","change","linesAffected","resultLines","translate","diffPos","lineOffset","char","isAfter","textDiffLines","numLinesAdded","newRightBoundary","laterOf","Selection","TextEditor","insert","lastChange","advancePositionByText","setCurrentMode","second","rangeOffset","compressed","prev","merged","DisableExtension","BaseCommand","SearchInProgressMode","CommandlineInProgress","Replace","EasyMotionInputMode","SurroundInputMode","Disabled","RegisterAction","EnableExtension","CommandNumber","num","operatorCount","lastAction","actionsRun","isZero","CommandRegister","register","registerName","isValidRegister","CommandRecordMacro","registerKey","toLocaleLowerCase","macro","RecordedState","newRegister","CommandQuitRecordMacro","existingMacro","CommandExecuteMacro","addTransformation","replay","isValidRegisterForMacro","CommandExecuteLastMacro","lastInvokedMacro","CommandEsc","surround","isMultiCursor","easyMotion","clearDecorations","CommandEditorScroll","visibleRange","visibleRanges","scrolloff","getConfiguration","linesAboveCursor","linesBelowCursor","getUp","withColumn","desiredColumn","getDown","postponedCodeViewChanges","by","revealCursor","select","isVisualMode","CommandCtrlE","CommandCtrlY","CommandScrollAndMoveCursor","smoothScrolling","moveLines","actionCount","getNumLines","scrollLines","lineCount","newPositionLine","obeyStartOfLine","CommandMoveFullPageUp","visible","CommandMoveFullPageDown","CommandMoveHalfPageDown","getScrollLines","CommandMoveHalfPageUp","CommandInsertAtCursor","previousActionsNumbers","prevAction","CommandReplaceAtCursorFromNormalMode","replaceState","ReplaceState","CommandOverrideCopy","sorted","getText","getRight","earlierOf","getLineBegin","getLineEnd","iterateLinesInBlock","Clipboard","Copy","CommandCmdA","MarkCommand","markName","addMark","CommandShowCommandLine","currentCommandlineText","statusBarCursorCharacterPos","previousMode","commandLineHistoryIndex","historyEntries","CommandShowCommandHistory","CommandShowSearchHistory","direction","SearchDirection","Forward","Backward","CommandDot","CommandRepeatSubstitution","CommandFold","levels","commandName","getCursorsAfterSync","CommandToggleFold","CommandCloseFold","CommandCloseAllFolds","CommandOpenFold","CommandOpenAllFolds","CommandCloseAllFoldsRecursively","CommandOpenAllFoldsRecursively","CommandCenterScroll","TextEditorRevealType","InCenter","CommandCenterScrollFirstChar","getFirstNonWhitespaceCharOnLine","CommandTopScroll","lineNumber","CommandTopScrollFirstChar","CommandBottomScroll","CommandBottomScrollFirstChar","CommandGoToOtherEndOfHighlightedText","CommandGoToOtherSideOfHighlightedText","CommandUndo","newPositions","goBackHistoryStep","setText","alteredHistory","CommandUndoOnLine","goBackHistoryStepsOnLine","CommandRedo","goForwardHistoryStep","CommandDeleteToLineEnd","isLineEnd","linesDown","getLeftThroughLineBreaks","DeleteOperator","CommandYankFullLine","getLeft","currentRegisterMode","LineWise","YankOperator","CommandChangeToLineEnd","ChangeOperator","CommandClearLine","runRepeat","sneak","CommandExitVisualMode","CommandVisualMode","CommandReselectVisual","lastVisualSelection","mode","CommandVisualBlockMode","CommandExitVisualBlockMode","CommandVisualLineMode","CommandExitVisualLineMode","CommandOpenFile","fullFilePath","getWordLeft","WordType","FileName","getWordRight","fileInfo","filePath","FileCommand","createFileIfNotExists","execute","CommandGoToDefinition","CommandOpenLink","CommandGoBackInChangelist","originalIndex","changelistIndex","prevPos","getChangePositionAtIndex","currPos","CommandGoForwardInChangelist","nextPos","CommandGoStartPrevOperatedText","lastPos","getLastChangeStartPosition","CommandGoEndPrevOperatedText","getLastChangeEndPosition","CommandGoLastChange","getLastHistoryStartPosition","CommandInsertAtLastChange","CommandInsertAtFirstCharacter","CommandInsertAtLineBegin","CommandInsertAfterCursor","CommandInsertAtLineEnd","CommandInsertNewLineAbove","newPos","isFakeMultiCursor","CommandInsertNewLineBefore","setIndentationLevel","manuallySetCursorPositions","CommandNavigateBack","jumpBack","CommandNavigateForward","jumpForward","CommandNavigateLast","CommandNavigateLastBOL","lastJump","jump","recordJump","CommandQuit","QuitCommand","CommandOnly","OnlyCommand","MoveToRightPane","MoveToLowerPane","MoveToUpperPane","MoveToLeftPane","CycleThroughPanes","VerticalSplit","OrthogonalSplit","EvenPaneWidths","CommandTabNext","TabCommand","tab","Tab","Absolute","Next","CommandTabPrevious","Previous","ActionDeleteChar","getLeftIfEOL","ActionDeleteCharWithDeleteKey","actionsRunPressedKeys","execCount","ActionDeleteLastChar","ActionJoin","str","chCode","startPosition","startLineNumber","startColumn","endLineNumber","endColumn","columnDeltaOffset","getLineLength","trimmedLinesContent","lineText","firstNonWhitespaceIdx","firstNonWhitespaceIndex","insertSpace","lineTextWithoutIndent","deleteStartPosition","deleteEndPosition","PositionDiff","execJoinLines","ActionJoinVisualMode","ActionJoinVisualBlockMode","ActionJoinNoWhitespace","execJoin","lastLine","lines","resultLine","lastLineLength","ActionJoinNoWhitespaceVisualMode","ActionReplaceCharacter","toReplace","endPos","ActionReplaceCharacterVisual","toInsert","getTabCharacter","visualSelectionOffset","textLength","lineNum","ActionReplaceCharacterVisualBlock","isBeforeOrEqual","topLeft","visualBlockGetTopLeftPosition","ActionDeleteVisualBlock","BlockWise","put","ActionShiftDVisualBlock","ActionGoToInsertVisualBlockMode","ActionChangeInVisualBlockMode","ActionChangeToEOLInVisualBlockMode","collapseRange","ActionGoToInsertVisualLineModeCommand","cursorsOnBlankLines","cursorRange","getCursorRangeForLine","isEmptyOrWhitespace","ActionGoToInsertVisualLineMode","startCharacterPosition","firstNonWhitespaceCharacterIndex","ActionGoToInsertVisualLineModeAppend","endCharacterPosition","ActionGoToInsertVisualMode","selectionStart","selectionEnd","ActionGoToInsertVisualModeAppend","ActionGoToInsertVisualBlockModeAppend","newCursors","insertionColumn","POSITIVE_INFINITY","insertAt","newCursor","ActionDeleteLineVisualMode","ActionChangeLineVisualModeS","ActionChangeLineVisualMode","getLineEndIncludingEOL","ActionChangeLineVisualBlockMode","ActionChangeChar","ToggleCaseAndMoveForward","ToggleCaseOperator","shouldWrapKey","IncrementDecrementNumberAction","ranges","getSearchRanges","stepNum","whereToStart","wordLoop","iterateWords","NumericString","suffixOffset","pos","replaceNum","staircase","startPos","oldLength","newNum","bottomRight","visualBlockGetBottomRightPosition","IncrementNumberAction","DecrementNumberAction","IncrementNumberStaircaseAction","DecrementNumberStaircaseAction","CommandUnicodeName","charCode","ActionTriggerHover","ActionOverrideCmdD","ActionOverrideCmdDInsert","curPos","getCurrentWordEnd","matchWordPos","matchWordLength","wordBegin","ActionOverrideCmdAltDown","ActionOverrideCmdAltUp","ActionShowFileInfo","reportFileInfo","WriteQuit","WriteQuitCommand","Quit","bang","ActionGoToAlternateFile","altFile","displayError","VimError","ErrorCode","NoAlternateFile","files","findFiles","CommandTabInCommandline","isTabForward","autoCompleteItems","autoCompleteIndex","preCompleteCharacterPos","lastCmd","preCompleteCommand","evalCmd","restCmd","k","lastKeyPressed","cycleCompletion","newCompletionItems","currentCmd","cursorPos","fileRegex","commandParsers","cmd","filePathInCmd","currentUri","isRemote","remoteName","fullDirPath","baseName","partialPath","p","getPathDetails","shouldAddDotItems","readDirectory","newIndex","completion","CommandEnterInCommandline","CommandRemoveWordCommandline","cmdText","characterAt","getWordLeftInText","CommandRemoveWordInSearchMode","searchState","searchString","WordLeftInCommandline","Big","WordRightInCommandline","getWordRightInText","WordLeftInSearchMode","WordRightInSearchMode","CommandInsertInCommandline","modifiedString","CommandInsertInSearchMode","prevSearchList","searchStatePrevious","CommandEscInSearchMode","searchDirection","addSearchStateToHistory","hl","getMatchRanges","PatternNotFound","nextMatch","searchPos","getNextSearchMatchPosition","SearchHitTop","SearchHitBottom","reportSearch","searchStateIndex","CommandEscInCommandline","firstVisibleLineBeforeSearch","scrollView","CommandInsertRegisterContentInCommandLine","NothingInRegister","keyStrokes","registerMode","CommandInsertRegisterContentInSearchMode","CommandInsertWord","getWord","CommandNavigateInCommandlineOrSearchMode","statusBarText","getTrimmedStatusBarText","CommandPasteInCommandline","textFromClipboard","Paste","CommandPasteInSearchMode","CommandCtrlLInSearchMode","getNextSearchMatchRange","DefaultDigraphs","CommandEscInsertMode","returnToInsertAfterCommand","lastActionBeforeEsc","keyHistory","languageId","typeOfInsert","isTypeToRepeatInsert","changeAction","getTransformation","lastContentChanges","CommandInsertPreviousText","NoInsertedTextYet","ArrowsInInsertMode","CommandInsertPreviousTextAndQuit","CommandInsertBelowChar","charBelowCursorPosition","CommandInsertIndentInCurrentLine","originalText","indentationWidth","getIndentationLevel","tabSize","tabstop","newIndentationWidth","CommandBackspaceInInsertMode","contains","expandtab","desiredLineLength","isAtDocumentBegin","CommandDeleteInInsertMode","isAtDocumentEnd","CommandInsertInInsertMode","CommandInsertDigraph","digraph","reverseDigraph","charCodes","digraphs","reverseChars","digraphChars","CommandInsertRegisterContent","PutCommand","CommandOneNormalCommandInInsertMode","CommandCtrlW","isInLeadingWhitespace","isLineBeginning","getPreviousLineBegin","CommandDeleteIndentInCurrentLine","cursorPosition","CommandInsertAboveChar","charAboveCursorPosition","CommandCtrlUInInsertMode","getLineBeginRespectingIndent","CommandNavigateAutocompleteDown","CommandNavigateAutocompleteUp","CommandCtrlVInInsertMode","CommandShowLineAutocomplete","lineCompletionProvider","showLineCompletionsQuickPick","NewLineInsertMode","CommandReplaceAtCursorFromInsertMode","registerContent","dest","pasteBeforeCursor","forceLinewise","execVisualBlockPaste","noPrevLine","noNextLine","textToAdd","whereToAddText","adjustIndent","firstLineIdentationWidth","textToEnd","numNewlines","currentLineLength","whitespaceOnFirstLine","lineDiff","PositionDiffType","ExactCharacter","forceCursorLastLine","check","numWhitespace","characterOffset","numNewlinesAfterPut","reportLinesChanged","block","linesToAdd","lineIndex","insertPos","AscertainFromCurrentMode","effectiveRegisterMode","PutBeforeCommand","PutCommandVisual","putRegisterIsLineWise","oldMode","replaceRegisterName","replaceRegister","useSystemClipboard","yank","deletedRegisterName","deletedRegister","resultMode","PutCommandVisualLine","isMultiLinePaste","oldText","GPutCommand","addedLinesCount","newBOLDiff","GPutCommandVisualLine","repeats","GPutBeforeCommand","PutWithIndentCommand","PutBeforeWithIndentCommand","ExitReplaceMode","newChars","ReplaceModeToInsertMode","BackspaceInReplaceMode","replaceCursorStartPosition","originalChars","ReplaceInReplaceMode","searchCurrentWord","isExact","currentWord","searchStartCursorPosition","createSearchStateAndMoveToMatch","needle","NoStringUnderCursor","searchCurrentSelection","currentSelection","SearchState","isRegex","ignoreSmartcase","CommandSearchCurrentWordExactForward","CommandSearchCurrentWordForward","CommandSearchVisualForward","visualstar","CommandSearchCurrentWordExactBackward","CommandSearchCurrentWordBackward","CommandSearchVisualBackward","CommandSearchForwards","CommandSearchBackwards","selectLastSearchWord","newSearchState","getSearchMatchRangeOf","CommandSelectNextLastSearchWord","CommandSelectPreviousLastSearchWord","ExpandingSelection","Expanding","MoveByScreenLine","execActionWithCount","movementType","removed","MoveUpByScreenLine","MoveDownByScreenLine","MoveByScreenLineMaintainDesiredColumn","prevDesiredColumn","prevLine","returnedPos","MoveDownFoldFix","t","prevChar","moveDownByScreenLine","lineChanged","colChanged","MoveDown","foldfix","MoveUp","MoveUpFoldFix","moveUpByScreenLine","firstAction","newPosition","MoveLeft","MoveRight","ArrowsInReplaceMode","CommandNextSearchMatch","searchForward","CommandPreviousSearchMatch","prevMatch","VisualMark","MarkMovementVisual","mark","SelectionStart","SelectionEnd","inLineCorrection","startOrEnd","MarkNotSet","MarkMovementVisualStart","MarkMovementVisualEnd","MarkMovementVisualStartLine","MarkMovementVisualEndLine","MarkMovementBOL","getMark","isUppercaseMark","ensureEditorIsActive","MarkMovement","MoveDownNonBlank","MoveUpNonBlank","MoveDownUnderscore","MoveToColumn","findHelper","MoveFindForward","sneakReplacesF","SneakForward","ToControlCharacter","lastSemicolonRepeatableMovement","lastCommaRepeatableMovement","MoveFindBackward","SneakBackward","tilHelper","MoveTilForward","toFind","MoveTilBackward","MoveRepeat","movement","MoveRepeatReversed","semiColonMovement","commaMovement","MoveLineEnd","MoveLineBegin","MoveScreenLineBegin","MoveScreenNonBlank","MoveScreenLineEnd","MoveScreenLineEndNonBlank","MoveScreenLineCenter","MoveUpByDisplayLine","MoveDownByDisplayLine","MoveUpByScreenLineVisualLine","MoveDownByScreenLineVisualLine","MoveUpByScreenLineVisualBlock","MoveDownByScreenLineVisualBlock","MoveScreenToRight","MoveScreenToLeft","MoveScreenToRightHalf","MoveScreenToLeftHalf","MoveToLineFromViewPortTop","MoveToLineFromViewPortBottom","MoveToMiddleLineInViewPort","MoveNonBlank","MoveNextLineNonBlank","MoveNonBlankFirst","withLine","MoveNonBlankLast","MoveWordBegin","isLastIteration","changeWordIncludesWhitespace","isFirstWordOfLine","MoveFullWordBegin","getCurrentBigWordEnd","getBigWordRight","MoveWordEnd","MoveFullWordEnd","MoveLastWordEnd","getLastWordEnd","MoveLastFullWordEnd","getLastBigWordEnd","MoveBeginningWord","MoveBeginningFullWord","getBigWordLeft","MovePreviousSentenceBegin","getSentenceBegin","forward","MoveNextSentenceBegin","MoveParagraphEnd","iteration","isFirstLineWise","hasOperator","paragraphEnd","getCurrentParagraphEnd","isLineWise","MoveParagraphBegin","getCurrentParagraphBeginning","MoveSectionBoundary","boundary","MoveNextSectionBegin","MoveNextSectionEnd","MovePreviousSectionBegin","MovePreviousSectionEnd","MoveToMatchingBracket","failure","col","pairing","PairMatcher","pairings","matchesWithPercentageMotion","nextPairedChar","targetLine","MoveInsideCharacter","includeSurrounding","closingChar","charToMatch","cursorStartPos","adjacentPosLeft","adjacentPosRight","adjacentCharLeft","getCharAt","adjacentCharRight","startPlusOne","isAfterOrEqual","isBefore","operatorPositionDiff","MoveInsideParentheses","MoveAroundParentheses","MoveInsideCurlyBrace","MoveAroundCurlyBrace","MoveInsideCaret","MoveAroundCaret","MoveInsideSquareBracket","MoveAroundSquareBracket","MoveQuoteMatch","quoteMatcher","QuoteMatcher","findOpening","findClosing","hasRunOperator","MoveInsideSingleQuotes","MoveAroundSingleQuotes","MoveInsideDoubleQuotes","MoveAroundDoubleQuotes","MoveInsideBacktick","MoveAroundBacktick","MoveToUnclosedRoundBracketBackward","MoveToUnclosedRoundBracketForward","MoveToUnclosedCurlyBracketBackward","MoveToUnclosedCurlyBracketForward","MoveTagMatch","includeTag","editorText","offsetAt","tagMatcher","TagMatcher","positionAt","endPosition","MoveInsideTag","MoveAroundTag","BaseOperator","doesRepeatedOperatorApply","nonCountActions","highlightedyank","yankDecoration","createTextEditorDecorationType","backgroundColor","color","textColor","setDecorations","dispose","duration","isOnLastLine","resultingPosition","ObeyStartOfLine","numLinesDeleted","DeleteOperatorVisual","originalMode","extendedEnd","highlightYankedRanges","moveCursor","TextObjectMovement","cursorsInitialState","numLinesYanked","reportLinesYanked","FilterOperator","ShiftYankOperatorVisual","DeleteOperatorXVisual","ChangeOperatorSVisual","FormatOperator","newCursorPosition","UpperCaseOperator","UpperCaseWithMotion","UpperCaseVisualBlockOperator","LowerCaseOperator","LowerCaseWithMotion","LowerCaseVisualBlockOperator","IndentOperator","IndentOperatorInVisualModesIsAWeirdSpecialCase","isRunningDotCommand","dotCommandPreviousVisualSelection","shiftSelectionByNum","OutdentOperator","OutdentOperatorInVisualModesIsAWeirdSpecialCase","isEndOfLine","thisLineIndent","autoindent","YankVisualBlockMode","toCopy","isMultiline","toggleCase","newText","toggled","toLocaleUpperCase","ToggleCaseVisualBlockOperator","ToggleCaseWithMotion","CommentOperator","ROT13Operator","original","rot13","A","CommentBlockOperator","ActionVisualReflowParagraph","indent","getIndentation","indentLevel","maximumLineLength","textwidth","chunksToReflow","lastChunk","trimmedLine","commentType","CommentTypes","final","singleLine","inner","content","indentLevelAfterComment","indentAfterComment","curIndex","textToReflow","reflowParagraph","buildTriggerKeys","trigger","leaderCount","BaseEasyMotionCommand","baseOptions","_baseOptions","clearMarkers","markerGenerator","MarkerGenerator","matchPosition","resolveMatchPosition","generateMarker","addMarker","searchOptions","easymotion","getMatches","EasyMotion","processMarkers","markers","getMatchesForString","sortedSearch","regexFlags","ignorecase","smartcase","_options","charCount","labelPosition","removeTrailingLineBreak","EasyMotionCharMoveCommandBase","_action","searchAction","getMatchesForWord","regex","jumpToAnywhere","easymotionJumpToAnywhereRegex","getMatchesForLineStart","EasyMotionCharInputMode","shouldFire","fire","CommandEscEasyMotionCharInputMode","MoveEasyMotion","nail","accumulation","findMarkers","visibleMarkers","decorations","decorationTypeCache","getDecorationType","fade","hide","onlyVisible","specialCharactersRegex","lineMin","lineMax","lineIdx","Match","computeAboluteDiff","matchIndex","absDiff","customizedValue","themeColorId","ThemeColor","getMarkerColor","easymotionMarkerBackgroundColor","easymotionMarkerForegroundColorOneChar","easymotionMarkerForegroundColorTwoCharFirst","easymotionMarkerForegroundColorTwoCharSecond","easymotionDimColor","dimmingZones","dimmingRenderOptions","getEasymotionDimColor","hiddenChars","keystroke","nextKeystroke","firstCharFontColor","getEasymotionMarkerForegroundColorTwoCharFirst","getEasymotionMarkerForegroundColorOneChar","getEasymotionMarkerBackgroundColor","firstCharRange","firstCharRenderOptions","contentText","margin","easymotionMarkerFontWeight","height","renderOptions","dark","light","secondCharFontColor","getEasymotionMarkerForegroundColorTwoCharSecond","secondCharRange","secondCharRenderOptions","easymotionDimBackground","prevMarker","prevKeystroke","prevDimPos","offsetPrevDimPos","getDocumentEnd","matchesCount","keyTable","getKeyTable","prefixKeyTable","createPrefixKeyTable","markerPosition","currentStep","totalRemainder","totalSteps","reversed","easymotionKeys","startingLetter","sneakUseIgnorecaseAndSmartcase","whichwrap","_logger","_history","CommandLineHistory","recState","commandList","parser","enableNeovim","neovimCapable","nvim","NotAnEditorCommand","initialText","showInputBox","getInputBoxOptions","prompt","ignoreFocusOut","valueSelection","showQuickPick","placeHolder","BangCommand","node","CommandBase","_arguments","externalCommand","startLine","endLine","output","getReplaceDiff","BufferDeleteCommand","NoWriteSinceLastChange","tabPosition","NoBuffersDeleted","CloseCommand","visibleTextEditors","CannotCloseLastWindow","oldViewColumn","viewColumn","DeleteRangeCommand","deleteRange","DigraphsCommand","quickPicks","digraphKey","charDesc","label","description","digraphKeyAndContent","makeQuickPicks","then","val","FilePosition","editorFileUri","editorFilePath","fsPath","NewWindowVerticalSplit","NewWindowHorizontalSplit","hidePreviousEditor","scheme","untildify","fileUri","fileList","showOpenDialog","fullPath","uriPath","resolveUri","fileExists","doesFileExist","pathWithExt","uriPathWithExt","FileInfoCommand","GotoCommand","scanner","Scanner","nextWord","TrailingCharacters","gotoOffset","HistoryCommandType","HistoryCommand","Cmd","Search","Expr","Input","Debug","All","JumpPickItem","detail","JumpsCommand","hasJumps","quickPickItems","jumps","item","canPickMany","ClearJumpsCommand","clearJumps","MarkQuickPickItem","picked","alwaysShow","MarksCommand","marksFilter","getMarks","DeleteMarksCommand","numbers","numberRange","letterRange","ArgumentRequired","removeLocalMarks","removeMarks","numberArgs","letterArgs","InvalidArgument","caseMismatch","letters","NohlCommand","PutExCommand","doPut","duplicatedInSplit","quitAll","ReadCommand","textToInsert","getTextToInsert","file","getTextToInsertFromFile","getTextToInsertFromCmd","readFileAsync","SUPPORT_READ_COMMAND","cp","err","stdout","stderr","RegisterCommand","getRegisterDisplayValue","specials","registers","displayRegisterValue","currentRegisterKeys","reg","reg1","reg2","regSortOrder","registerKeyAndContent","SetOptionOperator","SetOptionsCommand","optionName","optionAliases","UnknownOption","Reset","Equal","Invert","Append","Subtract","initialValue","Info","ShCommand","createTerminal","show","SmileCommand","smileText","SortCommand","sortLines","originalLines","currentLine","unique","sortedLines","ignoreCase","localeCompare","sortedContent","SubstituteFlags","SubstituteCommand","_abort","flags","ConfirmEach","jsRegexFlags","gdefault","substituteGlobalFlag","ReplaceAll","IgnoreCase","prevSubstituteState","substituteState","searchPattern","NoPreviousRegularExpression","replaceString","prevSearchState","SubstituteState","originalContent","newContent","nonGlobalRegex","matchPos","confirmReplacement","rangeEnd","replacement","cancellationToken","CancellationTokenSource","validSelections","searchRanges","decoration","searchHighlight","validateInput","token","getRegex","replaceTextAtLine","foundPattern","executeCommandWithCount","First","Last","New","isInWorkspace","workspaceFolders","currentFilePath","toOpenPath","workspacePath","Uri","Close","Only","Move","UndoCommand","WallCommand","saveAll","WriteCommand","opt","append","background","fs","accessAsync","constants","W_OK","save","accessErr","chmodAsync","bgWrite","writeArgs","optValue","writeCmd","write","quitArgs","quitCmd","quit","WriteQuitAllCommand","wallCmd","wall","emitToken","state","Token","LexerFunctions","f","lexRange","isAtEof","TokenType","Comma","Percent","Dollar","Dot","lexForwardSearch","lexReverseSearch","lexDigits","LineNumber","previousTokenType","Plus","Minus","Offset","ignore","SelectionFirstLine","SelectionLastLine","lexMark","CommandName","lexCommandArgs","lexCommand","c","Mark","backup","tokenType","CommandArgs","escaping","searchTerm","ForwardSearch","ReverseSearch","LineRange","tok","boundsCheck","resolveLineRef","toks","currentLineNum","currentOperation","firstToken","tokenIndex","currentToken","executeWithRange","parseLineRange","Eof","addToken","parseCommand","commandParser","getParser","argsTok","CommandLine","ParserState","lex","EOF","wordSeparators","skipRun","parseBangCommand","bdelete","abbrev","parseBufferDeleteCommandArgs","bfirst","blast","bmodified","bnext","tabCmd","parseTabNCommandArgs","bNext","parseTabPCommandArgs","bprevious","brewind","buffers","center","clearjumps","close","parseCloseCommandArgs","parseDeleteRangeLinesCommandArgs","delmarks","parseMarksRemoveCommandArgs","parseDigraphCommandArgs","display","parseRegisterCommandArgs","fileCmd","parseEditFileCommandArgs","enew","parseEditNewFileCommandArgs","parseFileInfoCommandArgs","goto","help","history","parseHistoryCommandArgs","ls","marks","parseMarksCommandArgs","move","new","parseEditNewFileInNewHorizontalWindowCommandArgs","nohlsearch","normal","only","parsePutExCommandArgs","qall","parseQuitAllCommandArgs","parseQuitCommandArgs","quitall","read","parseReadCommandArgs","parseOptionsCommandArgs","shell","smile","parseSortCommandArgs","parseEditFileInNewHorizontalWindowCommandArgs","substitute","parseSubstituteCommandArgs","tabclose","parseTabCloseCommandArgs","tabedit","parseTabNewCommandArgs","tabfirst","parseTabFirstCommandArgs","tablast","parseTabLastCommandArgs","tabmove","parseTabMovementCommandArgs","tabnew","tabnext","tabNext","tabonly","parseTabOnlyCommandArgs","tabprevious","undo","vglobal","vnew","parseEditNewFileInNewVerticalWindowCommandArgs","vsplit","parseEditFileInNewVerticalWindowCommandArgs","parseWallCommandArgs","wq","parseWriteQuitCommandArgs","wqall","parseWriteQuitAllCommandArgs","parseWriteCommandArgs","xall","fullName","parserMapping","UnimplementedCommand","commandText","scannedArgs","skipWhiteSpace","regs","parseOption","optionArgs","Multiply","parsePattern","currentChar","None","secondDelimiterFound","KeepPreviousFlags","SuppressError","NoIgnoreCase","PrintCount","PrintLastMatchedLine","PrintLastMatchedLineWithNumber","PrintLastMatchedLineWithList","UsePreviousPattern","parseSubstituteFlags","countStr","parseCount","isDigit","nextWhile","parseCountOrOffset","expect","expectOneOf","charToFind","charToStack","stackHeight","isNextMatchForward","allowCurrentPosition","linePosition","cursorChar","keepSearching","originalLineLength","nextChar","pairMemberChar","directionless","matchedPos","findPairedChar","cfgKey","currentPosition","charactersToMatch","shouldDeleteMatchingBracket","deleteText","matchRange","isNextMatch","QuoteMatch","corpus","quoteMap","openingQuote","escapeChar","Opening","Closing","TAG_REGEX","tags","CLOSE_FORWARD_SLASH","TAG_NAME","OPEN_FORWARD_SLASH","matchedTags","openNode","openingTagStart","openingTagEnd","closingTagStart","closingTagEnd","firstNonWhitespacePositionOnLine","startPosOffset","endPosOffset","tagsSurrounding","nodeSurrounding","determineRelevantTag","compareTo","openStart","closeEnd","openEnd","closeStart","adjustedStartPosOffset","selectionActive","relevantTag","inclusive","p1","p2","resultChar","validatePosition","getLineCount","column","includeEol","getOffsetThroughLineBreaks","getSentenceEnd","getNextLineBegin","newlines","startofline","isValid","sel","numLength","negative","coreBegin","coreLength","coreRadix","coreSign","matchings","coreEnd","core","numPrefix","8","10","16","linesWithoutIndentation","lineToStartScanFrom","scanAboveFirst","distanceFromStartLine","sortPriority","getCompletionsForCurrentLine","currentFileName","matchedLines","startingFileName","documentsStartingWith","getCompletionsForText","completions","selectedCompletion","extensionVersion","packagejson","Configuration","leaderDefault","cursorTypeMap","TextEditorCursorStyle","Line","Block","underline","Underline","LineThin","BlockOutline","UnderlineThin","handleKeys","useCtrlKeys","overrideCopy","hlsearch","camelCaseMotion","replaceWithRegister","smartRelativeLine","argumentObjectSeparators","argumentObjectOpeningDelimiters","argumentObjectClosingDelimiters","easymotionMarkerForegroundColorTwoChar","easymotionIncSearchForegroundColor","easymotionMarkerWidthPerChar","easymotionMarkerFontFamily","easymotionMarkerFontSize","easymotionMarkerMargin","autoSwitchInputMethod","defaultIM","obtainIMCmd","switchIMCmd","maxmapdepth","showcmd","showmodename","incsearch","statusBarColorControl","statusBarColors","visual","visualline","visualblock","silent","loggingLevelForAlert","loggingLevelForConsole","searchHighlightColor","searchHighlightTextColor","mouseSelectionGoesIntoVisualMode","neovimPath","neovimUseConfigFile","neovimConfigPath","showMarksInGutter","report","wrapscan","scroll","cursorStylePerMode","insertModeKeyBindings","insertModeKeyBindingsNonRecursive","normalModeKeyBindings","normalModeKeyBindingsNonRecursive","operatorPendingModeKeyBindings","operatorPendingModeKeyBindingsNonRecursive","visualModeKeyBindings","visualModeKeyBindingsNonRecursive","commandLineModeKeyBindings","commandLineModeKeyBindingsNonRecursive","vimConfigs","mockConfiguration","option","unproxify","SUPPORT_VIMRC","vimrcModel","clearKeyBindingsMaps","configurationValidator","validate","keybinding","contributes","keybindings","when","mac","linux","useKey","handleKey","section","resource","cursorStyle","normalModeKeyBindingsMap","insertModeKeyBindingsMap","visualModeKeyBindingsMap","commandLineModeKeyBindingsMap","operatorPendingModeKeyBindingsMap","cursorStyleFromString","editorCursorStyleRaw","obj","overlapSetting","propertyKey","settingName","vscodeSetting","vimSetting","ConfigurationTarget","Global","enumerable","configurable","_validators","validator","config","ValidatorResults","hasError","disable","_markDecorationCache","svg","isWholeLine","gutterIconPath","gutterIconSize","_default","_searchHighlight","_easyMotionIncSearch","_easyMotionDimIncSearch","decorationType","getMarkDecoration","_createMarkDecoration","_insertModeVirtualCharacter","_operatorPendingModeCursor","_operatorPendingModeCursorChar","default","borderColor","borderStyle","borderWidth","overviewRulerColor","easyMotionIncSearch","fontWeight","easyMotionDimIncSearch","insertModeVirtualCharacter","operatorPendingModeCursor","operatorPendingModeCursorChar","errors","validationResult","validationResults","numWarnings","isSurroundedByAngleBrackets","leaderKey","standardNotation","_notationMap","shiftedLetterRegex","normalized","remappers","InsertModeRemapper","NormalModeRemapper","VisualModeRemapper","CommandLineModeRemapper","OperatorPendingModeRemapper","r","isPotentialRemap","remapper","sendKey","Remapper","configKey","remappedModes","_isPotentialRemap","_hasPotentialRemap","_configKey","_remappedModes","allowPotentialRemapOnFirstKey","remainingKeys","allowBufferingKeys","currentModeIncludingPseudoModes","userDefinedRemappings","TimeoutFinished","remapping","findMatchingRemap","hasPotentialRemap","_hasAmbiguousRemap","resetCommandList","wasPerformingRemapThatFinishedWaitingForTimeout","lastRemapLength","keysPressedByUser","ForceStopRemappingError","bufferedKeys","bufferedKeysTimeoutObj","newRemapping","skipFirstCharacter","hasParentRemapping","isCurrentlyPerformingRemapping","mapDepth","recursive","isCurrentlyPerformingNonRecursiveRemapping","remapFailed","vimError","RecursiveMapping","fromVimError","ms","remapUsedACharacter","handleRemapping","finishCurrentStep","specialKey","lastRemapWithoutAmbiguousRemap","commandString","commandArgs","inputtedKeys","getRemappedKeysLengthRange","startingSliceLength","inputtedString","sliceLength","keySlice","verbose","precedingKeys","remappings","keyLengths","remap","countRemapAsPotential","keysAsString","re","keyBindingsConfigKey","OperatorPendingMode","InputMethodSwitcherConfigurationValidator","inputMethodConfig","existsAsync","getRawCmd","registerValidator","RemappingValidator","modeKeyBindingsKeys","modeKeyBindingsKey","isRecursive","modeMapName","modeKeyBindingsMap","remappingError","isRemappingValid","beforeKeys","isCommandValid","getCommandMap","_commandMap","getCommands","ErrorMessage","20","23","29","32","34","35","37","208","223","348","353","384","385","444","471","474","486","488","492","516","518","extraValue","reason","HistoryFile","historyFileName","_base","HistoryBase","extensionStoragePath","historyKey","diffEngine","DiffMatchPatch","DocumentChange","isAdd","_text","do","_end","HistoryStep","init","isFinished","cursorStart","cursorEnd","timestamp","timeDiffMillis","timeDiffSeconds","getHours","getMinutes","getSeconds","globalMarks","UndoStack","historySteps","currentStepIndex","initialMarks","getCurrentHistoryStep","undoStack","previousDocumentState","_getDocumentText","versionNumber","_getDocumentVersion","previousMarks","getAllCurrentDocumentMarks","newMarks","newMark","ch","docEnd","isFileMark","getCurrentMarkList","getLocalMarks","putMarkInList","getMarkList","previousIndex","existingMark","markNames","whatHappened","added","DIFF_INSERT","pushChange","getStackDepth","removedChanges","removedChange","characterDelta","currentHistoryStep","updateAndReturnMarks","stepBackward","getCurrentHistoryStepIndex","howLongAgo","stepsToUndo","changesToUndo","mostRecentText","stepIdx","getHistoryStepAtIndex","newStep","pushHistoryStep","stepForward","lastChangeIndex","_jumps","_currentJumpNumber","isJumpingThroughHistory","isSamePosition","pushJump","jumpThroughHistory","recordJumpForward","recordJumpBack","getJump","iterations","performFileJump","distance","changePositionForJumpNumber","newLineShiftedUp","removeDuplicateJumps","clearJumpsOnSamePosition","clearOldJumps","linesSeenPerFile","VSCodeVimCursorType","cursorType","TextDecoration","Native","ModeHandler","handlerMap","_disposables","_handlerMap","_remappers","Remappers","VimState","RemapState","_currentMode","isSnippetSelectionChange","allowedModes","Command","isStatusBarMode","toDraw","lastClickWasPastEol","newStart","printableKey","oldFullMode","oldStatusBarText","oldWaitingForAnotherActionKey","waitingForAnotherActionKey","handledAsRemap","handledAsAction","preventZeroRemap","getLastActionRun","handleKeyAsAnAction","lastKeyPressedTimestamp","updateShowCmd","forceClearStatusBar","lastMovementFailed","addChange","getRelevantAction","actionToRecord","addChanges","newContentChange","runAction","isInsertion","fromStateBefore","ranRepeatableAction","ranAction","executeMovement","executeTransformations","prevMode","operatorReadyToExecute","executeOperator","createUndoPointForBrackets","previousFullAction","preservesDesiredColumn","ignoreChange","isReplayingMacro","documentEndPosition","documentLineCount","withNewStart","currentStartLineLength","offsetAllowed","setLastHistoryEndPosition","cursorsToRemove","oldCursorPositionStart","oldCursorPositionStop","startingMode","startingRegisterMode","operators","resultingRange","hasRunSurround","surroundKeys","recordedMacro","originalLocation","showHighlights","selectionMode","combinedSelections","previousSelection","getSelectionsCombined","isLastCursorTracked","cursorToTrack","isCursorAboveRange","isCursorBelowRange","revealType","Default","getCursorStyleForMode","getCursorType","getCursorStyle","editorCursorStyle","cursorStop","iModeVirtualCharDecorationOptions","virtualKey","eolRenderOptions","opCursorDecorations","opCursorCharDecorations","markDecoration","allMarkDecorations","getOrCreateMarkDecoration","markLine","markRange","updateSearchHighlights","easyMotionDimRanges","SearchByNCharCommand","getDocumentBegin","easyMotionHighlightRanges","toRange","viewChange","updateDecorations","modeHandlerMap","editorId","SUPPORT_NVIM","SUPPORT_IME_SWITCHER","UV_FS_SYMLINK_DIR","UV_FS_SYMLINK_JUNCTION","O_RDONLY","O_WRONLY","O_RDWR","UV_DIRENT_UNKNOWN","UV_DIRENT_FILE","UV_DIRENT_DIR","UV_DIRENT_LINK","UV_DIRENT_FIFO","UV_DIRENT_SOCKET","UV_DIRENT_CHAR","UV_DIRENT_BLOCK","S_IFMT","S_IFREG","S_IFDIR","S_IFCHR","S_IFBLK","S_IFIFO","S_IFLNK","S_IFSOCK","O_CREAT","O_EXCL","UV_FS_O_FILEMAP","O_NOCTTY","O_TRUNC","O_APPEND","O_DIRECTORY","O_NOFOLLOW","O_SYNC","O_DSYNC","O_SYMLINK","O_NONBLOCK","S_IRWXU","S_IRUSR","S_IWUSR","S_IXUSR","S_IRWXG","S_IRGRP","S_IWGRP","S_IXGRP","S_IRWXO","S_IROTH","S_IWOTH","S_IXOTH","F_OK","R_OK","X_OK","UV_FS_COPYFILE_EXCL","COPYFILE_EXCL","UV_FS_COPYFILE_FICLONE","COPYFILE_FICLONE","UV_FS_COPYFILE_FICLONE_FORCE","COPYFILE_FICLONE_FORCE","stat","_e","encoding","readFile","createDirectory","writeFile","_context","_historyFileName","_extensionStoragePath","workspaceState","parsedData","VsCodeMessage","actionMessages","errorMessage","log","debugMessage","warnMessage","verboseMessage","info","showMessage","console","isBlackHoleRegister","isReadOnlyRegister","isValidUppercaseRegister","appendMulticursorRegister","putMulticursorRegister","appendNormalRegister","putNormalRegister","isValidLowercaseRegister","specialRegisters","isClipboardRegister","clipboardText","processNumberedRegister","appendToRegister","createEmptyRegister","force","baseOperator","registerText","supportNode","serializable","writeFileAsync","savedRegisters","_searchStatePrevious","JumpTracker","_searchHistory","SearchHistory","states","prevSearchString","items","surroundKeyIndexStart","Transformer","regexEscape","regexLeader","regexBufferedKeys","hasRunAMovement","supportsLookbehind","matchRanges","_searchString","recalculateSearchRanges","oldNeedle","needleSegments","notEscapedQuestionMarkRegex","notEscapedSlashRegex","searchOffsetBeginRegex","searchOffsetEndRegex","_needleRegex","searchRE","ignorecaseOverride","caseOverrideRegex","cached","startOffset","needleRegex","wrappedOver","MAX_SEARCH_RANGES","_cursors","_cursorsInitialState","isOperatorPending","_inputMethodSwitcher","switchInputMethod","lineNumbers","TextEditorLineNumbersStyle","On","Relative","NeovimWrapper","ime","InputMethodSwitcher","leadingChar","searchWithCursor","commandWithCursor","statusBarCommandText","searchCharCount","wentOverEOL","pendingCommandString","_previousModeName","_showingDefaultMessage","_statusBarItem","createStatusBarItem","StatusBarAlignment","Left","MIN_SAFE_INTEGER","_recordedStateStatusBarItem","Right","hasModeChanged","updateText","updateColor","macroText","escaped","foreground","colorToSet","workbenchConfiguration","currentColorCustomizations","colorCustomizations","_taskQueue","queueName","tasks","isRunning","isHighPriority","promise","reportButton","showErrorMessage","body","dequeueTask","numHighPriority","runTasks","letVSCodeHandleKeystrokes","editBuilder","firstNonBlank","whitespaceRegExp","iskeyword","foundRealWord","includeInWord","insertSpaces","visibleColumn","screenCharacters","indentString","itrStart","itrEnd","runToLineEnd","endCharacter","wordEnd","isLineBlank","trimWhite","getLine","sentenceEndRegex","getFirstNonWhitespaceInParagraph","newCharacter","getAllPositions","getAllEndPositions","getNextSentenceBegin","paragraphBegin","getPreviousSentenceBegin","SelectWord","SelectABigWord","SelectAnExpandingBlock","blocks","smallestRange","iMotion","currentSelectedRange","contender","equals","SelectInnerWord","SelectInnerBigWord","SelectSentence","currentSentenceBegin","currentSentenceNonWhitespaceEnd","nextSentenceBegin","SelectInnerSentence","SelectParagraph","currentParagraphBegin","SelectInnerParagraph","SelectEntire","SelectEntireIgnoringLeadingTrailing","IndentObjectMatch","includeLineAbove","includeLineBelow","isChangeOperator","firstValidLineNumber","findFirstValidLine","cursorIndent","findRangeStartOrEnd","startCharacter","startIndex","InsideIndentObject","InsideIndentObjectAbove","InsideIndentObjectBoth","SelectArgument","selectAround","leftSearchStartPosition","rightSearchStartPosition","charAtPos","separatorCharacters","openingDelimiterCharacters","closingDelimiterCharacters","SelectInnerArgument","findLeftArgumentBoundary","findRightArgumentBoundary","leftArgumentBoundary","rightArgumentBoundary","isLeftOnOpening","isRightOnClosing","ignoreSeparators","delimiterPosition","walkingPosition","closedParensCount","isOnBoundary","openedParensCount","SelectAroundArgument","positions","nonWordCharRegex","keywordChars","CharKind","symbolTable","Punctuation","Superscript","Subscript","Braille","Hiragana","Katakana","Ideograph","Hangul","codePointRangePatterns","escapedKeywordChars","codePointRanges","patterns","symbolSegments","wordSegment","segments","makeUnicodeWordRegex","nonBigWordCharRegex","makeWordRegex","nonCamelCaseWordCharRegex","characterSet","firstSegment","makeCamelCaseWordRegex","nonFileNameRegex","regexForWordType","wordType","CamelCase","getWordLeftOnLine","forceFirst","textTransformations","multicursorTextTransformations","isMultiCursorTextTransformation","otherTransformations","accumulatedPositionDifferences","doTextEditorEdit","immediateMatchingBracket","areAnyTransformationsOverlapping","areAllSameTransformation","FromVSCodeSelection","showHistory","showSearchHistory","rerunRecordedState","runMacro","firstTransformation","getRangeFromTextTransformation","firstRange","secondRange","overlaps","clipboard","writeText","readText","previousExternalCommand","NoPreviousCommand","inputFile","outputFile","pipeIndex","SHELL","stdin","getRandomFileName","expandCommand","redirectCommand","promisify","unlink","LoggerImpl","os","separatePath","searchPath","baseNameIndex","absolutePath","isWindows","isLocalUntitled","updatedPartialPath","dirName","addCurrentAndUp","directoryUri","FileType","Directory","numLinesChanged","progress","matchIdx","numMatches","homeDirectory","pathWithTilde","ctor","superCtor","super_","writable","TempCtor","readUInt8","getOwnPropertyDescriptors","descriptors","getOwnPropertyDescriptor","formatRegExp","objects","inspect","deprecate","msg","noDeprecation","warned","throwDeprecation","traceDeprecation","trace","debugEnviron","debugs","opts","ctx","stylize","stylizeNoColor","colors","showHidden","_extend","customInspect","stylizeWithColor","formatValue","styleType","style","styles","recurseTimes","primitive","simple","formatPrimitive","visibleKeys","arrayToHash","getOwnPropertyNames","formatError","braces","toUTCString","l","formatProperty","formatArray","cur","reduceToSingleString","desc","ar","debuglog","NODE_DEBUG","pid","isNullOrUndefined","isPrimitive","months","getDate","getMonth","inherits","origin","kCustomPromisifiedSymbol","callbackifyOnRejected","cb","newReason","promiseResolve","promiseReject","setPrototypeOf","defineProperties","custom","callbackify","callbackified","maybeCb","rej","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","globalThis","nmd","children","activate"],"mappings":"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AAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IACvE,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IACvE,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IACvE,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IACvE,EAAU,IAAM,EAAU,IAC1B,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IACvE,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IACvE,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IACxD,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IACtF,EAAU,IAAM,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IAAK,EAAU,IACtF,EAAU,IAAM,EAAU,IAC1B,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,IAAM,EAAU,IAAK,EAAU,IACzC,EAAU,KAAM,EAAU,K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,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,MAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAO,CAAC,IAAK,KACb,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,MAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAO,CAAC,IAAK,MACb,KAAO,CAAC,IAAK,MACb,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAO,CAAC,IAAK,OACb,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAO,CAAC,IAAK,OACb,KAAO,CAAC,IAAK,OACb,KAAO,CAAC,IAAK,OACb,KAAO,CAAC,IAAK,OACb,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAO,CAAC,IAAK,OACb,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC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","file":"extensionWeb.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nvar diff_match_patch = function() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n};\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * ~Attempts to look like a two-element array (which is what this used to be).~\n * Constructor returns an actual two-element array, to allow destructing @JackuB\n * See https://github.com/JackuB/diff-match-patch/issues/14 for details\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\ndiff_match_patch.Diff = function(op, text) {\n  return [op, text];\n};\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number=} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));\n  }\n  if (commonsuffix) {\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),\n             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),\n             new diff_match_patch.Diff(DIFF_INSERT,\n                 longtext.substring(i + shorttext.length))];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n            new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],\n                          diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var subDiff =\n              this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = subDiff.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, subDiff[j]);\n          }\n          pointer = pointer + subDiff.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n          new diff_match_patch.Diff(DIFF_INSERT, text2)];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        if (lineArrayLength == maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.substring(lineStart);\n          lineEnd = text.length;\n        }\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n      lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  // Allocate 2/3rds of the space for text1, the rest for text2.\n  var maxLines = 40000;\n  var chars1 = diff_linesToCharsMunge_(text1);\n  maxLines = 65535;\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var i = 0; i < diffs.length; i++) {\n    var chars = diffs[i][1];\n    var text = [];\n    for (var j = 0; j < chars.length; j++) {\n      text[j] = lineArray[chars.charCodeAt(j)];\n    }\n    diffs[i][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastEquality && (lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastEquality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastEquality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastEquality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastEquality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastEquality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n                    text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] =\n              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);\n        } else {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  if (patch.start2 === null) {\n    throw Error('patch not initialized');\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // https://github.com/google/diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] =\n          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indices are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports['diff_match_patch'] = diff_match_patch;\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;","/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.20';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('dj vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = _)._ = _;\n    // Export for CommonJS support.\n    freeExports._ = _;\n  }\n  else {\n    // Export to the global object.\n    root._ = _;\n  }\n}.call(this));\n","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","import * as vscode from 'vscode';\nimport * as path from 'path';\n\nimport { CompositionState } from './src/state/compositionState';\nimport { EditorIdentity } from './src/editorIdentity';\nimport { Globals } from './src/globals';\nimport { Jump } from './src/jumps/jump';\nimport { ModeHandler } from './src/mode/modeHandler';\nimport { ModeHandlerMap } from './src/mode/modeHandlerMap';\nimport { Mode } from './src/mode/mode';\nimport { Notation } from './src/configuration/notation';\nimport { Logger } from './src/util/logger';\nimport { StatusBar } from './src/statusBar';\nimport { VSCodeContext } from './src/util/vscodeContext';\nimport { commandLine } from './src/cmd_line/commandLine';\nimport { configuration } from './src/configuration/configuration';\nimport { globalState } from './src/state/globalState';\nimport { taskQueue } from './src/taskQueue';\nimport { Register, RegisterMode } from './src/register/register';\nimport { SpecialKeys } from './src/util/specialKeys';\nimport { HistoryTracker } from './src/history/historyTracker';\n\nlet extensionContext: vscode.ExtensionContext;\nlet previousActiveEditorId: EditorIdentity | undefined;\nlet lastClosedModeHandler: ModeHandler | null = null;\n\ninterface ICodeKeybinding {\n  after?: string[];\n  commands?: Array<{ command: string; args: any[] }>;\n}\n\nexport async function getAndUpdateModeHandler(\n  forceSyncAndUpdate = false\n): Promise<ModeHandler | undefined> {\n  const activeTextEditor = vscode.window.activeTextEditor;\n  if (activeTextEditor === undefined || activeTextEditor.document.isClosed) {\n    return undefined;\n  }\n\n  const activeEditorId = EditorIdentity.fromEditor(activeTextEditor);\n\n  const [curHandler, isNew] = await ModeHandlerMap.getOrCreate(activeEditorId);\n  if (isNew) {\n    extensionContext.subscriptions.push(curHandler);\n  }\n\n  curHandler.vimState.editor = activeTextEditor;\n\n  if (\n    forceSyncAndUpdate ||\n    !previousActiveEditorId ||\n    !previousActiveEditorId.isEqual(activeEditorId)\n  ) {\n    // We sync the cursors here because ModeHandler is specific to a document, not an editor, so we\n    // need to update our representation of the cursors when switching between editors for the same document.\n    // This will be unnecessary once #4889 is fixed.\n    curHandler.syncCursors();\n    await curHandler.updateView({ drawSelection: false, revealRange: false });\n  }\n\n  previousActiveEditorId = activeEditorId;\n\n  if (curHandler.vimState.focusChanged) {\n    curHandler.vimState.focusChanged = false;\n\n    if (previousActiveEditorId) {\n      const prevHandler = ModeHandlerMap.get(previousActiveEditorId);\n      prevHandler!.vimState.focusChanged = true;\n    }\n  }\n\n  return curHandler;\n}\n\n/**\n * Loads and validates the user's configuration\n */\nasync function loadConfiguration() {\n  const validatorResults = await configuration.load();\n\n  Logger.configChanged(configuration);\n\n  const logger = Logger.get('Configuration');\n  logger.debug(`${validatorResults.numErrors} errors found with vim configuration`);\n\n  if (validatorResults.numErrors > 0) {\n    for (const validatorResult of validatorResults.get()) {\n      switch (validatorResult.level) {\n        case 'error':\n          logger.error(validatorResult.message);\n          break;\n        case 'warning':\n          logger.warn(validatorResult.message);\n          break;\n      }\n    }\n  }\n}\n\n/**\n * The extension's entry point\n */\nexport async function activate(context: vscode.ExtensionContext, handleLocal: boolean = true) {\n  // before we do anything else, we need to load the configuration\n  await loadConfiguration();\n\n  const logger = Logger.get('Extension Startup');\n  logger.debug('Start');\n\n  extensionContext = context;\n  extensionContext.subscriptions.push(StatusBar);\n\n  // Load state\n  Register.loadFromDisk(handleLocal);\n  await Promise.all([commandLine.load(extensionContext), globalState.load(extensionContext)]);\n\n  if (vscode.window.activeTextEditor) {\n    const filepathComponents = vscode.window.activeTextEditor.document.fileName.split(/\\\\|\\//);\n    Register.putByKey(filepathComponents[filepathComponents.length - 1], '%', undefined, true);\n  }\n\n  // workspace events\n  registerEventListener(\n    context,\n    vscode.workspace.onDidChangeConfiguration,\n    async () => {\n      await loadConfiguration();\n    },\n    false\n  );\n\n  registerEventListener(context, vscode.workspace.onDidChangeTextDocument, async (event) => {\n    const textWasDeleted = (changeEvent: vscode.TextDocumentChangeEvent) =>\n      changeEvent.contentChanges.length === 1 &&\n      changeEvent.contentChanges[0].text === '' &&\n      changeEvent.contentChanges[0].range.start.line !==\n        changeEvent.contentChanges[0].range.end.line;\n\n    const textWasAdded = (changeEvent: vscode.TextDocumentChangeEvent) =>\n      changeEvent.contentChanges.length === 1 &&\n      (changeEvent.contentChanges[0].text === '\\n' ||\n        changeEvent.contentChanges[0].text === '\\r\\n') &&\n      changeEvent.contentChanges[0].range.start.line ===\n        changeEvent.contentChanges[0].range.end.line;\n\n    if (textWasDeleted(event)) {\n      globalState.jumpTracker.handleTextDeleted(event.document, event.contentChanges[0].range);\n    } else if (textWasAdded(event)) {\n      globalState.jumpTracker.handleTextAdded(\n        event.document,\n        event.contentChanges[0].range,\n        event.contentChanges[0].text\n      );\n    }\n\n    // Change from VSCode editor should set document.isDirty to true but they initially don't!\n    // There is a timing issue in VSCode codebase between when the isDirty flag is set and\n    // when registered callbacks are fired. https://github.com/Microsoft/vscode/issues/11339\n    const contentChangeHandler = (modeHandler: ModeHandler) => {\n      if (modeHandler.vimState.currentMode === Mode.Insert) {\n        if (modeHandler.vimState.historyTracker.currentContentChanges === undefined) {\n          modeHandler.vimState.historyTracker.currentContentChanges = [];\n        }\n\n        modeHandler.vimState.historyTracker.currentContentChanges = modeHandler.vimState.historyTracker.currentContentChanges.concat(\n          event.contentChanges\n        );\n      }\n    };\n\n    if (Globals.isTesting && Globals.mockModeHandler) {\n      contentChangeHandler(Globals.mockModeHandler);\n    } else {\n      ModeHandlerMap.getAll()\n        .filter((modeHandler) => modeHandler.vimState.identity.fileName === event.document.fileName)\n        .forEach((modeHandler) => {\n          contentChangeHandler(modeHandler);\n        });\n    }\n\n    if (handleLocal) {\n      setTimeout(() => {\n        if (!event.document.isDirty && !event.document.isUntitled && event.contentChanges.length) {\n          handleContentChangedFromDisk(event.document);\n        }\n      }, 0);\n    }\n  });\n\n  registerEventListener(\n    context,\n    vscode.workspace.onDidCloseTextDocument,\n    async (closedDocument) => {\n      const documents = vscode.workspace.textDocuments;\n\n      // Delete modehandler once all tabs of this document have been closed\n      for (const editorIdentity of ModeHandlerMap.getKeys()) {\n        const modeHandler = ModeHandlerMap.get(editorIdentity);\n\n        let shouldDelete = false;\n        if (modeHandler == null || modeHandler.vimState.editor === undefined) {\n          shouldDelete = true;\n        } else {\n          const document = modeHandler.vimState.document;\n          if (!documents.includes(document)) {\n            shouldDelete = true;\n            if (closedDocument === document) {\n              lastClosedModeHandler = modeHandler;\n            }\n          }\n        }\n\n        if (shouldDelete) {\n          ModeHandlerMap.delete(editorIdentity);\n        }\n      }\n    },\n    false\n  );\n\n  registerEventListener(context, vscode.workspace.onDidSaveTextDocument, async (document) => {\n    if (\n      configuration.vimrc.enable &&\n      path.relative(document.fileName, configuration.vimrc.path) === ''\n    ) {\n      await configuration.load();\n      vscode.window.showInformationMessage('Sourced new .vimrc');\n    }\n  });\n\n  // window events\n  registerEventListener(\n    context,\n    vscode.window.onDidChangeActiveTextEditor,\n    async () => {\n      const mhPrevious: ModeHandler | undefined = previousActiveEditorId\n        ? ModeHandlerMap.get(previousActiveEditorId)\n        : undefined;\n      // Track the closed editor so we can use it the next time an open event occurs.\n      // When vscode changes away from a temporary file, onDidChangeActiveTextEditor first twice.\n      // First it fires when leaving the closed editor. Then onDidCloseTextDocument first, and we delete\n      // the old ModeHandler. Then a new editor opens.\n      //\n      // This also applies to files that are merely closed, which allows you to jump back to that file similarly\n      // once a new file is opened.\n      lastClosedModeHandler = mhPrevious || lastClosedModeHandler;\n\n      if (vscode.window.activeTextEditor === undefined) {\n        Register.putByKey('', '%', undefined, true);\n        return;\n      }\n\n      const oldFileRegister = (await Register.get(undefined, '%'))?.text;\n      const relativePath = vscode.workspace.asRelativePath(\n        vscode.window.activeTextEditor.document.uri,\n        false\n      );\n\n      if (relativePath !== oldFileRegister) {\n        if (oldFileRegister && oldFileRegister !== '') {\n          Register.putByKey(oldFileRegister, '#', RegisterMode.CharacterWise, true);\n        }\n        Register.putByKey(relativePath, '%', RegisterMode.CharacterWise, true);\n      }\n\n      taskQueue.enqueueTask(async () => {\n        const mh = await getAndUpdateModeHandler(true);\n        if (mh) {\n          globalState.jumpTracker.handleFileJump(\n            lastClosedModeHandler ? Jump.fromStateNow(lastClosedModeHandler.vimState) : null,\n            Jump.fromStateNow(mh.vimState)\n          );\n        }\n      });\n    },\n    true,\n    true\n  );\n\n  registerEventListener(\n    context,\n    vscode.window.onDidChangeTextEditorSelection,\n    async (e: vscode.TextEditorSelectionChangeEvent) => {\n      if (\n        vscode.window.activeTextEditor === undefined ||\n        e.textEditor.document !== vscode.window.activeTextEditor.document\n      ) {\n        // We don't care if user selection changed in a paneled window (e.g debug console/terminal)\n        return;\n      }\n\n      const mh = await getAndUpdateModeHandler();\n      if (mh === undefined) {\n        // We don't care if there is no active editor\n        return;\n      }\n\n      if (e.kind !== vscode.TextEditorSelectionChangeKind.Mouse) {\n        const selectionsHash = e.selections.reduce(\n          (hash, s) =>\n            hash +\n            `[${s.anchor.line}, ${s.anchor.character}; ${s.active.line}, ${s.active.character}]`,\n          ''\n        );\n        const idx = mh.vimState.selectionsChanged.ourSelections.indexOf(selectionsHash);\n        if (idx > -1) {\n          mh.vimState.selectionsChanged.ourSelections.splice(idx, 1);\n          logger.debug(\n            `Selections: Ignoring selection: ${selectionsHash}, Count left: ${mh.vimState.selectionsChanged.ourSelections.length}`\n          );\n          return;\n        } else if (mh.vimState.selectionsChanged.ignoreIntermediateSelections) {\n          logger.debug(`Selections: ignoring intermediate selection change: ${selectionsHash}`);\n          return;\n        } else if (mh.vimState.selectionsChanged.ourSelections.length > 0) {\n          // Some intermediate selection must have slipped in after setting the\n          // 'ignoreIntermediateSelections' to false. Which means we didn't count\n          // for it yet, but since we have selections to be ignored then we probably\n          // wanted this one to be ignored as well.\n          logger.debug(`Selections: Ignoring slipped selection: ${selectionsHash}`);\n          return;\n        }\n      }\n\n      // We may receive changes from other panels when, having selections in them containing the same file\n      // and changing text before the selection in current panel.\n      if (e.textEditor !== mh.vimState.editor) {\n        return;\n      }\n\n      if (mh.vimState.focusChanged) {\n        mh.vimState.focusChanged = false;\n        return;\n      }\n\n      if (mh.currentMode === Mode.EasyMotionMode) {\n        return;\n      }\n\n      taskQueue.enqueueTask(\n        () => mh.handleSelectionChange(e),\n        undefined,\n        /**\n         * We don't want these to become backlogged! If they do, we'll update\n         * the selection to an incorrect value and see a jittering cursor.\n         */\n        true\n      );\n    },\n    true,\n    false\n  );\n\n  registerEventListener(\n    context,\n    vscode.window.onDidChangeTextEditorVisibleRanges,\n    async (e: vscode.TextEditorVisibleRangesChangeEvent) => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        // Scrolling the viewport clears any status bar message, even errors.\n        StatusBar.clear(mh.vimState, true);\n      }\n    }\n  );\n\n  const compositionState = new CompositionState();\n\n  // Override VSCode commands\n  overrideCommand(context, 'type', async (args) => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        if (compositionState.isInComposition) {\n          compositionState.composingText += args.text;\n          if (mh.vimState.currentMode === Mode.Insert) {\n            compositionState.insertedText = true;\n            vscode.commands.executeCommand('default:type', { text: args.text });\n          }\n        } else {\n          await mh.handleKeyEvent(args.text);\n        }\n      }\n    });\n  });\n\n  overrideCommand(context, 'replacePreviousChar', async (args) => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        if (compositionState.isInComposition) {\n          compositionState.composingText =\n            compositionState.composingText.substr(\n              0,\n              compositionState.composingText.length - args.replaceCharCnt\n            ) + args.text;\n        }\n        if (compositionState.insertedText) {\n          await vscode.commands.executeCommand('default:replacePreviousChar', {\n            text: args.text,\n            replaceCharCnt: args.replaceCharCnt,\n          });\n          mh.vimState.cursorStopPosition = mh.vimState.editor.selection.start;\n          mh.vimState.cursorStartPosition = mh.vimState.editor.selection.start;\n        }\n      } else {\n        await vscode.commands.executeCommand('default:replacePreviousChar', {\n          text: args.text,\n          replaceCharCnt: args.replaceCharCnt,\n        });\n      }\n    });\n  });\n\n  overrideCommand(context, 'compositionStart', async () => {\n    taskQueue.enqueueTask(async () => {\n      compositionState.isInComposition = true;\n    });\n  });\n\n  overrideCommand(context, 'compositionEnd', async () => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        if (compositionState.insertedText) {\n          mh.vimState.selectionsChanged.ignoreIntermediateSelections = true;\n          await vscode.commands.executeCommand('default:replacePreviousChar', {\n            text: '',\n            replaceCharCnt: compositionState.composingText.length,\n          });\n          mh.vimState.cursorStopPosition = mh.vimState.editor.selection.active;\n          mh.vimState.cursorStartPosition = mh.vimState.editor.selection.active;\n          mh.vimState.selectionsChanged.ignoreIntermediateSelections = false;\n        }\n        const text = compositionState.composingText;\n        await mh.handleMultipleKeyEvents(text.split(''));\n      }\n      compositionState.reset();\n    });\n  });\n\n  // Register extension commands\n  registerCommand(context, 'vim.showQuickpickCmdLine', async () => {\n    const mh = await getAndUpdateModeHandler();\n    if (mh) {\n      await commandLine.PromptAndRun('', mh.vimState);\n      mh.updateView();\n    }\n  });\n\n  registerCommand(context, 'vim.remap', async (args: ICodeKeybinding) => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh === undefined) {\n        return;\n      }\n\n      if (!args) {\n        throw new Error(\n          \"'args' is undefined. For this remap to work it needs to have 'args' with an '\\\"after\\\": string[]' and/or a '\\\"commands\\\": { command: string; args: any[] }[]'\"\n        );\n      }\n\n      if (args.after) {\n        for (const key of args.after) {\n          await mh.handleKeyEvent(Notation.NormalizeKey(key, configuration.leader));\n        }\n      }\n\n      if (args.commands) {\n        for (const command of args.commands) {\n          // Check if this is a vim command by looking for :\n          if (command.command.startsWith(':')) {\n            await commandLine.Run(command.command.slice(1, command.command.length), mh.vimState);\n            mh.updateView();\n          } else {\n            vscode.commands.executeCommand(command.command, command.args);\n          }\n        }\n      }\n    });\n  });\n\n  registerCommand(context, 'toggleVim', async () => {\n    configuration.disableExtension = !configuration.disableExtension;\n    toggleExtension(configuration.disableExtension, compositionState);\n  });\n\n  registerCommand(\n    context,\n    'vim.editVimrc',\n    async () => {\n      const document = await vscode.workspace.openTextDocument(configuration.vimrc.path);\n      await vscode.window.showTextDocument(document);\n    },\n    false\n  );\n\n  for (const boundKey of configuration.boundKeyCombinations) {\n    const command = ['<Esc>', '<C-c>'].includes(boundKey.key)\n      ? async () => {\n          const didStopRemap = await forceStopRecursiveRemap();\n          if (!didStopRemap) {\n            handleKeyEvent(`${boundKey.key}`);\n          }\n        }\n      : () => {\n          handleKeyEvent(`${boundKey.key}`);\n        };\n    registerCommand(context, boundKey.command, command);\n  }\n\n  {\n    // Initialize mode handler for current active Text Editor at startup.\n    const modeHandler = await getAndUpdateModeHandler();\n    if (modeHandler) {\n      if (!configuration.startInInsertMode) {\n        const vimState = modeHandler.vimState;\n\n        // Make sure no cursors start on the EOL character (which is invalid in normal mode)\n        // This can happen if we quit last session in insert mode at the end of the line\n        vimState.cursors = vimState.cursors.map((cursor) => {\n          const eolColumn = vimState.document.lineAt(cursor.stop).text.length;\n          if (cursor.stop.character >= eolColumn) {\n            const character = Math.max(eolColumn - 1, 0);\n            return cursor.withNewStop(cursor.stop.with({ character }));\n          } else {\n            return cursor;\n          }\n        });\n      }\n\n      // This is called last because getAndUpdateModeHandler() will change cursor\n      modeHandler.updateView({ drawSelection: true, revealRange: false });\n    }\n  }\n\n  // Disable automatic keyboard navigation in lists, so it doesn't interfere\n  // with our list navigation keybindings\n  await VSCodeContext.set('listAutomaticKeyboardNavigation', false);\n\n  await toggleExtension(configuration.disableExtension, compositionState);\n\n  logger.debug('Finish.');\n}\n\n/**\n * Toggles the VSCodeVim extension between Enabled mode and Disabled mode. This\n * function is activated by calling the 'toggleVim' command from the Command Palette.\n *\n * @param isDisabled if true, sets VSCodeVim to Disabled mode; else sets to enabled mode\n */\nasync function toggleExtension(isDisabled: boolean, compositionState: CompositionState) {\n  await VSCodeContext.set('vim.active', !isDisabled);\n  const mh = await getAndUpdateModeHandler();\n  if (mh) {\n    if (isDisabled) {\n      await mh.handleKeyEvent(SpecialKeys.ExtensionDisable);\n      compositionState.reset();\n      ModeHandlerMap.clear();\n    } else {\n      await mh.handleKeyEvent(SpecialKeys.ExtensionEnable);\n    }\n  }\n}\n\nfunction overrideCommand(\n  context: vscode.ExtensionContext,\n  command: string,\n  callback: (...args: any[]) => any\n) {\n  const disposable = vscode.commands.registerCommand(command, async (args) => {\n    if (configuration.disableExtension) {\n      return vscode.commands.executeCommand('default:' + command, args);\n    }\n\n    if (!vscode.window.activeTextEditor) {\n      return;\n    }\n\n    if (\n      vscode.window.activeTextEditor.document &&\n      vscode.window.activeTextEditor.document.uri.toString() === 'debug:input'\n    ) {\n      return vscode.commands.executeCommand('default:' + command, args);\n    }\n\n    return callback(args);\n  });\n  context.subscriptions.push(disposable);\n}\n\nfunction registerCommand(\n  context: vscode.ExtensionContext,\n  command: string,\n  callback: (...args: any[]) => any,\n  requiresActiveEditor: boolean = true\n) {\n  const disposable = vscode.commands.registerCommand(command, async (args) => {\n    if (requiresActiveEditor && !vscode.window.activeTextEditor) {\n      return;\n    }\n\n    callback(args);\n  });\n  context.subscriptions.push(disposable);\n}\n\nfunction registerEventListener<T>(\n  context: vscode.ExtensionContext,\n  event: vscode.Event<T>,\n  listener: (e: T) => void,\n  exitOnExtensionDisable = true,\n  exitOnTests = false\n) {\n  const disposable = event(async (e) => {\n    if (exitOnExtensionDisable && configuration.disableExtension) {\n      return;\n    }\n\n    if (exitOnTests && Globals.isTesting) {\n      return;\n    }\n\n    listener(e);\n  });\n  context.subscriptions.push(disposable);\n}\n\nasync function handleKeyEvent(key: string): Promise<void> {\n  const mh = await getAndUpdateModeHandler();\n  if (mh) {\n    taskQueue.enqueueTask(async () => {\n      await mh.handleKeyEvent(key);\n    });\n  }\n}\n\n/**\n * @returns true if there was a remap being executed to stop\n */\nasync function forceStopRecursiveRemap(): Promise<boolean> {\n  const mh = await getAndUpdateModeHandler();\n  if (mh?.remapState.isCurrentlyPerformingRecursiveRemapping) {\n    mh.remapState.forceStopRecursiveRemapping = true;\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleContentChangedFromDisk(document: vscode.TextDocument): void {\n  ModeHandlerMap.getAll()\n    .filter((modeHandler) => modeHandler.vimState.identity.fileName === document.fileName)\n    .forEach((modeHandler) => {\n      modeHandler.vimState.historyTracker = new HistoryTracker(modeHandler.vimState);\n    });\n}\n","import { Position } from 'vscode';\nimport { Range } from '../common/motion/range';\nimport { Notation } from '../configuration/notation';\nimport { isTextTransformation } from '../transformations/transformations';\nimport { configuration } from './../configuration/configuration';\nimport { Mode } from './../mode/mode';\nimport { VimState } from './../state/vimState';\n\nexport abstract class BaseAction {\n  /**\n   * Can this action be paired with an operator (is it like w in dw)? All\n   * BaseMovements can be, and some more sophisticated commands also can be.\n   */\n  public isMotion = false;\n\n  public isOperator = false;\n  public isCommand = false;\n\n  /**\n   * If true, the cursor position will be added to the jump list on completion.\n   */\n  public isJump = false;\n\n  public canBeRepeatedWithDot = false;\n\n  /**\n   * If this is being run in multi cursor mode, the index of the cursor\n   * this action is being applied to.\n   */\n  multicursorIndex: number | undefined = undefined;\n\n  /**\n   * Whether we should change `vimState.desiredColumn`\n   */\n  public preservesDesiredColumn(): boolean {\n    return false;\n  }\n\n  /**\n   * Modes that this action can be run in.\n   */\n  public abstract modes: Mode[];\n\n  /**\n   * The sequence of keys you use to trigger the action, or a list of such sequences.\n   */\n  public keys: string[] | string[][];\n\n  public mustBeFirstKey = false;\n\n  /**\n   * The keys pressed at the time that this action was triggered.\n   */\n  public keysPressed: string[] = [];\n\n  private static readonly isSingleNumber: RegExp = /^[0-9]$/;\n  private static readonly isSingleAlpha: RegExp = /^[a-zA-Z]$/;\n\n  /**\n   * Is this action valid in the current Vim state?\n   */\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (\n      this.mustBeFirstKey &&\n      (vimState.recordedState.commandWithoutCountPrefix.length > keysPressed.length ||\n        vimState.recordedState.operator)\n    ) {\n      return false;\n    }\n\n    return (\n      this.modes.includes(vimState.currentMode) &&\n      BaseAction.CompareKeypressSequence(this.keys, keysPressed)\n    );\n  }\n\n  /**\n   * Could the user be in the process of doing this action.\n   */\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!this.modes.includes(vimState.currentMode)) {\n      return false;\n    }\n\n    const keys2D = BaseAction.is2DArray(this.keys) ? this.keys : [this.keys];\n    const keysSlice = keys2D.map((x) => x.slice(0, keysPressed.length));\n    if (!BaseAction.CompareKeypressSequence(keysSlice, keysPressed)) {\n      return false;\n    }\n\n    if (\n      this.mustBeFirstKey &&\n      (vimState.recordedState.commandWithoutCountPrefix.length > keysPressed.length ||\n        vimState.recordedState.operator)\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public static CompareKeypressSequence(one: string[] | string[][], two: string[]): boolean {\n    if (BaseAction.is2DArray(one)) {\n      for (const sequence of one) {\n        if (BaseAction.CompareKeypressSequence(sequence, two)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (one.length !== two.length) {\n      return false;\n    }\n\n    for (let i = 0, j = 0; i < one.length; i++, j++) {\n      const left = one[i];\n      const right = two[j];\n\n      if (left === '<any>' || right === '<any>') {\n        continue;\n      }\n\n      if (left === '<number>' && this.isSingleNumber.test(right)) {\n        continue;\n      }\n      if (right === '<number>' && this.isSingleNumber.test(left)) {\n        continue;\n      }\n\n      if (left === '<alpha>' && this.isSingleAlpha.test(right)) {\n        continue;\n      }\n      if (right === '<alpha>' && this.isSingleAlpha.test(left)) {\n        continue;\n      }\n\n      if (left === '<character>' && !Notation.IsControlKey(right)) {\n        continue;\n      }\n      if (right === '<character>' && !Notation.IsControlKey(left)) {\n        continue;\n      }\n\n      if (left === '<leader>' && right === configuration.leader) {\n        continue;\n      }\n      if (right === '<leader>' && left === configuration.leader) {\n        continue;\n      }\n\n      if (left === configuration.leader || right === configuration.leader) {\n        return false;\n      }\n\n      if (left !== right) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public toString(): string {\n    return this.keys.join('');\n  }\n\n  private static is2DArray<T>(x: any): x is T[][] {\n    return Array.isArray(x[0]);\n  }\n}\n\n/**\n * A command is something like <Esc>, :, v, i, etc.\n */\nexport abstract class BaseCommand extends BaseAction {\n  isCommand = true;\n\n  /**\n   * If isCompleteAction is true, then triggering this command is a complete action -\n   * that means that we'll go and try to run it.\n   */\n  isCompleteAction = true;\n\n  /**\n   * In multi-cursor mode, do we run this command for every cursor, or just once?\n   */\n  public runsOnceForEveryCursor(): boolean {\n    return true;\n  }\n\n  /**\n   * If true, exec() will get called N times where N is the count.\n   *\n   * If false, exec() will only be called once, and you are expected to\n   * handle count prefixes (e.g. the 3 in 3w) yourself.\n   */\n  runsOnceForEachCountPrefix = false;\n\n  canBeRepeatedWithDot = false;\n\n  /**\n   * Run the command a single time.\n   */\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    throw new Error('Not implemented!');\n  }\n\n  /**\n   * Run the command the number of times VimState wants us to.\n   */\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = this.runsOnceForEachCountPrefix ? vimState.recordedState.count || 1 : 1;\n\n    if (!this.runsOnceForEveryCursor()) {\n      for (let i = 0; i < timesToRepeat; i++) {\n        await this.exec(position, vimState);\n      }\n\n      for (const transformation of vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = 0;\n        }\n      }\n\n      return;\n    }\n\n    const resultingCursors: Range[] = [];\n\n    const cursorsToIterateOver = vimState.cursors\n      .map((x) => new Range(x.start, x.stop))\n      .sort((a, b) =>\n        a.start.line > b.start.line ||\n        (a.start.line === b.start.line && a.start.character > b.start.character)\n          ? 1\n          : -1\n      );\n\n    let cursorIndex = 0;\n    for (const { start, stop } of cursorsToIterateOver) {\n      this.multicursorIndex = cursorIndex++;\n\n      vimState.cursorStopPosition = stop;\n      vimState.cursorStartPosition = start;\n\n      for (let j = 0; j < timesToRepeat; j++) {\n        await this.exec(stop, vimState);\n      }\n\n      resultingCursors.push(new Range(vimState.cursorStartPosition, vimState.cursorStopPosition));\n\n      for (const transformation of vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = this.multicursorIndex;\n        }\n      }\n    }\n\n    vimState.cursors = resultingCursors;\n  }\n}\n\nexport enum KeypressState {\n  WaitingOnKeys,\n  NoPossibleMatch,\n}\n\n/**\n * Every Vim action will be added here with the @RegisterAction decorator.\n */\nconst actionMap = new Map<Mode, Array<new () => BaseAction>>();\n\n/**\n * Gets the action that should be triggered given a key sequence.\n *\n * If there is a definitive action that matched, returns that action.\n *\n * If an action could potentially match if more keys were to be pressed, returns `KeyPressState.WaitingOnKeys`\n * (e.g. you pressed \"g\" and are about to press \"g\" action to make the full action \"gg\")\n *\n * If no action could ever match, returns `KeypressState.NoPossibleMatch`.\n */\nexport function getRelevantAction(\n  keysPressed: string[],\n  vimState: VimState\n): BaseAction | KeypressState {\n  let isPotentialMatch = false;\n\n  const possibleActionsForMode = actionMap.get(vimState.currentMode) || [];\n  for (const actionType of possibleActionsForMode) {\n    const action = new actionType();\n    if (action.doesActionApply(vimState, keysPressed)) {\n      action.keysPressed = vimState.recordedState.actionKeys.slice(0);\n      return action;\n    }\n\n    if (action.couldActionApply(vimState, keysPressed)) {\n      isPotentialMatch = true;\n    }\n  }\n\n  return isPotentialMatch ? KeypressState.WaitingOnKeys : KeypressState.NoPossibleMatch;\n}\n\nexport function RegisterAction(action: new () => BaseAction): void {\n  const actionInstance = new action();\n  for (const modeName of actionInstance.modes) {\n    let actions = actionMap.get(modeName);\n    if (!actions) {\n      actions = [];\n      actionMap.set(modeName, actions);\n    }\n\n    if (actionInstance.keys === undefined) {\n      // action that can't be called directly\n      continue;\n    }\n\n    actions.push(action);\n  }\n}\n","import { RegisterMode } from '../register/register';\nimport { BaseAction } from './base';\nimport { Mode } from '../mode/mode';\nimport { VimState } from '../state/vimState';\nimport { RecordedState } from '../state/recordedState';\nimport { clamp } from '../util/util';\nimport { Position } from 'vscode';\n\nexport function isIMovement(o: IMovement | Position): o is IMovement {\n  return (o as IMovement).start !== undefined && (o as IMovement).stop !== undefined;\n}\n\nexport enum SelectionType {\n  Concatenating, // Selections that concatenate repeated movements\n  Expanding, // Selections that expand the start and end of the previous selection\n}\n\n/**\n * The result of a (more sophisticated) Movement.\n */\nexport interface IMovement {\n  start: Position;\n  stop: Position;\n\n  /**\n   * Whether this motion succeeded. Some commands, like fx when 'x' can't be found,\n   * will not move the cursor. Furthermore, dfx won't delete *anything*, even though\n   * deleting to the current character would generally delete 1 character.\n   */\n  failed?: boolean;\n\n  /**\n   * Wheter this motion resulted in the current multicursor index being removed. This\n   * happens when multiple selections combine into one.\n   */\n  removed?: boolean;\n\n  // It /so/ annoys me that I have to put this here.\n  registerMode?: RegisterMode;\n}\n\nexport function failedMovement(vimState: VimState): IMovement {\n  return {\n    start: vimState.cursorStartPosition,\n    stop: vimState.cursorStopPosition,\n    failed: true,\n  };\n}\n\nexport abstract class BaseMovement extends BaseAction {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  isMotion = true;\n\n  /**\n   * If movement can be repeated with semicolon or comma this will be true when\n   * running the repetition.\n   */\n  isRepeat = false;\n\n  /**\n   * This is for commands like $ which force the desired column to be at\n   * the end of even the longest line.\n   */\n  public setsDesiredColumnToEOL = false;\n\n  protected minCount = 1;\n  protected maxCount = 99999;\n  protected selectionType = SelectionType.Concatenating;\n\n  constructor(keysPressed?: string[], isRepeat?: boolean) {\n    super();\n\n    if (keysPressed) {\n      this.keysPressed = keysPressed;\n    }\n\n    if (isRepeat) {\n      this.isRepeat = isRepeat;\n    }\n  }\n\n  /**\n   * Run the movement a single time.\n   *\n   * Generally returns a new Position. If necessary, it can return an IMovement instead.\n   * Note: If returning an IMovement, make sure that repeated actions on a\n   * visual selection work. For example, V}}\n   */\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    throw new Error('Not implemented!');\n  }\n\n  /**\n   * Run the movement in an operator context a single time.\n   *\n   * Some movements operate over different ranges when used for operators.\n   */\n  public async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    return this.execAction(position, vimState);\n  }\n\n  /**\n   * Run a movement count times.\n   *\n   * count: the number prefix the user entered, or 0 if they didn't enter one.\n   */\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const recordedState = vimState.recordedState;\n    let result: Position | IMovement = new Position(0, 0); // bogus init to satisfy typechecker\n    let prevResult = failedMovement(vimState);\n    let firstMovementStart: Position = new Position(position.line, position.character);\n\n    count = clamp(count, this.minCount, this.maxCount);\n\n    for (let i = 0; i < count; i++) {\n      const firstIteration = i === 0;\n      const lastIteration = i === count - 1;\n      result = await this.createMovementResult(position, vimState, recordedState, lastIteration);\n\n      if (result instanceof Position) {\n        /**\n         * This position will be passed to the `motion` on the next iteration,\n         * it may cause some issues when count > 1.\n         */\n        position = result;\n      } else {\n        if (result.failed) {\n          return prevResult;\n        }\n\n        if (firstIteration) {\n          firstMovementStart = new Position(result.start.line, result.start.character);\n        }\n\n        position = this.adjustPosition(position, result, lastIteration);\n        prevResult = result;\n      }\n    }\n\n    if (this.selectionType === SelectionType.Concatenating && isIMovement(result)) {\n      result.start = firstMovementStart;\n    }\n\n    return result;\n  }\n\n  protected async createMovementResult(\n    position: Position,\n    vimState: VimState,\n    recordedState: RecordedState,\n    lastIteration: boolean\n  ): Promise<Position | IMovement> {\n    const result =\n      recordedState.operator && lastIteration\n        ? await this.execActionForOperator(position, vimState)\n        : await this.execAction(position, vimState);\n    return result;\n  }\n\n  protected adjustPosition(position: Position, result: IMovement, lastIteration: boolean) {\n    if (!lastIteration) {\n      position = result.stop.getRightThroughLineBreaks();\n    }\n    return position;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { RecordedState } from '../../state/recordedState';\nimport { ReplaceState } from '../../state/replaceState';\nimport { VimState } from '../../state/vimState';\nimport { getCursorsAfterSync, clamp } from '../../util/util';\nimport { Clipboard } from '../../util/clipboard';\nimport { FileCommand } from './../../cmd_line/commands/file';\nimport { OnlyCommand } from './../../cmd_line/commands/only';\nimport { QuitCommand } from './../../cmd_line/commands/quit';\nimport { Tab, TabCommand } from './../../cmd_line/commands/tab';\nimport { PositionDiff, earlierOf, laterOf, sorted } from './../../common/motion/position';\nimport { Range } from './../../common/motion/range';\nimport { NumericString } from './../../common/number/numericString';\nimport { configuration } from './../../configuration/configuration';\nimport {\n  Mode,\n  visualBlockGetTopLeftPosition,\n  isVisualMode,\n  visualBlockGetBottomRightPosition,\n} from './../../mode/mode';\nimport { Register, RegisterMode } from './../../register/register';\nimport { SearchDirection } from './../../state/searchState';\nimport { EditorScrollByUnit, EditorScrollDirection, TextEditor } from './../../textEditor';\nimport { isTextTransformation, Transformation } from './../../transformations/transformations';\nimport { RegisterAction, BaseCommand } from './../base';\nimport { BaseAction } from './../base';\nimport { commandLine } from './../../cmd_line/commandLine';\nimport * as operator from './../operator';\nimport { Jump } from '../../jumps/jump';\nimport { StatusBar } from '../../statusBar';\nimport { reportFileInfo } from '../../util/statusBarTextUtils';\nimport { globalState } from '../../state/globalState';\nimport { SpecialKeys } from '../../util/specialKeys';\nimport { getWordLeft, WordType, getWordRight } from '../../textobject/word';\nimport { Position } from 'vscode';\nimport { WriteQuitCommand } from '../../cmd_line/commands/writequit';\nimport { shouldWrapKey } from '../wrapping';\nimport { ErrorCode, VimError } from '../../error';\n\nexport class DocumentContentChangeAction extends BaseAction {\n  modes: [];\n\n  private contentChanges: vscode.TextDocumentContentChangeEvent[] = [];\n\n  public addChanges(changes: vscode.TextDocumentContentChangeEvent[]) {\n    this.contentChanges = [...this.contentChanges, ...changes];\n    this.compressChanges();\n  }\n\n  public getTransformation(positionDiff: PositionDiff): Transformation {\n    return {\n      type: 'contentChange',\n      changes: this.contentChanges,\n      diff: positionDiff,\n    };\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (this.contentChanges.length === 0) {\n      return;\n    }\n\n    const firstTextDiff = this.contentChanges[0];\n    let originalLeftBoundary =\n      firstTextDiff.text === '' && firstTextDiff.rangeLength === 1\n        ? firstTextDiff.range.end\n        : firstTextDiff.range.start;\n\n    let rightBoundary: Position = position;\n    let replaceRange: Range | undefined;\n    for (const change of this.contentChanges) {\n      if (change.range.start.line < originalLeftBoundary.line) {\n        // This change should be ignored\n        const linesAffected = change.range.end.line - change.range.start.line + 1;\n        const resultLines = change.text.split('\\n').length;\n        originalLeftBoundary = originalLeftBoundary.with(\n          originalLeftBoundary.line + resultLines - linesAffected\n        );\n        continue;\n      }\n\n      // Translates diffPos from a position relative to originalLeftBoundary to one relative to position\n      const translate = (diffPos: Position): Position => {\n        const lineOffset = diffPos.line - originalLeftBoundary.line;\n        const char =\n          lineOffset === 0\n            ? position.character + diffPos.character - originalLeftBoundary.character\n            : diffPos.character;\n        return new Position(position.line + lineOffset, char);\n      };\n\n      replaceRange = new Range(translate(change.range.start), translate(change.range.end));\n\n      if (replaceRange.start.isAfter(rightBoundary)) {\n        // This change should be ignored as it's out of boundary\n        continue;\n      }\n\n      // Calculate new right boundary\n      const textDiffLines = change.text.split('\\n');\n      const numLinesAdded = textDiffLines.length - 1;\n      const newRightBoundary =\n        numLinesAdded === 0\n          ? new Position(replaceRange.start.line, replaceRange.start.character + change.text.length)\n          : new Position(replaceRange.start.line + numLinesAdded, textDiffLines.pop()!.length);\n\n      rightBoundary = laterOf(rightBoundary, newRightBoundary);\n\n      vimState.editor.selection = new vscode.Selection(replaceRange.start, replaceRange.stop);\n\n      if (replaceRange.start.isEqual(replaceRange.stop)) {\n        await TextEditor.insert(vimState.editor, change.text, replaceRange.start);\n      } else {\n        await TextEditor.replace(vimState.editor, vimState.editor.selection, change.text);\n      }\n    }\n\n    /**\n     * We're making an assumption here that content changes are always in order, and I'm not sure\n     * we're guaranteed that, but it seems to work well enough in practice.\n     */\n    if (replaceRange) {\n      const lastChange = this.contentChanges[this.contentChanges.length - 1];\n\n      vimState.cursorStartPosition = vimState.cursorStopPosition = replaceRange.start.advancePositionByText(\n        lastChange.text\n      );\n    }\n\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n\n  private compressChanges(): void {\n    function merge(\n      first: vscode.TextDocumentContentChangeEvent,\n      second: vscode.TextDocumentContentChangeEvent\n    ): vscode.TextDocumentContentChangeEvent | undefined {\n      if (\n        first.rangeOffset + first.text.length !== second.rangeOffset ||\n        second.rangeLength !== 0\n      ) {\n        // TODO: We should be able to do better, but I'm not sure if this is actually relevant.\n        return undefined;\n      }\n\n      return {\n        text: first.text + second.text,\n        range: first.range,\n        rangeOffset: first.rangeOffset,\n        rangeLength: first.rangeLength,\n      };\n    }\n\n    const compressed: vscode.TextDocumentContentChangeEvent[] = [];\n    let prev: vscode.TextDocumentContentChangeEvent | undefined;\n    for (const change of this.contentChanges) {\n      if (prev === undefined) {\n        prev = change;\n      } else {\n        const merged = merge(prev, change);\n        if (merged) {\n          prev = merged;\n        } else {\n          compressed.push(prev);\n          prev = change;\n        }\n      }\n    }\n    if (prev !== undefined) {\n      compressed.push(prev);\n    }\n    this.contentChanges = compressed;\n  }\n}\n\n@RegisterAction\nclass DisableExtension extends BaseCommand {\n  modes = [\n    Mode.Normal,\n    Mode.Insert,\n    Mode.Visual,\n    Mode.VisualBlock,\n    Mode.VisualLine,\n    Mode.SearchInProgressMode,\n    Mode.CommandlineInProgress,\n    Mode.Replace,\n    Mode.EasyMotionMode,\n    Mode.EasyMotionInputMode,\n    Mode.SurroundInputMode,\n  ];\n  keys = [SpecialKeys.ExtensionDisable];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Disabled);\n  }\n}\n\n@RegisterAction\nclass EnableExtension extends BaseCommand {\n  modes = [Mode.Disabled];\n  keys = [SpecialKeys.ExtensionEnable];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class CommandNumber extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['<number>'];\n  isCompleteAction = false;\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const num = parseInt(this.keysPressed[0], 10);\n    const operatorCount = vimState.recordedState.operatorCount;\n\n    if (operatorCount > 0) {\n      const lastAction =\n        vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 2];\n      if (!(lastAction instanceof CommandNumber)) {\n        // We have set an operatorCount !== 0 after an operator, but now we got another count\n        // number so we need to multiply them.\n        vimState.recordedState.count = operatorCount * num;\n      } else {\n        // We are now getting another digit which means we need to multiply by 10 and add\n        // the new digit multiplied by operatorCount.\n        //\n        // Example: user presses '2d31w':\n        // - After '2' the number 2 is stored in 'count'\n        // - After 'd' the count (2) is stored in 'operatorCount'\n        // - After '3' the number 3 multiplied by 'operatorCount' (3 x 2 = 6) is stored in 'count'\n        // - After '1' the count is multiplied by 10 and added by number 1 multiplied by 'operatorCount'\n        //   (6 * 10 + 1 * 2 = 62)\n        // The final result will be the deletion of 62 words.\n        vimState.recordedState.count = vimState.recordedState.count * 10 + num * operatorCount;\n      }\n    } else {\n      vimState.recordedState.count = vimState.recordedState.count * 10 + num;\n    }\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const isZero = keysPressed[0] === '0';\n\n    return (\n      super.doesActionApply(vimState, keysPressed) &&\n      ((isZero && vimState.recordedState.count > 0) || !isZero)\n    );\n  }\n\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const isZero = keysPressed[0] === '0';\n\n    return (\n      super.couldActionApply(vimState, keysPressed) &&\n      ((isZero && vimState.recordedState.count > 0) || !isZero)\n    );\n  }\n}\n\n@RegisterAction\nexport class CommandRegister extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['\"', '<character>'];\n  isCompleteAction = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = this.keysPressed[1];\n    vimState.recordedState.registerName = register;\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const register = keysPressed[1];\n\n    return super.doesActionApply(vimState, keysPressed) && Register.isValidRegister(register);\n  }\n}\n\n@RegisterAction\nclass CommandRecordMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['q', '<alpha>'],\n    ['q', '<number>'],\n    ['q', '\"'],\n  ];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const registerKey = this.keysPressed[1];\n    const register = registerKey.toLocaleLowerCase();\n    vimState.macro = new RecordedState();\n    vimState.macro.registerName = register;\n\n    if (!/^[A-Z]+$/.test(registerKey) || !Register.has(register)) {\n      // If register name is upper case, it means we are appending commands to existing register instead of overriding.\n      const newRegister = new RecordedState();\n      newRegister.registerName = register;\n      Register.putByKey(newRegister, register);\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandQuitRecordMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['q'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const macro = vimState.macro!;\n\n    const existingMacro = (await Register.get(vimState, macro.registerName))?.text;\n    if (existingMacro instanceof RecordedState) {\n      existingMacro.actionsRun = existingMacro.actionsRun.concat(macro.actionsRun);\n    }\n\n    vimState.macro = undefined;\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && vimState.macro !== undefined;\n  }\n\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.couldActionApply(vimState, keysPressed) && vimState.macro !== undefined;\n  }\n}\n\n@RegisterAction\nclass CommandExecuteMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['@', '<character>'];\n  runsOnceForEachCountPrefix = true;\n  canBeRepeatedWithDot = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = this.keysPressed[1].toLocaleLowerCase();\n    if (Register.has(register)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register,\n        replay: 'contentChange',\n      });\n    }\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const register = keysPressed[1];\n\n    return (\n      super.doesActionApply(vimState, keysPressed) && Register.isValidRegisterForMacro(register)\n    );\n  }\n}\n\n@RegisterAction\nclass CommandExecuteLastMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['@', '@'];\n  runsOnceForEachCountPrefix = true;\n  canBeRepeatedWithDot = true;\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const { lastInvokedMacro } = vimState;\n\n    if (lastInvokedMacro) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register: lastInvokedMacro.registerName,\n        replay: 'contentChange',\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass CommandEsc extends BaseCommand {\n  modes = [\n    Mode.Visual,\n    Mode.VisualLine,\n    Mode.VisualBlock,\n    Mode.Normal,\n    Mode.SurroundInputMode,\n    Mode.EasyMotionMode,\n    Mode.EasyMotionInputMode,\n  ];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  preservesDesiredColumn() {\n    return true;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal) {\n      vimState.surround = undefined;\n\n      if (!vimState.isMultiCursor) {\n        // If there's nothing to do on the vim side, we might as well call some\n        // of vscode's default \"close notification\" actions. I think we should\n        // just add to this list as needed.\n        await Promise.all([\n          vscode.commands.executeCommand('closeReferenceSearchEditor'),\n          vscode.commands.executeCommand('closeMarkersNavigation'),\n          vscode.commands.executeCommand('closeDirtyDiff'),\n        ]);\n\n        return;\n      } else {\n        vimState.isMultiCursor = false;\n      }\n    }\n\n    if (vimState.currentMode === Mode.EasyMotionMode) {\n      vimState.easyMotion.clearDecorations(vimState.editor);\n    }\n\n    // Abort surround operation\n    if (vimState.currentMode === Mode.SurroundInputMode) {\n      vimState.surround = undefined;\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n\n    if (!vimState.isMultiCursor) {\n      vimState.cursors = [vimState.cursors[0]];\n    }\n  }\n}\n\nabstract class CommandEditorScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  runsOnceForEachCountPrefix = false;\n  keys: string[];\n  abstract to: EditorScrollDirection;\n  abstract by: EditorScrollByUnit;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n    const visibleRange = vimState.editor.visibleRanges[0];\n    const scrolloff = configuration\n      .getConfiguration('editor')\n      .get<number>('cursorSurroundingLines', 0);\n\n    const linesAboveCursor =\n      visibleRange.end.line - vimState.cursorStopPosition.line - timesToRepeat;\n    const linesBelowCursor =\n      vimState.cursorStopPosition.line - visibleRange.start.line - timesToRepeat;\n    if (this.to === 'up' && scrolloff > linesAboveCursor) {\n      vimState.cursorStopPosition = vimState.cursorStopPosition\n        .getUp(scrolloff - linesAboveCursor)\n        .withColumn(vimState.desiredColumn);\n    } else if (this.to === 'down' && scrolloff > linesBelowCursor) {\n      vimState.cursorStopPosition = vimState.cursorStopPosition\n        .getDown(scrolloff - linesBelowCursor)\n        .withColumn(vimState.desiredColumn);\n    }\n\n    vimState.postponedCodeViewChanges.push({\n      command: 'editorScroll',\n      args: {\n        to: this.to,\n        by: this.by,\n        value: timesToRepeat,\n        revealCursor: true,\n        select: isVisualMode(vimState.currentMode),\n      },\n    });\n  }\n}\n\n@RegisterAction\nclass CommandCtrlE extends CommandEditorScroll {\n  keys = ['<C-e>'];\n  preservesDesiredColumn() {\n    return true;\n  }\n  to: EditorScrollDirection = 'down';\n  by: EditorScrollByUnit = 'line';\n}\n\n@RegisterAction\nclass CommandCtrlY extends CommandEditorScroll {\n  keys = ['<C-y>'];\n  preservesDesiredColumn() {\n    return true;\n  }\n  to: EditorScrollDirection = 'up';\n  by: EditorScrollByUnit = 'line';\n}\n\n/**\n * Commands like `<C-d>` and `<C-f>` act *sort* of like `<count><C-e>`, but they move\n * your cursor down and put it on the first non-whitespace character of the line.\n */\nabstract class CommandScrollAndMoveCursor extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  runsOnceForEachCountPrefix = false;\n  abstract to: EditorScrollDirection;\n\n  /**\n   * @returns the number of lines this command should move the cursor\n   */\n  protected abstract getNumLines(vimState: VimState): number;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const { visibleRanges } = vimState.editor;\n    const smoothScrolling = configuration.getConfiguration('editor').smoothScrolling;\n    const moveLines = (vimState.actionCount || 1) * this.getNumLines(vimState);\n\n    let scrollLines = moveLines;\n    if (this.to === 'down') {\n      // This makes <C-d> less wonky when `editor.scrollBeyondLastLine` is enabled\n      scrollLines = Math.min(\n        moveLines,\n        vimState.document.lineCount - 1 - visibleRanges[visibleRanges.length - 1].end.line\n      );\n    }\n\n    if (scrollLines > 0) {\n      const args = {\n        to: this.to,\n        by: 'line',\n        value: scrollLines,\n        revealCursor: smoothScrolling,\n        select: isVisualMode(vimState.currentMode),\n      };\n      if (smoothScrolling) {\n        await vscode.commands.executeCommand('editorScroll', args);\n      } else {\n        vimState.postponedCodeViewChanges.push({\n          command: 'editorScroll',\n          args,\n        });\n      }\n    }\n\n    const newPositionLine = clamp(\n      position.line + (this.to === 'down' ? moveLines : -moveLines),\n      0,\n      vimState.document.lineCount - 1\n    );\n    vimState.cursorStopPosition = new Position(\n      newPositionLine,\n      vimState.desiredColumn\n    ).obeyStartOfLine(vimState.document);\n  }\n}\n\n@RegisterAction\nclass CommandMoveFullPageUp extends CommandScrollAndMoveCursor {\n  keys = ['<C-b>'];\n  to: EditorScrollDirection = 'up';\n\n  protected getNumLines(vimState: VimState) {\n    const visible = vimState.editor.visibleRanges[0];\n    return visible.end.line - visible.start.line;\n  }\n}\n\n@RegisterAction\nclass CommandMoveFullPageDown extends CommandScrollAndMoveCursor {\n  keys = ['<C-f>'];\n  to: EditorScrollDirection = 'down';\n\n  protected getNumLines(vimState: VimState) {\n    const visible = vimState.editor.visibleRanges[0];\n    return visible.end.line - visible.start.line;\n  }\n}\n\n@RegisterAction\nclass CommandMoveHalfPageDown extends CommandScrollAndMoveCursor {\n  keys = ['<C-d>'];\n  to: EditorScrollDirection = 'down';\n\n  protected getNumLines(vimState: VimState) {\n    return configuration.getScrollLines(vimState.editor.visibleRanges);\n  }\n}\n\n@RegisterAction\nclass CommandMoveHalfPageUp extends CommandScrollAndMoveCursor {\n  keys = ['<C-u>'];\n  to: EditorScrollDirection = 'up';\n\n  protected getNumLines(vimState: VimState) {\n    return configuration.getScrollLines(vimState.editor.visibleRanges);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtCursor extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['i'], ['<Insert>']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Only allow this command to be prefixed with a count or nothing, no other\n    // actions or operators before\n    let previousActionsNumbers = true;\n    for (const prevAction of vimState.recordedState.actionsRun) {\n      if (!(prevAction instanceof CommandNumber)) {\n        previousActionsNumbers = false;\n        break;\n      }\n    }\n\n    if (vimState.recordedState.actionsRun.length === 0 || previousActionsNumbers) {\n      return super.couldActionApply(vimState, keysPressed);\n    }\n    return false;\n  }\n}\n\n@RegisterAction\nexport class CommandReplaceAtCursorFromNormalMode extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['R'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n\n    await vimState.setCurrentMode(Mode.Replace);\n    vimState.replaceState = new ReplaceState(vimState, position, timesToRepeat);\n  }\n}\n\n/**\n * Our Vim implementation selects up to but not including the final character\n * of a visual selection, instead opting to render a block cursor on the final\n * character. This works for everything except VSCode's native copy command,\n * which loses the final character because it's not selected. We override that\n * copy command here by default to include the final character.\n */\n@RegisterAction\nclass CommandOverrideCopy extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock, Mode.Insert, Mode.Normal];\n  keys = ['<copy>']; // A special key - see ModeHandler\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    let text = '';\n\n    if (vimState.currentMode === Mode.Visual) {\n      text = vimState.cursors\n        .map((range) => {\n          const [start, stop] = sorted(range.start, range.stop);\n          return vimState.document.getText(new vscode.Range(start, stop.getRight()));\n        })\n        .join('\\n');\n    } else if (vimState.currentMode === Mode.VisualLine) {\n      text = vimState.cursors\n        .map((range) => {\n          return vimState.document.getText(\n            new vscode.Range(\n              earlierOf(range.start.getLineBegin(), range.stop.getLineBegin()),\n              laterOf(range.start.getLineEnd(), range.stop.getLineEnd())\n            )\n          );\n        })\n        .join('\\n');\n    } else if (vimState.currentMode === Mode.VisualBlock) {\n      for (const { line } of TextEditor.iterateLinesInBlock(vimState)) {\n        text += line + '\\n';\n      }\n    } else if (vimState.currentMode === Mode.Insert || vimState.currentMode === Mode.Normal) {\n      text = vimState.editor.selections\n        .map((selection) => {\n          return vimState.document.getText(new vscode.Range(selection.start, selection.end));\n        })\n        .join('\\n');\n    }\n\n    await Clipboard.Copy(text);\n    // all vim yank operations return to normal mode.\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandCmdA extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['<D-a>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.cursorStartPosition = new Position(0, vimState.desiredColumn);\n    vimState.cursorStopPosition = new Position(\n      vimState.document.lineCount - 1,\n      vimState.desiredColumn\n    );\n    await vimState.setCurrentMode(Mode.VisualLine);\n  }\n}\n\n@RegisterAction\nexport class MarkCommand extends BaseCommand {\n  keys = ['m', '<character>'];\n  modes = [Mode.Normal];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const markName = this.keysPressed[1];\n\n    vimState.historyTracker.addMark(position, markName);\n  }\n}\n\n@RegisterAction\nclass CommandShowCommandLine extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = [':'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal) {\n      if (vimState.recordedState.count) {\n        vimState.currentCommandlineText = `.,.+${vimState.recordedState.count - 1}`;\n      } else {\n        vimState.currentCommandlineText = '';\n      }\n    } else {\n      vimState.currentCommandlineText = \"'<,'>\";\n    }\n\n    // Initialize the cursor position\n    vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n\n    // Store the current mode for use in retaining selection\n    commandLine.previousMode = vimState.currentMode;\n\n    // Change to the new mode\n    await vimState.setCurrentMode(Mode.CommandlineInProgress);\n\n    // Reset history navigation index\n    commandLine.commandLineHistoryIndex = commandLine.historyEntries.length;\n  }\n}\n\n@RegisterAction\nexport class CommandShowCommandHistory extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['q', ':'];\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.addTransformation({\n      type: 'showCommandHistory',\n    });\n\n    if (vimState.currentMode === Mode.Normal) {\n      vimState.currentCommandlineText = '';\n    } else {\n      vimState.currentCommandlineText = \"'<,'>\";\n    }\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class CommandShowSearchHistory extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = [\n    ['q', '/'],\n    ['q', '?'],\n  ];\n\n  private direction = SearchDirection.Forward;\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public constructor(direction = SearchDirection.Forward) {\n    super();\n    this.direction = direction;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (this.keysPressed.includes('?')) {\n      this.direction = SearchDirection.Backward;\n    }\n    vimState.recordedState.transformer.addTransformation({\n      type: 'showSearchHistory',\n      direction: this.direction,\n    });\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandDot extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['.'];\n\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    const count = vimState.recordedState.count || 1;\n\n    for (let i = 0; i < count; i++) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'dot',\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass CommandRepeatSubstitution extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['&'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // Parsing the command from a string, while not ideal, is currently\n    // necessary to make this work with and without neovim integration\n    await commandLine.Run('s', vimState);\n  }\n}\n\ntype FoldDirection = 'up' | 'down' | undefined;\nabstract class CommandFold extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  abstract commandName: string;\n  direction: FoldDirection | undefined;\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n    const args =\n      this.direction !== undefined\n        ? { levels: timesToRepeat, direction: this.direction }\n        : undefined;\n    await vscode.commands.executeCommand(this.commandName, args);\n    vimState.cursors = getCursorsAfterSync();\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandToggleFold extends CommandFold {\n  keys = ['z', 'a'];\n  commandName = 'editor.toggleFold';\n}\n\n@RegisterAction\nclass CommandCloseFold extends CommandFold {\n  keys = ['z', 'c'];\n  commandName = 'editor.fold';\n  direction: FoldDirection = 'up';\n}\n\n@RegisterAction\nclass CommandCloseAllFolds extends CommandFold {\n  keys = ['z', 'M'];\n  commandName = 'editor.foldAll';\n}\n\n@RegisterAction\nclass CommandOpenFold extends CommandFold {\n  keys = ['z', 'o'];\n  commandName = 'editor.unfold';\n  direction: FoldDirection = 'down';\n}\n\n@RegisterAction\nclass CommandOpenAllFolds extends CommandFold {\n  keys = ['z', 'R'];\n  commandName = 'editor.unfoldAll';\n}\n\n@RegisterAction\nclass CommandCloseAllFoldsRecursively extends CommandFold {\n  modes = [Mode.Normal];\n  keys = ['z', 'C'];\n  commandName = 'editor.foldRecursively';\n}\n\n@RegisterAction\nclass CommandOpenAllFoldsRecursively extends CommandFold {\n  modes = [Mode.Normal];\n  keys = ['z', 'O'];\n  commandName = 'editor.unfoldRecursively';\n}\n\n@RegisterAction\nclass CommandCenterScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'z'];\n\n  preservesDesiredColumn() {\n    return true;\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    vimState.editor.revealRange(\n      new vscode.Range(vimState.cursorStopPosition, vimState.cursorStopPosition),\n      vscode.TextEditorRevealType.InCenter\n    );\n  }\n}\n\n@RegisterAction\nclass CommandCenterScrollFirstChar extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', '.'];\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    // This particular one moves cursor to first non blank char though\n    vimState.editor.revealRange(\n      new vscode.Range(vimState.cursorStopPosition, vimState.cursorStopPosition),\n      vscode.TextEditorRevealType.InCenter\n    );\n\n    // Move cursor to first char of line\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStopPosition.line\n    );\n  }\n}\n\n@RegisterAction\nclass CommandTopScroll extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['z', 't'];\n\n  preservesDesiredColumn() {\n    return true;\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'top',\n      },\n    });\n  }\n}\n\n@RegisterAction\nclass CommandTopScrollFirstChar extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', '\\n'];\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    // This particular one moves cursor to first non blank char though\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'top',\n      },\n    });\n\n    // Move cursor to first char of line\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStopPosition.line\n    );\n  }\n}\n\n@RegisterAction\nclass CommandBottomScroll extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['z', 'b'];\n\n  preservesDesiredColumn() {\n    return true;\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'bottom',\n      },\n    });\n  }\n}\n\n@RegisterAction\nclass CommandBottomScrollFirstChar extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', '-'];\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    // This particular one moves cursor to first non blank char though\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'bottom',\n      },\n    });\n\n    // Move cursor to first char of line\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStopPosition.line\n    );\n  }\n}\n\n@RegisterAction\nclass CommandGoToOtherEndOfHighlightedText extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['o'];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    [vimState.cursorStartPosition, vimState.cursorStopPosition] = [\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition,\n    ];\n  }\n}\n\n@RegisterAction\nclass CommandGoToOtherSideOfHighlightedText extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['O'];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.VisualBlock) {\n      [vimState.cursorStartPosition, vimState.cursorStopPosition] = [\n        new vscode.Position(\n          vimState.cursorStartPosition.line,\n          vimState.cursorStopPosition.character\n        ),\n        new vscode.Position(\n          vimState.cursorStopPosition.line,\n          vimState.cursorStartPosition.character\n        ),\n      ];\n    } else {\n      return new CommandGoToOtherEndOfHighlightedText().exec(position, vimState);\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandUndo extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['u'];\n  // we support a count to undo by this setting\n  runsOnceForEachCountPrefix = true;\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  // to prevent undo for accidental key chords like: cu, du...\n  mustBeFirstKey = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const newPositions = await vimState.historyTracker.goBackHistoryStep();\n\n    if (newPositions === undefined) {\n      StatusBar.setText(vimState, 'Already at oldest change');\n    } else {\n      vimState.cursors = newPositions.map((x) => new Range(x, x));\n    }\n\n    vimState.alteredHistory = true;\n  }\n}\n\n@RegisterAction\nclass CommandUndoOnLine extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['U'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  mustBeFirstKey = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const newPositions = await vimState.historyTracker.goBackHistoryStepsOnLine();\n\n    if (newPositions !== undefined) {\n      vimState.cursors = newPositions.map((x) => new Range(x, x));\n    }\n\n    vimState.alteredHistory = true;\n  }\n}\n\n@RegisterAction\nclass CommandRedo extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-r>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const newPositions = await vimState.historyTracker.goForwardHistoryStep();\n\n    if (newPositions === undefined) {\n      StatusBar.setText(vimState, 'Already at newest change');\n    } else {\n      vimState.cursors = newPositions.map((x) => new Range(x, x));\n    }\n\n    vimState.alteredHistory = true;\n  }\n}\n\n@RegisterAction\nclass CommandDeleteToLineEnd extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['D'];\n  canBeRepeatedWithDot = true;\n  runsOnceForEveryCursor() {\n    return true;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.isLineEnd()) {\n      return;\n    }\n\n    const linesDown = (vimState.recordedState.count || 1) - 1;\n    const start = position;\n    const end = position.getDown(linesDown).getLineEnd().getLeftThroughLineBreaks();\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nexport class CommandYankFullLine extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['Y'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const linesDown = (vimState.recordedState.count || 1) - 1;\n    const start = position.getLineBegin();\n    const end = position.getDown(linesDown).getLeft();\n\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await new operator.YankOperator().run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nclass CommandChangeToLineEnd extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['C'];\n  runsOnceForEachCountPrefix = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const count = vimState.recordedState.count || 1;\n\n    await new operator.ChangeOperator().run(\n      vimState,\n      position,\n      position\n        .getDown(Math.max(0, count - 1))\n        .getLineEnd()\n        .getLeft()\n    );\n  }\n}\n\n@RegisterAction\nclass CommandClearLine extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['S'];\n  runsOnceForEachCountPrefix = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new operator.ChangeOperator(this.multicursorIndex).runRepeat(\n      vimState,\n      position,\n      vimState.recordedState.count || 1\n    );\n  }\n\n  // Don't clash with sneak\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && !configuration.sneak;\n  }\n\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.couldActionApply(vimState, keysPressed) && !configuration.sneak;\n  }\n}\n\n@RegisterAction\nclass CommandExitVisualMode extends BaseCommand {\n  modes = [Mode.Visual];\n  keys = ['v'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class CommandVisualMode extends BaseCommand {\n  modes = [Mode.Normal, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['v'];\n  isCompleteAction = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Visual);\n  }\n}\n\n@RegisterAction\nclass CommandReselectVisual extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'v'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // Try to restore selection only if valid\n    if (vimState.lastVisualSelection !== undefined) {\n      if (vimState.lastVisualSelection.end.line <= vimState.document.lineCount - 1) {\n        await vimState.setCurrentMode(vimState.lastVisualSelection.mode);\n        vimState.cursorStartPosition = vimState.lastVisualSelection.start;\n        vimState.cursorStopPosition = vimState.lastVisualSelection.end.getLeft();\n      }\n    }\n  }\n}\n\n@RegisterAction\nclass CommandVisualBlockMode extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [['<C-v>'], ['<C-q>']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.VisualBlock);\n  }\n}\n\n@RegisterAction\nclass CommandExitVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['<C-v>'], ['<C-q>']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandVisualLineMode extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  keys = ['V'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.VisualLine);\n\n    if (vimState.recordedState.count > 1) {\n      vimState.cursorStopPosition = vimState.cursorStopPosition.getDown(\n        vimState.recordedState.count - 1\n      );\n    }\n  }\n}\n\n@RegisterAction\nclass CommandExitVisualLineMode extends BaseCommand {\n  modes = [Mode.VisualLine];\n  keys = ['V'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandOpenFile extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = ['g', 'f'];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    let fullFilePath: string;\n    if (vimState.currentMode === Mode.Visual) {\n      fullFilePath = vimState.document.getText(vimState.editor.selection);\n    } else {\n      const range = new vscode.Range(\n        getWordLeft(position, WordType.FileName, true),\n        getWordRight(position, WordType.FileName)\n      );\n\n      fullFilePath = vimState.document.getText(range).trim();\n    }\n\n    const fileInfo = fullFilePath.match(/(.*?(?=:[0-9]+)|.*):?([0-9]*)$/);\n    if (fileInfo) {\n      const filePath = fileInfo[1];\n      const lineNumber = parseInt(fileInfo[2], 10);\n      const fileCommand = new FileCommand({\n        name: filePath,\n        lineNumber,\n        createFileIfNotExists: false,\n      });\n      fileCommand.execute(vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandGoToDefinition extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['g', 'd'], ['<C-]>']];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.goToDeclaration');\n\n    if (vimState.editor === vscode.window.activeTextEditor) {\n      // We didn't switch to a different editor\n      vimState.cursorStopPosition = vimState.editor.selection.start;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandOpenLink extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['g', 'x'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vscode.commands.executeCommand('editor.action.openLink');\n  }\n}\n\n@RegisterAction\nclass CommandGoBackInChangelist extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', ';'];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const originalIndex = vimState.historyTracker.changelistIndex;\n    const prevPos = vimState.historyTracker.getChangePositionAtIndex(originalIndex - 1);\n    const currPos = vimState.historyTracker.getChangePositionAtIndex(originalIndex);\n\n    if (prevPos !== undefined) {\n      vimState.cursorStopPosition = prevPos[0];\n      vimState.historyTracker.changelistIndex = originalIndex - 1;\n    } else if (currPos !== undefined) {\n      vimState.cursorStopPosition = currPos[0];\n    }\n  }\n}\n\n@RegisterAction\nclass CommandGoForwardInChangelist extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', ','];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const originalIndex = vimState.historyTracker.changelistIndex;\n    const nextPos = vimState.historyTracker.getChangePositionAtIndex(originalIndex + 1);\n    const currPos = vimState.historyTracker.getChangePositionAtIndex(originalIndex);\n\n    if (nextPos !== undefined) {\n      vimState.cursorStopPosition = nextPos[0];\n      vimState.historyTracker.changelistIndex = originalIndex + 1;\n    } else if (currPos !== undefined) {\n      vimState.cursorStopPosition = currPos[0];\n    }\n  }\n}\n\n@RegisterAction\nclass CommandGoStartPrevOperatedText extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = [\n    ['`', '['],\n    [\"'\", '['],\n  ];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const lastPos = vimState.historyTracker.getLastChangeStartPosition();\n    if (lastPos !== undefined) {\n      vimState.cursorStopPosition = lastPos;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandGoEndPrevOperatedText extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = [\n    ['`', ']'],\n    [\"'\", ']'],\n  ];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const lastPos = vimState.historyTracker.getLastChangeEndPosition();\n    if (lastPos !== undefined) {\n      vimState.cursorStopPosition = lastPos;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandGoLastChange extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [\n    ['`', '.'],\n    [\"'\", '.'],\n  ];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const lastPos = vimState.historyTracker.getLastHistoryStartPosition();\n\n    if (lastPos !== undefined) {\n      vimState.cursorStopPosition = lastPos[0];\n    }\n  }\n}\n\n@RegisterAction\nclass CommandInsertAtLastChange extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'i'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.cursorStopPosition =\n      vimState.historyTracker.getLastChangeEndPosition() ?? new Position(0, 0);\n\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtFirstCharacter extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['I'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      position.line\n    );\n  }\n}\n\n@RegisterAction\nclass CommandInsertAtLineBegin extends BaseCommand {\n  modes = [Mode.Normal];\n  mustBeFirstKey = true;\n  keys = ['g', 'I'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = position.getLineBegin();\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAfterCursor extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['a'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = position.getRight();\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Only allow this command to be prefixed with a count or nothing, no other actions or operators before\n    if (!vimState.recordedState.actionsRun.every((action) => action instanceof CommandNumber)) {\n      return false;\n    }\n\n    return super.couldActionApply(vimState, keysPressed);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtLineEnd extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['A'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = position.getLineEnd();\n  }\n}\n\n@RegisterAction\nclass CommandInsertNewLineAbove extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['O'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    const count = vimState.recordedState.count || 1;\n\n    for (let i = 0; i < count; i++) {\n      await vscode.commands.executeCommand('editor.action.insertLineBefore');\n    }\n\n    vimState.cursors = getCursorsAfterSync();\n    for (let i = 0; i < count; i++) {\n      const newPos = new Position(\n        vimState.cursors[0].start.line + i,\n        vimState.cursors[0].start.character\n      );\n      vimState.cursors.push(new Range(newPos, newPos));\n    }\n    vimState.cursors = vimState.cursors.reverse();\n    vimState.isFakeMultiCursor = true;\n    vimState.isMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass CommandInsertNewLineBefore extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['o'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    const count = vimState.recordedState.count || 1;\n\n    for (let i = 0; i < count; i++) {\n      await vscode.commands.executeCommand('editor.action.insertLineAfter');\n    }\n    vimState.cursors = getCursorsAfterSync();\n    for (let i = 1; i < count; i++) {\n      const newPos = new Position(\n        vimState.cursorStartPosition.line - i,\n        vimState.cursorStartPosition.character\n      );\n      vimState.cursors.push(new Range(newPos, newPos));\n\n      // Ahhhhhh. We have to manually set cursor position here as we need text\n      // transformations AND to set multiple cursors.\n      vimState.recordedState.transformer.addTransformation({\n        type: 'insertText',\n        text: TextEditor.setIndentationLevel('', newPos.character),\n        position: newPos,\n        cursorIndex: i,\n        manuallySetCursorPositions: true,\n      });\n    }\n    vimState.cursors = vimState.cursors.reverse();\n    vimState.isFakeMultiCursor = true;\n    vimState.isMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass CommandNavigateBack extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['<C-o>'], ['<C-t>']];\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await globalState.jumpTracker.jumpBack(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandNavigateForward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-i>'];\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await globalState.jumpTracker.jumpForward(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandNavigateLast extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['`', '`'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await globalState.jumpTracker.jumpBack(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandNavigateLastBOL extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [\"'\", \"'\"];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  isJump = true;\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const lastJump = globalState.jumpTracker.end;\n    if (lastJump == null) {\n      // This command goes to the last jump, and there is no previous jump, so there's nothing to do.\n      return;\n    }\n    const jump = new Jump({\n      editor: vimState.editor,\n      fileName: vimState.document.fileName,\n      position: lastJump.position.getLineBegin(),\n    });\n    globalState.jumpTracker.recordJump(Jump.fromStateNow(vimState), jump);\n    vimState.cursorStopPosition = jump.position;\n  }\n}\n\n@RegisterAction\nclass CommandQuit extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [\n    ['<C-w>', 'q'],\n    ['<C-w>', '<C-q>'],\n    ['<C-w>', 'c'],\n    ['<C-w>', '<C-c>'],\n  ];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    new QuitCommand({}).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass CommandOnly extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [\n    ['<C-w>', 'o'],\n    ['<C-w>', '<C-o>'],\n  ];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    new OnlyCommand({}).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass MoveToRightPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'l'],\n    ['<C-w>', '<right>'],\n    ['<C-w>', '<C-l>'],\n  ];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateRight',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass MoveToLowerPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'j'],\n    ['<C-w>', '<down>'],\n    ['<C-w>', '<C-j>'],\n  ];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateDown',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass MoveToUpperPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'k'],\n    ['<C-w>', '<up>'],\n    ['<C-w>', '<C-k>'],\n  ];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateUp',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass MoveToLeftPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'h'],\n    ['<C-w>', '<left>'],\n    ['<C-w>', '<C-h>'],\n  ];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateLeft',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass CycleThroughPanes extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', '<C-w>'],\n    ['<C-w>', 'w'],\n  ];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateEditorGroups',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass VerticalSplit extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'v'],\n    ['<C-w>', '<C-v>'],\n  ];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.splitEditor',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass OrthogonalSplit extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 's'],\n    ['<C-w>', '<C-s>'],\n  ];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.splitEditorOrthogonal',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass EvenPaneWidths extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['<C-w>', '='];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.evenEditorWidths',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass CommandTabNext extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [['g', 't'], ['<C-pagedown>']];\n  runsOnceForEachCountPrefix = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // gt behaves differently than gT and goes to an absolute index tab\n    // (1-based), it does NOT iterate over next tabs\n    if (vimState.recordedState.count > 0) {\n      new TabCommand({\n        tab: Tab.Absolute,\n        count: vimState.recordedState.count - 1,\n      }).execute(vimState);\n    } else {\n      new TabCommand({\n        tab: Tab.Next,\n        count: 1,\n      }).execute(vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandTabPrevious extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [['g', 'T'], ['<C-pageup>']];\n  runsOnceForEachCountPrefix = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    new TabCommand({\n      tab: Tab.Previous,\n      count: 1,\n    }).execute(vimState);\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteChar extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['x'];\n  canBeRepeatedWithDot = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // If line is empty, do nothing\n    if (vimState.document.lineAt(position).text.length === 0) {\n      return;\n    }\n\n    const timesToRepeat = vimState.recordedState.count || 1;\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      position,\n      position.getRight(timesToRepeat - 1).getLeftIfEOL()\n    );\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteCharWithDeleteKey extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<Del>'];\n  runsOnceForEachCountPrefix = true;\n  canBeRepeatedWithDot = true;\n\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    // If <del> has a count in front of it, then <del> deletes a character\n    // off the count. Therefore, 100<del>x, would apply 'x' 10 times.\n    // http://vimdoc.sourceforge.net/htmldoc/change.html#<Del>\n    if (vimState.recordedState.count !== 0) {\n      vimState.recordedState.count = Math.floor(vimState.recordedState.count / 10);\n\n      // Change actionsRunPressedKeys so that showCmd updates correctly\n      vimState.recordedState.actionsRunPressedKeys =\n        vimState.recordedState.count > 0 ? vimState.recordedState.count.toString().split('') : [];\n      this.isCompleteAction = false;\n    } else {\n      await new ActionDeleteChar().execCount(position, vimState);\n    }\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteLastChar extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['X'];\n  canBeRepeatedWithDot = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.character === 0) {\n      return;\n    }\n\n    const timesToRepeat = vimState.recordedState.count || 1;\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      position.getLeft(timesToRepeat),\n      position.getLeft()\n    );\n  }\n}\n\n@RegisterAction\nclass ActionJoin extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['J'];\n  canBeRepeatedWithDot = true;\n  runsOnceForEachCountPrefix = false;\n\n  private firstNonWhitespaceIndex(str: string): number {\n    for (let i = 0, len = str.length; i < len; i++) {\n      const chCode = str.charCodeAt(i);\n      if (chCode !== 32 /** space */ && chCode !== 9 /** tab */) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  public async execJoinLines(\n    startPosition: Position,\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<void> {\n    count = count - 1 || 1;\n\n    let startLineNumber: number;\n    let startColumn: number;\n    let endLineNumber: number;\n    let endColumn: number;\n    let columnDeltaOffset: number = 0;\n\n    if (startPosition.isEqual(position) || startPosition.line === position.line) {\n      if (position.line + 1 < vimState.document.lineCount) {\n        startLineNumber = position.line;\n        startColumn = 0;\n        endLineNumber = position.getDown(count).line;\n        endColumn = TextEditor.getLineLength(endLineNumber);\n      } else {\n        startLineNumber = position.line;\n        startColumn = 0;\n        endLineNumber = position.line;\n        endColumn = TextEditor.getLineLength(endLineNumber);\n      }\n    } else {\n      startLineNumber = startPosition.line;\n      startColumn = 0;\n      endLineNumber = position.line;\n      endColumn = TextEditor.getLineLength(endLineNumber);\n    }\n\n    let trimmedLinesContent = vimState.document.lineAt(startPosition).text;\n\n    for (let i = startLineNumber + 1; i <= endLineNumber; i++) {\n      const lineText = vimState.document.lineAt(i).text;\n\n      const firstNonWhitespaceIdx = this.firstNonWhitespaceIndex(lineText);\n\n      if (firstNonWhitespaceIdx >= 0) {\n        let insertSpace = true;\n\n        if (\n          trimmedLinesContent === '' ||\n          trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === ' ' ||\n          trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === '\\t'\n        ) {\n          insertSpace = false;\n        }\n\n        const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx);\n\n        if (lineTextWithoutIndent.charAt(0) === ')') {\n          insertSpace = false;\n        }\n\n        trimmedLinesContent += (insertSpace ? ' ' : '') + lineTextWithoutIndent;\n\n        if (insertSpace) {\n          columnDeltaOffset = lineTextWithoutIndent.length + 1;\n        } else {\n          columnDeltaOffset = lineTextWithoutIndent.length;\n        }\n      } else if (\n        trimmedLinesContent === '' ||\n        trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === ' ' ||\n        trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === '\\t'\n      ) {\n        columnDeltaOffset += 0;\n      } else {\n        trimmedLinesContent += ' ';\n        columnDeltaOffset += 1;\n      }\n    }\n\n    const deleteStartPosition = new Position(startLineNumber, startColumn);\n    const deleteEndPosition = new Position(endLineNumber, endColumn);\n\n    if (!deleteStartPosition.isEqual(deleteEndPosition)) {\n      if (startPosition.isEqual(position)) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: trimmedLinesContent,\n          range: new Range(deleteStartPosition, deleteEndPosition),\n          diff: new PositionDiff({\n            character: trimmedLinesContent.length - columnDeltaOffset - position.character,\n          }),\n        });\n      } else {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: trimmedLinesContent,\n          range: new Range(deleteStartPosition, deleteEndPosition),\n          manuallySetCursorPositions: true,\n        });\n\n        vimState.cursorStartPosition = vimState.cursorStopPosition = new Position(\n          startPosition.line,\n          trimmedLinesContent.length - columnDeltaOffset\n        );\n        await vimState.setCurrentMode(Mode.Normal);\n      }\n    }\n  }\n\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    const cursorsToIterateOver = vimState.cursors\n      .map((x) => new Range(x.start, x.stop))\n      .sort((a, b) =>\n        a.start.line > b.start.line ||\n        (a.start.line === b.start.line && a.start.character > b.start.character)\n          ? 1\n          : -1\n      );\n\n    const resultingCursors: Range[] = [];\n    for (const [idx, { start, stop }] of cursorsToIterateOver.entries()) {\n      this.multicursorIndex = idx;\n\n      vimState.cursorStopPosition = stop;\n      vimState.cursorStartPosition = start;\n\n      await this.execJoinLines(start, stop, vimState, vimState.recordedState.count || 1);\n\n      resultingCursors.push(new Range(vimState.cursorStartPosition, vimState.cursorStopPosition));\n\n      for (const transformation of vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = this.multicursorIndex;\n        }\n      }\n    }\n\n    vimState.cursors = resultingCursors;\n  }\n}\n\n@RegisterAction\nclass ActionJoinVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['J'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.editor.selection.start, vimState.editor.selection.end);\n\n    /**\n     * For joining lines, Visual Line behaves the same as Visual so we align the register mode here.\n     */\n    vimState.currentRegisterMode = RegisterMode.CharacterWise;\n    await new ActionJoin().execJoinLines(start, end, vimState, 1);\n  }\n}\n\n@RegisterAction\nclass ActionJoinVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['J'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n\n    vimState.currentRegisterMode = RegisterMode.CharacterWise;\n    await new ActionJoin().execJoinLines(start, end, vimState, 1);\n  }\n}\n\n@RegisterAction\nclass ActionJoinNoWhitespace extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'J'];\n  canBeRepeatedWithDot = true;\n\n  // gJ is essentially J without the edge cases. ;-)\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.line === vimState.document.lineCount - 1) {\n      return; // TODO: bell\n    }\n\n    const count = vimState.recordedState.count > 2 ? vimState.recordedState.count - 1 : 1;\n    await this.execJoin(count, position, vimState);\n  }\n\n  public async execJoin(count: number, position: Position, vimState: VimState): Promise<void> {\n    const lastLine = Math.min(position.line + count, vimState.document.lineCount - 1);\n    const lines: string[] = [];\n    for (let i = position.line + 1; i <= lastLine; i++) {\n      lines.push(vimState.document.lineAt(i).text);\n    }\n    const resultLine = vimState.document.lineAt(position.line).text + lines.join('');\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      position.getLineBegin(),\n      TextEditor.getLineLength(lastLine) > 0\n        ? position.getDown(count).getLineEnd().getLeft()\n        : position.getDown(count - 1).getLineEnd()\n    );\n\n    const lastLineLength = lines[lines.length - 1].length;\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertText',\n      text: resultLine,\n      position,\n      diff: new PositionDiff({\n        character: -lastLineLength,\n      }),\n    });\n\n    vimState.cursorStopPosition = new Position(position.line, resultLine.length - lastLineLength);\n  }\n}\n\n@RegisterAction\nclass ActionJoinNoWhitespaceVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['g', 'J'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    const count = start.line === end.line ? 1 : end.line - start.line;\n    vimState.currentRegisterMode = RegisterMode.CharacterWise;\n    return new ActionJoinNoWhitespace().execJoin(count, start, vimState);\n  }\n}\n\n@RegisterAction\nclass ActionReplaceCharacter extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['r', '<character>'];\n  canBeRepeatedWithDot = true;\n  runsOnceForEachCountPrefix = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n    const toReplace = this.keysPressed[1];\n\n    /**\n     * <character> includes <BS>, <S-BS> and <TAB> but not any control keys,\n     * so we ignore the former two keys and have a special handle for <tab>.\n     */\n\n    if (['<BS>', '<S-BS>'].includes(toReplace.toUpperCase())) {\n      return;\n    }\n\n    if (position.character + timesToRepeat > position.getLineEnd().character) {\n      return;\n    }\n\n    let endPos = new Position(position.line, position.character + timesToRepeat);\n\n    // Return if tried to repeat longer than linelength\n    if (endPos.character > vimState.document.lineAt(endPos).text.length) {\n      return;\n    }\n\n    // If last char (not EOL char), add 1 so that replace selection is complete\n    if (endPos.character > vimState.document.lineAt(endPos).text.length) {\n      endPos = new Position(endPos.line, endPos.character + 1);\n    }\n\n    if (toReplace === '<tab>') {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new Range(position, endPos),\n      });\n      vimState.recordedState.transformer.addTransformation({\n        type: 'tab',\n        cursorIndex: this.multicursorIndex,\n        diff: new PositionDiff({ character: -1 }),\n      });\n    } else if (toReplace === '\\n') {\n      // A newline replacement always inserts exactly one newline (regardless\n      // of count prefix) and puts the cursor on the next line.\n      // We use `insertTextVSCode` so we get the right indentation\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new Range(position, endPos),\n      });\n      vimState.recordedState.transformer.addTransformation({\n        type: 'insertTextVSCode',\n        text: '\\n',\n      });\n    } else {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: toReplace.repeat(timesToRepeat),\n        range: new Range(position, endPos),\n        diff: new PositionDiff({ character: timesToRepeat - 1 }),\n      });\n    }\n  }\n\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    await super.execCount(position, vimState);\n  }\n}\n\n@RegisterAction\nclass ActionReplaceCharacterVisual extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['r', '<character>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  canBeRepeatedWithDot = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    let toInsert = this.keysPressed[1];\n\n    if (toInsert === '<tab>') {\n      toInsert = TextEditor.getTabCharacter(vimState.editor);\n    }\n\n    let visualSelectionOffset = 1;\n\n    // If selection is reversed, reorganize it so that the text replace logic always works\n    let [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    if (vimState.currentMode === Mode.VisualLine) {\n      [start, end] = [start.getLineBegin(), end.getLineEnd()];\n    }\n\n    // Limit to not replace EOL\n    const textLength = vimState.document.lineAt(end).text.length;\n    if (textLength <= 0) {\n      visualSelectionOffset = 0;\n    }\n    end = new Position(end.line, Math.min(end.character, textLength > 0 ? textLength - 1 : 0));\n\n    // Iterate over every line in the current selection\n    for (let lineNum = start.line; lineNum <= end.line; lineNum++) {\n      // Get line of text\n      const lineText = vimState.document.lineAt(lineNum).text;\n\n      if (start.line === end.line) {\n        // This is a visual section all on one line, only replace the part within the selection\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(end.character - start.character + 2).join(toInsert),\n          range: new Range(start, new Position(end.line, end.character + 1)),\n          manuallySetCursorPositions: true,\n        });\n      } else if (lineNum === start.line) {\n        // This is the first line of the selection so only replace after the cursor\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(lineText.length - start.character + 1).join(toInsert),\n          range: new Range(start, new Position(start.line, lineText.length)),\n          manuallySetCursorPositions: true,\n        });\n      } else if (lineNum === end.line) {\n        // This is the last line of the selection so only replace before the cursor\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(end.character + 1 + visualSelectionOffset).join(toInsert),\n          range: new Range(\n            new Position(end.line, 0),\n            new Position(end.line, end.character + visualSelectionOffset)\n          ),\n          manuallySetCursorPositions: true,\n        });\n      } else {\n        // Replace the entire line length since it is in the middle of the selection\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(lineText.length + 1).join(toInsert),\n          range: new Range(new Position(lineNum, 0), new Position(lineNum, lineText.length)),\n          manuallySetCursorPositions: true,\n        });\n      }\n    }\n\n    vimState.cursorStopPosition = start;\n    vimState.cursorStartPosition = start;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionReplaceCharacterVisualBlock extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['r', '<character>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  canBeRepeatedWithDot = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    let toInsert = this.keysPressed[1];\n\n    if (toInsert === '<tab>') {\n      toInsert = TextEditor.getTabCharacter(vimState.editor);\n    }\n\n    for (const { start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      if (end.isBeforeOrEqual(start)) {\n        continue;\n      }\n\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: Array(end.character - start.character + 1).join(toInsert),\n        range: new Range(start, end),\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    const topLeft = visualBlockGetTopLeftPosition(\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition\n    );\n    vimState.cursors = [new Range(topLeft, topLeft)];\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionDeleteVisualBlock extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['d'], ['x'], ['X']];\n  canBeRepeatedWithDot = true;\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const lines: string[] = [];\n\n    for (const { line, start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      lines.push(line);\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new Range(start, end),\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    const text = lines.length === 1 ? lines[0] : lines.join('\\n');\n    vimState.currentRegisterMode = RegisterMode.BlockWise;\n    Register.put(text, vimState, this.multicursorIndex);\n\n    const topLeft = visualBlockGetTopLeftPosition(\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition\n    );\n\n    vimState.cursors = [new Range(topLeft, topLeft)];\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionShiftDVisualBlock extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['D'];\n  canBeRepeatedWithDot = true;\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    for (const { start } of TextEditor.iterateLinesInBlock(vimState)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new Range(start, start.getLineEnd()),\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    const topLeft = visualBlockGetTopLeftPosition(\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition\n    );\n\n    vimState.cursors = [new Range(topLeft, topLeft)];\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['I'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isMultiCursor = true;\n    vimState.isFakeMultiCursor = true;\n\n    for (const { line, start } of TextEditor.iterateLinesInBlock(vimState)) {\n      if (line === '' && start.character !== 0) {\n        continue;\n      }\n      vimState.cursors.push(new Range(start, start));\n    }\n    vimState.cursors = vimState.cursors.slice(1);\n  }\n}\n\n@RegisterAction\nclass ActionChangeInVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['c'], ['s']];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    for (const { start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new Range(start, end),\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isMultiCursor = true;\n    vimState.isFakeMultiCursor = true;\n\n    for (const { start } of TextEditor.iterateLinesInBlock(vimState)) {\n      vimState.cursors.push(new Range(start, start));\n    }\n    vimState.cursors = vimState.cursors.slice(1);\n  }\n}\n\n@RegisterAction\nclass ActionChangeToEOLInVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['C'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const cursors: Range[] = [];\n    for (const cursor of vimState.cursors) {\n      for (const { start, end } of TextEditor.iterateLinesInBlock(vimState, cursor)) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'deleteRange',\n          range: new Range(start, start.getLineEnd()),\n          collapseRange: true,\n        });\n        cursors.push(new Range(end, end));\n      }\n    }\n    vimState.cursors = cursors;\n\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isMultiCursor = true;\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\nabstract class ActionGoToInsertVisualLineModeCommand extends BaseCommand {\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  abstract getCursorRangeForLine(\n    line: vscode.TextLine,\n    selectionStart: Position,\n    selectionEnd: Position\n  ): Range;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isMultiCursor = true;\n    vimState.isFakeMultiCursor = true;\n\n    const resultingCursors: Range[] = [];\n    const cursorsOnBlankLines: Range[] = [];\n    for (const selection of vimState.editor.selections) {\n      const { start, end } = selection;\n\n      for (let i = start.line; i <= end.line; i++) {\n        const line = vimState.document.lineAt(i);\n\n        const cursorRange = this.getCursorRangeForLine(line, start, end);\n        if (!line.isEmptyOrWhitespace) {\n          resultingCursors.push(cursorRange);\n        } else {\n          cursorsOnBlankLines.push(cursorRange);\n        }\n      }\n    }\n\n    if (resultingCursors.length > 0) {\n      vimState.cursors = resultingCursors;\n    } else {\n      vimState.cursors = cursorsOnBlankLines;\n    }\n  }\n}\n\n@RegisterAction\nexport class ActionGoToInsertVisualLineMode extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.VisualLine];\n  keys = ['I'];\n\n  getCursorRangeForLine(line: vscode.TextLine): Range {\n    const startCharacterPosition = new Position(\n      line.lineNumber,\n      line.firstNonWhitespaceCharacterIndex\n    );\n    return new Range(startCharacterPosition, startCharacterPosition);\n  }\n}\n\n@RegisterAction\nexport class ActionGoToInsertVisualLineModeAppend extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.VisualLine];\n  keys = ['A'];\n\n  getCursorRangeForLine(line: vscode.TextLine): Range {\n    const endCharacterPosition = new Position(line.lineNumber, line.range.end.character);\n    return new Range(endCharacterPosition, endCharacterPosition);\n  }\n}\n\n@RegisterAction\nexport class ActionGoToInsertVisualMode extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.Visual];\n  keys = ['I'];\n\n  getCursorRangeForLine(\n    line: vscode.TextLine,\n    selectionStart: Position,\n    selectionEnd: Position\n  ): Range {\n    const startCharacterPosition =\n      line.lineNumber === selectionStart.line\n        ? selectionStart\n        : new Position(line.lineNumber, line.firstNonWhitespaceCharacterIndex);\n    return new Range(startCharacterPosition, startCharacterPosition);\n  }\n}\n\n@RegisterAction\nexport class ActionGoToInsertVisualModeAppend extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.Visual];\n  keys = ['A'];\n\n  getCursorRangeForLine(\n    line: vscode.TextLine,\n    selectionStart: Position,\n    selectionEnd: Position\n  ): Range {\n    const endCharacterPosition =\n      line.lineNumber === selectionEnd.line\n        ? selectionEnd\n        : new Position(line.lineNumber, line.range.end.character);\n    return new Range(endCharacterPosition, endCharacterPosition);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualBlockModeAppend extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['A'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const newCursors: Range[] = [];\n    for (const cursor of vimState.cursors) {\n      const [start, end] = sorted(cursor.start, cursor.stop);\n      for (let lineNum = start.line; lineNum <= end.line; lineNum++) {\n        const line = vimState.document.lineAt(lineNum);\n        const insertionColumn =\n          vimState.desiredColumn === Number.POSITIVE_INFINITY\n            ? line.text.length\n            : Math.max(cursor.start.character, cursor.stop.character) + 1;\n        if (line.text.length < insertionColumn) {\n          await TextEditor.insertAt(\n            vimState.editor,\n            ' '.repeat(insertionColumn - line.text.length),\n            line.range.end\n          );\n        }\n        const newCursor = new Position(lineNum, insertionColumn);\n        newCursors.push(new Range(newCursor, newCursor));\n      }\n    }\n\n    vimState.cursors = newCursors;\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isMultiCursor = true;\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass ActionDeleteLineVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['X'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Visual) {\n      await new operator.DeleteOperator(this.multicursorIndex).run(\n        vimState,\n        vimState.cursorStartPosition.getLineBegin(),\n        vimState.cursorStopPosition.getLineEnd()\n      );\n    } else {\n      await new operator.DeleteOperator(this.multicursorIndex).run(\n        vimState,\n        position.getLineBegin(),\n        position.getLineEnd()\n      );\n    }\n  }\n}\n\n@RegisterAction\nclass ActionChangeLineVisualModeS extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['S'];\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return !configuration.surround && super.doesActionApply(vimState, keysPressed);\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    return new ActionChangeLineVisualMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass ActionChangeLineVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = [['C'], ['R']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    await new operator.ChangeOperator(this.multicursorIndex).run(\n      vimState,\n      start.getLineBegin(),\n      end.getLineEndIncludingEOL()\n    );\n  }\n}\n\n@RegisterAction\nclass ActionChangeLineVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['R'], ['S']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    return new ActionChangeLineVisualMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass ActionChangeChar extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['s'];\n  runsOnceForEachCountPrefix = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new operator.ChangeOperator().run(vimState, position, position);\n\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n\n  // Don't clash with surround or sneak modes!\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return (\n      super.doesActionApply(vimState, keysPressed) &&\n      !configuration.sneak &&\n      !vimState.recordedState.operator\n    );\n  }\n\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return (\n      super.couldActionApply(vimState, keysPressed) &&\n      !configuration.sneak &&\n      !vimState.recordedState.operator\n    );\n  }\n}\n\n@RegisterAction\nclass ToggleCaseAndMoveForward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['~'];\n  mustBeFirstKey = true;\n  canBeRepeatedWithDot = true;\n  runsOnceForEachCountPrefix = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new operator.ToggleCaseOperator().run(\n      vimState,\n      vimState.cursorStopPosition,\n      vimState.cursorStopPosition\n    );\n\n    vimState.cursorStopPosition = shouldWrapKey(vimState.currentMode, '~')\n      ? vimState.cursorStopPosition.getRightThroughLineBreaks()\n      : vimState.cursorStopPosition.getRight();\n  }\n}\n\nabstract class IncrementDecrementNumberAction extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  canBeRepeatedWithDot = true;\n  abstract offset: number;\n  abstract staircase: boolean;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const ranges = this.getSearchRanges(vimState);\n\n    let stepNum = 1;\n\n    for (const [idx, range] of ranges.entries()) {\n      position = range.start;\n\n      const text = vimState.document.lineAt(position).text;\n\n      // Make sure position within the text is possible and return if not\n      if (text.length <= position.character) {\n        continue;\n      }\n\n      // Start looking to the right for the next word to increment, unless we're\n      // already on a word to increment, in which case start at the beginning of\n      // that word.\n      const whereToStart = text[position.character].match(/\\s/)\n        ? position\n        : position.getWordLeft(true);\n\n      wordLoop: for (let { start, end, word } of TextEditor.iterateWords(\n        vimState.document,\n        whereToStart\n      )) {\n        if (start.isAfter(range.stop)) {\n          break;\n        }\n\n        // '-' doesn't count as a word, but is important to include in parsing\n        // the number, as long as it is not just part of the word (-foo2 for example)\n        if (text[start.character - 1] === '-' && /\\d/.test(text[start.character])) {\n          start = start.getLeft();\n          word = text[start.character] + word;\n        }\n        // Strict number parsing so \"1a\" doesn't silently get converted to \"1\"\n        do {\n          const result = NumericString.parse(word);\n          if (result === undefined) {\n            break;\n          }\n          const { num, suffixOffset } = result;\n\n          // Use suffix offset to check if current cursor is in or before detected number.\n          if (position.character < start.character + suffixOffset) {\n            const pos = await this.replaceNum(\n              vimState.editor,\n              num,\n              this.offset * stepNum * (vimState.recordedState.count || 1),\n              start,\n              end\n            );\n\n            if (this.staircase) {\n              stepNum++;\n            }\n\n            if (vimState.currentMode === Mode.Normal) {\n              vimState.cursorStartPosition = vimState.cursorStopPosition = pos.getLeft(\n                num.suffix.length\n              );\n            }\n            break wordLoop;\n          } else {\n            // For situation like this: xyz1999em199[cursor]9m\n            word = word.slice(suffixOffset);\n            start = new Position(start.line, start.character + suffixOffset);\n          }\n        } while (true);\n      }\n    }\n\n    if (isVisualMode(vimState.currentMode)) {\n      vimState.cursorStopPosition = ranges[0].start;\n    }\n\n    vimState.setCurrentMode(Mode.Normal);\n  }\n\n  private async replaceNum(\n    editor: vscode.TextEditor,\n    start: NumericString,\n    offset: number,\n    startPos: Position,\n    endPos: Position\n  ): Promise<Position> {\n    const oldLength = endPos.character + 1 - startPos.character;\n    start.value += offset;\n    const newNum = start.toString();\n\n    const range = new vscode.Range(startPos, endPos.getRight());\n\n    await TextEditor.replace(editor, range, newNum);\n    if (oldLength !== newNum.length) {\n      // Adjust end position according to difference in width of number-string\n      endPos = new Position(endPos.line, startPos.character + newNum.length - 1);\n    }\n\n    return endPos;\n  }\n\n  /**\n   * @returns a list of Ranges in which to search for numbers\n   */\n  private getSearchRanges(vimState: VimState): Range[] {\n    const ranges: Range[] = [];\n    const [start, stop] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    switch (vimState.currentMode) {\n      case Mode.Normal: {\n        ranges.push(\n          new Range(vimState.cursorStopPosition, vimState.cursorStopPosition.getLineEnd())\n        );\n        break;\n      }\n\n      case Mode.Visual: {\n        ranges.push(new Range(start, start.getLineEnd()));\n        for (let line = start.line + 1; line < stop.line; line++) {\n          const lineStart = new Position(line, 0);\n          ranges.push(new Range(lineStart, lineStart.getLineEnd()));\n        }\n        ranges.push(new Range(stop.getLineBegin(), stop));\n        break;\n      }\n\n      case Mode.VisualLine: {\n        for (let line = start.line; line <= stop.line; line++) {\n          const lineStart = new Position(line, 0);\n          ranges.push(new Range(lineStart, lineStart.getLineEnd()));\n        }\n        break;\n      }\n\n      case Mode.VisualBlock: {\n        const topLeft = visualBlockGetTopLeftPosition(start, stop);\n        const bottomRight = visualBlockGetBottomRightPosition(start, stop);\n        for (let line = topLeft.line; line <= bottomRight.line; line++) {\n          ranges.push(\n            new Range(\n              new Position(line, topLeft.character),\n              new Position(line, bottomRight.character)\n            )\n          );\n        }\n        break;\n      }\n\n      default:\n        throw new Error('Unexpected mode in IncrementDecrementNumberAction.getPositions()');\n    }\n    return ranges;\n  }\n}\n\n@RegisterAction\nclass IncrementNumberAction extends IncrementDecrementNumberAction {\n  keys = ['<C-a>'];\n  offset = +1;\n  staircase = false;\n}\n\n@RegisterAction\nclass DecrementNumberAction extends IncrementDecrementNumberAction {\n  keys = ['<C-x>'];\n  offset = -1;\n  staircase = false;\n}\n\n@RegisterAction\nclass IncrementNumberStaircaseAction extends IncrementDecrementNumberAction {\n  keys = ['g', '<C-a>'];\n  offset = +1;\n  staircase = true;\n}\n\n@RegisterAction\nclass DecrementNumberStaircaseAction extends IncrementDecrementNumberAction {\n  keys = ['g', '<C-x>'];\n  offset = -1;\n  staircase = true;\n}\n\n@RegisterAction\nclass CommandUnicodeName extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'a'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const char = vimState.document.getText(new vscode.Range(position, position.getRight()));\n    const charCode = char.charCodeAt(0);\n    // TODO: Handle charCode > 127 by also including <M-x>\n    StatusBar.setText(\n      vimState,\n      `<${char}>  ${charCode},  Hex ${charCode.toString(16)},  Octal ${charCode.toString(8)}`\n    );\n  }\n}\n\n@RegisterAction\nclass ActionTriggerHover extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'h'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.showHover');\n  }\n}\n\n/**\n * Multi-Cursor Command Overrides\n *\n * We currently have to override the VSCode key commands that get us into multi-cursor mode.\n *\n * Normally, we'd just listen for another cursor to be added in order to go into multi-cursor\n * mode rather than rewriting each keybinding one-by-one. We can't currently do that because\n * Visual Block Mode also creates additional cursors, but will get confused if you're in\n * multi-cursor mode.\n */\n\n@RegisterAction\nexport class ActionOverrideCmdD extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = [['<D-d>'], ['g', 'b']];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  runsOnceForEachCountPrefix = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.addSelectionToNextFindMatch');\n    vimState.cursors = getCursorsAfterSync();\n\n    // If this is the first cursor, select 1 character less\n    // so that only the word is selected, no extra character\n    vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getLeft()));\n\n    await vimState.setCurrentMode(Mode.Visual);\n  }\n}\n\n@RegisterAction\nclass ActionOverrideCmdDInsert extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<D-d>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  runsOnceForEachCountPrefix = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // Since editor.action.addSelectionToNextFindMatch uses the selection to\n    // determine where to add a word, we need to do a hack and manually set the\n    // selections to the word boundaries before we make the api call.\n    vimState.editor.selections = vimState.editor.selections.map((x, idx) => {\n      const curPos = x.active;\n      if (idx === 0) {\n        return new vscode.Selection(\n          curPos.getWordLeft(false),\n          curPos.getLeft().getCurrentWordEnd(true).getRight()\n        );\n      } else {\n        // Since we're adding the selections ourselves, we need to make sure\n        // that our selection is actually over what our original word is\n        const matchWordPos = vimState.editor.selections[0].active;\n        const matchWordLength =\n          matchWordPos.getLeft().getCurrentWordEnd(true).getRight().character -\n          matchWordPos.getWordLeft(false).character;\n        const wordBegin = curPos.getLeft(matchWordLength);\n        return new vscode.Selection(wordBegin, curPos);\n      }\n    });\n    await vscode.commands.executeCommand('editor.action.addSelectionToNextFindMatch');\n    vimState.cursors = getCursorsAfterSync();\n  }\n}\n\n@RegisterAction\nclass ActionOverrideCmdAltDown extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['<D-alt+down>'], // OSX\n    ['<C-alt+down>'], // Windows\n  ];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  runsOnceForEachCountPrefix = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.insertCursorBelow');\n    vimState.cursors = getCursorsAfterSync();\n  }\n}\n\n@RegisterAction\nclass ActionOverrideCmdAltUp extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['<D-alt+up>'], // OSX\n    ['<C-alt+up>'], // Windows\n  ];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n  runsOnceForEachCountPrefix = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.insertCursorAbove');\n    vimState.cursors = getCursorsAfterSync();\n  }\n}\n\n@RegisterAction\nclass ActionShowFileInfo extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-g>'];\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    reportFileInfo(position, vimState);\n  }\n}\n\n@RegisterAction\nclass WriteQuit extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['Z', 'Z']];\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new WriteQuitCommand({}).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass Quit extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['Z', 'Q']];\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new QuitCommand({ bang: true }).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass ActionGoToAlternateFile extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['<C-6>'], ['<C-^>']];\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const altFile = await Register.get(undefined, '#');\n    if (altFile === undefined || altFile.text === '') {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NoAlternateFile));\n    } else {\n      const files = await vscode.workspace.findFiles(altFile.text as string);\n      // TODO: if the path matches a file from multiple workspace roots, we may not choose the right one\n      if (files.length > 0) {\n        const document = await vscode.workspace.openTextDocument(files[0]);\n        await vscode.window.showTextDocument(document);\n      }\n    }\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { RegisterAction, BaseCommand } from '../base';\nimport { CommandShowCommandHistory, CommandShowSearchHistory } from './actions';\nimport { Mode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { commandLine } from '../../cmd_line/commandLine';\nimport { globalState } from '../../state/globalState';\nimport { Register, RegisterMode } from '../../register/register';\nimport { reportSearch } from '../../util/statusBarTextUtils';\nimport { RecordedState } from '../../state/recordedState';\nimport { TextEditor } from '../../textEditor';\nimport { StatusBar } from '../../statusBar';\nimport { commandParsers } from '../../cmd_line/subparser';\nimport { getPathDetails, readDirectory } from '../../util/path';\nimport { Clipboard } from '../../util/clipboard';\nimport { VimError, ErrorCode } from '../../error';\nimport { SearchDirection } from '../../state/searchState';\nimport { scrollView } from '../../util/util';\nimport { getWordLeftInText, getWordRightInText, WordType } from '../../textobject/word';\nimport { Position } from 'vscode';\n\n/**\n * Commands that are only relevant when entering a command or search\n */\n\n// TODO: Much of the code in this file is duplicated.\n//       We need an interface to the status bar which can be used by both modes.\n\n// Command tab backward from behind shift tab\n@RegisterAction\nclass CommandTabInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['<tab>'], ['<S-tab>']];\n  runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  private cycleCompletion(vimState: VimState, isTabForward: boolean) {\n    const autoCompleteItems = commandLine.autoCompleteItems;\n    if (autoCompleteItems.length === 0) {\n      return;\n    }\n\n    commandLine.autoCompleteIndex = isTabForward\n      ? (commandLine.autoCompleteIndex + 1) % autoCompleteItems.length\n      : (commandLine.autoCompleteIndex - 1 + autoCompleteItems.length) % autoCompleteItems.length;\n\n    const lastPos = commandLine.preCompleteCharacterPos;\n    const lastCmd = commandLine.preCompleteCommand;\n    const evalCmd = lastCmd.slice(0, lastPos);\n    const restCmd = lastCmd.slice(lastPos);\n\n    vimState.currentCommandlineText =\n      evalCmd + autoCompleteItems[commandLine.autoCompleteIndex] + restCmd;\n    vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length - restCmd.length;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const isTabForward = key === '<tab>';\n\n    if (\n      commandLine.autoCompleteItems.length !== 0 &&\n      this.keys.some((k) => commandLine.lastKeyPressed === k[0])\n    ) {\n      this.cycleCompletion(vimState, isTabForward);\n      commandLine.lastKeyPressed = key;\n      return;\n    }\n\n    let newCompletionItems: string[] = [];\n    const currentCmd = vimState.currentCommandlineText;\n    const cursorPos = vimState.statusBarCursorCharacterPos;\n\n    // Sub string since vim does completion before the cursor\n    let evalCmd = currentCmd.slice(0, cursorPos);\n    const restCmd = currentCmd.slice(cursorPos);\n\n    // \\s* is the match the extra space before any character like ':  edit'\n    const cmdRegex = /^\\s*\\w+$/;\n    const fileRegex = /^\\s*\\w+\\s+/g;\n    if (cmdRegex.test(evalCmd)) {\n      // Command completion\n      newCompletionItems = Object.keys(commandParsers)\n        .filter((cmd) => cmd.startsWith(evalCmd))\n        // Remove the already typed portion in the array\n        .map((cmd) => cmd.slice(cmd.search(evalCmd) + evalCmd.length))\n        .sort();\n    } else if (fileRegex.exec(evalCmd)) {\n      // File completion by searching if there is a space after the first word/command\n      // ideally it should be a process of white-listing to selected commands like :e and :vsp\n      const filePathInCmd = evalCmd.substring(fileRegex.lastIndex);\n      const currentUri = vimState.document.uri;\n      const isRemote = !!vscode.env.remoteName;\n\n      const { fullDirPath, baseName, partialPath, path: p } = getPathDetails(\n        filePathInCmd,\n        currentUri,\n        isRemote\n      );\n      // Update the evalCmd in case of windows, where we change / to \\\n      evalCmd = evalCmd.slice(0, fileRegex.lastIndex) + partialPath;\n\n      // test if the baseName is . or ..\n      const shouldAddDotItems = /^\\.\\.?$/g.test(baseName);\n      const dirItems = await readDirectory(\n        fullDirPath,\n        p.sep,\n        currentUri,\n        isRemote,\n        shouldAddDotItems\n      );\n      newCompletionItems = dirItems\n        .filter((name) => name.startsWith(baseName))\n        .map((name) => name.slice(name.search(baseName) + baseName.length))\n        .sort();\n    }\n\n    const newIndex = isTabForward ? 0 : newCompletionItems.length - 1;\n    commandLine.autoCompleteIndex = newIndex;\n    // If here only one items we fill cmd direct, so the next tab will not cycle the one item array\n    commandLine.autoCompleteItems = newCompletionItems.length <= 1 ? [] : newCompletionItems;\n    commandLine.preCompleteCharacterPos = cursorPos;\n    commandLine.preCompleteCommand = evalCmd + restCmd;\n\n    const completion = newCompletionItems.length === 0 ? '' : newCompletionItems[newIndex];\n    vimState.currentCommandlineText = evalCmd + completion + restCmd;\n    vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length - restCmd.length;\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandEnterInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['\\n'], ['<C-m>']];\n  runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await commandLine.Run(vimState.currentCommandlineText, vimState);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandRemoveWordCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['<C-w>'], ['<C-BS>']];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const pos = vimState.statusBarCursorCharacterPos;\n    const cmdText = vimState.currentCommandlineText;\n    const characterAt = getWordLeftInText(cmdText, pos, WordType.Normal);\n    // Needs explicit check undefined because zero is falsy and zero is a valid character pos.\n    if (characterAt !== undefined) {\n      vimState.currentCommandlineText = cmdText\n        .substring(0, characterAt)\n        .concat(cmdText.slice(pos));\n      vimState.statusBarCursorCharacterPos = pos - (pos - characterAt);\n    }\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandRemoveWordInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = [['<C-w>'], ['<C-BS>']];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const searchState = globalState.searchState;\n    if (searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const pos = vimState.statusBarCursorCharacterPos;\n    const searchString = searchState.searchString;\n    const characterAt = getWordLeftInText(searchString, pos, WordType.Normal);\n    // Needs explicit check undefined because zero is falsy and zero is a valid character pos.\n    if (characterAt !== undefined) {\n      searchState.searchString = searchString\n        .substring(0, characterAt)\n        .concat(searchString.slice(pos));\n      vimState.statusBarCursorCharacterPos = pos - (pos - characterAt);\n    }\n  }\n}\n\n@RegisterAction\nclass WordLeftInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = ['<C-left>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const cmdText = vimState.currentCommandlineText;\n    vimState.statusBarCursorCharacterPos =\n      getWordLeftInText(cmdText, vimState.statusBarCursorCharacterPos, WordType.Big) ?? 0;\n  }\n}\n\n@RegisterAction\nclass WordRightInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = ['<C-right>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const cmdText = vimState.currentCommandlineText;\n    vimState.statusBarCursorCharacterPos =\n      getWordRightInText(cmdText, vimState.statusBarCursorCharacterPos, WordType.Big) ??\n      cmdText.length;\n  }\n}\n\n@RegisterAction\nclass WordLeftInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = ['<C-left>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const searchState = globalState.searchState;\n    if (searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const searchString = searchState.searchString;\n    vimState.statusBarCursorCharacterPos =\n      getWordLeftInText(searchString, vimState.statusBarCursorCharacterPos, WordType.Big) ?? 0;\n  }\n}\n\n@RegisterAction\nclass WordRightInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = ['<C-right>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const searchState = globalState.searchState;\n    if (searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const searchString = searchState.searchString;\n    vimState.statusBarCursorCharacterPos =\n      getWordRightInText(searchString, vimState.statusBarCursorCharacterPos, WordType.Big) ??\n      searchString.length;\n  }\n}\n\n@RegisterAction\n// TODO: break up\nclass CommandInsertInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [\n    ['<character>'],\n    ['<up>'],\n    ['<down>'],\n    ['<C-b>'], // Beginning\n    ['<C-e>'], // End\n    ['<C-h>'], // Backspace\n    ['<C-p>'], // Previous\n    ['<C-n>'], // Next\n    ['<C-f>'], // Find\n    ['<C-u>'], // Delete to beginning\n    ['<Home>'],\n    ['<End>'],\n    ['<Del>'],\n  ];\n  runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n\n    // handle special keys first\n    if (key === '<BS>' || key === '<S-BS>' || key === '<C-h>') {\n      if (vimState.statusBarCursorCharacterPos === 0) {\n        await vimState.setCurrentMode(Mode.Normal);\n        return;\n      }\n\n      vimState.currentCommandlineText =\n        vimState.currentCommandlineText.slice(0, vimState.statusBarCursorCharacterPos - 1) +\n        vimState.currentCommandlineText.slice(vimState.statusBarCursorCharacterPos);\n      vimState.statusBarCursorCharacterPos = Math.max(vimState.statusBarCursorCharacterPos - 1, 0);\n    } else if (key === '<C-f>') {\n      new CommandShowCommandHistory().exec(position, vimState);\n    } else if (key === '<C-u>') {\n      vimState.currentCommandlineText = vimState.currentCommandlineText.slice(\n        vimState.statusBarCursorCharacterPos\n      );\n      vimState.statusBarCursorCharacterPos = 0;\n    } else if (key === '<Del>') {\n      vimState.currentCommandlineText =\n        vimState.currentCommandlineText.slice(0, vimState.statusBarCursorCharacterPos) +\n        vimState.currentCommandlineText.slice(vimState.statusBarCursorCharacterPos + 1);\n    } else if (key === '<Home>' || key === '<C-b>') {\n      vimState.statusBarCursorCharacterPos = 0;\n    } else if (key === '<End>' || key === '<C-e>') {\n      vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n    } else if (key === '<up>' || key === '<C-p>') {\n      commandLine.commandLineHistoryIndex -= 1;\n\n      // Clamp the history index to stay within bounds of command history length\n      commandLine.commandLineHistoryIndex = Math.max(commandLine.commandLineHistoryIndex, 0);\n\n      if (commandLine.historyEntries[commandLine.commandLineHistoryIndex] !== undefined) {\n        vimState.currentCommandlineText =\n          commandLine.historyEntries[commandLine.commandLineHistoryIndex];\n      }\n      vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n    } else if (key === '<down>' || key === '<C-n>') {\n      commandLine.commandLineHistoryIndex += 1;\n\n      // If past the first history item, allow user to enter their own new command string (not using history)\n      if (commandLine.commandLineHistoryIndex > commandLine.historyEntries.length - 1) {\n        if (commandLine.previousMode === Mode.Normal) {\n          vimState.currentCommandlineText = '';\n        } else {\n          vimState.currentCommandlineText = \"'<,'>\";\n        }\n\n        commandLine.commandLineHistoryIndex = commandLine.historyEntries.length;\n        vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n        return;\n      }\n\n      if (commandLine.historyEntries[commandLine.commandLineHistoryIndex] !== undefined) {\n        vimState.currentCommandlineText =\n          commandLine.historyEntries[commandLine.commandLineHistoryIndex];\n      }\n\n      vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n    } else {\n      const modifiedString = vimState.currentCommandlineText.split('');\n      modifiedString.splice(vimState.statusBarCursorCharacterPos, 0, key);\n      vimState.currentCommandlineText = modifiedString.join('');\n      vimState.statusBarCursorCharacterPos += key.length;\n    }\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\n// TODO: break up\nclass CommandInsertInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = [\n    ['<character>'],\n    ['<up>'],\n    ['<down>'],\n    ['<C-b>'], // Beginning\n    ['<C-e>'], // End\n    ['<C-h>'], // Backspace\n    ['<C-p>'], // Previous\n    ['<C-n>'], // Next\n    ['<C-f>'], // Find\n    ['<C-u>'], // Delete to beginning\n    ['<C-m>'], // Another way to run search\n    ['<Home>'],\n    ['<End>'],\n    ['<Del>'],\n  ];\n  isJump = true;\n\n  runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const searchState = globalState.searchState;\n    const key = this.keysPressed[0];\n    const prevSearchList = globalState.searchStatePrevious;\n\n    // handle special keys first\n    if (key === '<BS>' || key === '<S-BS>' || key === '<C-h>') {\n      if (searchState.searchString.length === 0) {\n        await new CommandEscInSearchMode().exec(position, vimState);\n      }\n      if (vimState.statusBarCursorCharacterPos === 0) {\n        return;\n      }\n\n      searchState.searchString =\n        searchState.searchString.slice(0, vimState.statusBarCursorCharacterPos - 1) +\n        searchState.searchString.slice(vimState.statusBarCursorCharacterPos);\n      vimState.statusBarCursorCharacterPos = Math.max(vimState.statusBarCursorCharacterPos - 1, 0);\n    } else if (key === '<C-f>') {\n      await new CommandShowSearchHistory(searchState.searchDirection).exec(position, vimState);\n    } else if (key === '<C-u>') {\n      searchState.searchString = searchState.searchString.slice(\n        vimState.statusBarCursorCharacterPos\n      );\n      vimState.statusBarCursorCharacterPos = 0;\n    } else if (key === '<Del>') {\n      searchState.searchString =\n        searchState.searchString.slice(0, vimState.statusBarCursorCharacterPos) +\n        searchState.searchString.slice(vimState.statusBarCursorCharacterPos + 1);\n    } else if (key === '<Home>' || key === '<C-b>') {\n      vimState.statusBarCursorCharacterPos = 0;\n    } else if (key === '<End>' || key === '<C-e>') {\n      vimState.statusBarCursorCharacterPos = searchState.searchString.length;\n    } else if (key === '\\n' || key === '<C-m>') {\n      await vimState.setCurrentMode(searchState.previousMode);\n\n      // Repeat the previous search if no new string is entered\n      if (searchState.searchString === '') {\n        if (prevSearchList.length > 0) {\n          searchState.searchString = prevSearchList[prevSearchList.length - 1].searchString;\n        }\n      }\n\n      vimState.statusBarCursorCharacterPos = 0;\n      Register.putByKey(searchState.searchString, '/', undefined, true);\n      globalState.addSearchStateToHistory(searchState);\n      globalState.hl = true;\n\n      if (searchState.getMatchRanges(vimState.editor).length === 0) {\n        StatusBar.displayError(\n          vimState,\n          VimError.fromCode(ErrorCode.PatternNotFound, searchState.searchString)\n        );\n        return;\n      }\n\n      const count = vimState.recordedState.count || 1;\n      let searchPos = vimState.cursorStopPosition;\n      let nextMatch: { pos: Position; match: boolean; index: number } | undefined;\n      for (let i = 0; i < count; i++) {\n        // Move cursor to next match\n        nextMatch = searchState.getNextSearchMatchPosition(vimState.editor, searchPos);\n        if (nextMatch === undefined) {\n          break;\n        }\n        searchPos = nextMatch.pos;\n      }\n      if (nextMatch === undefined) {\n        StatusBar.displayError(\n          vimState,\n          VimError.fromCode(\n            searchState.searchDirection === SearchDirection.Backward\n              ? ErrorCode.SearchHitTop\n              : ErrorCode.SearchHitBottom,\n            searchState.searchString\n          )\n        );\n        return;\n      }\n\n      vimState.cursorStopPosition = nextMatch.pos;\n\n      reportSearch(nextMatch.index, searchState.getMatchRanges(vimState.editor).length, vimState);\n\n      return;\n    } else if (key === '<up>' || key === '<C-p>') {\n      globalState.searchStateIndex -= 1;\n\n      // Clamp the history index to stay within bounds of search history length\n      globalState.searchStateIndex = Math.max(globalState.searchStateIndex, 0);\n\n      if (prevSearchList[globalState.searchStateIndex] !== undefined) {\n        searchState.searchString = prevSearchList[globalState.searchStateIndex].searchString;\n        vimState.statusBarCursorCharacterPos = searchState.searchString.length;\n      }\n    } else if (key === '<down>' || key === '<C-n>') {\n      globalState.searchStateIndex += 1;\n\n      // If past the first history item, allow user to enter their own search string (not using history)\n      if (globalState.searchStateIndex > globalState.searchStatePrevious.length - 1) {\n        searchState.searchString = '';\n        globalState.searchStateIndex = globalState.searchStatePrevious.length;\n        return;\n      }\n\n      if (prevSearchList[globalState.searchStateIndex] !== undefined) {\n        searchState.searchString = prevSearchList[globalState.searchStateIndex].searchString;\n      }\n      vimState.statusBarCursorCharacterPos = searchState.searchString.length;\n    } else {\n      const modifiedString = searchState.searchString.split('');\n      modifiedString.splice(vimState.statusBarCursorCharacterPos, 0, key);\n      searchState.searchString = modifiedString.join('');\n      vimState.statusBarCursorCharacterPos += key.length;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandEscInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n  runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n\n    await vimState.setCurrentMode(Mode.Normal);\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandEscInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n  runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const searchState = globalState.searchState;\n    if (searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    vimState.cursorStopPosition = searchState.cursorStartPosition;\n\n    const prevSearchList = globalState.searchStatePrevious;\n    globalState.searchState = prevSearchList\n      ? prevSearchList[prevSearchList.length - 1]\n      : undefined;\n\n    if (vimState.firstVisibleLineBeforeSearch !== undefined) {\n      const offset =\n        vimState.editor.visibleRanges[0].start.line - vimState.firstVisibleLineBeforeSearch;\n      scrollView(vimState, offset);\n    }\n\n    await vimState.setCurrentMode(searchState.previousMode);\n    vimState.statusBarCursorCharacterPos = 0;\n    if (searchState.searchString.length > 0) {\n      globalState.addSearchStateToHistory(searchState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandInsertRegisterContentInCommandLine extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = ['<C-r>', '<character>'];\n  isCompleteAction = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.registerName = this.keysPressed[1];\n    const register = await Register.get(vimState);\n    if (register === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister));\n      return;\n    }\n\n    let text: string;\n    if (register.text instanceof Array) {\n      text = register.text.join('\\n');\n    } else if (register.text instanceof RecordedState) {\n      let keyStrokes: string[] = [];\n\n      for (const action of register.text.actionsRun) {\n        keyStrokes = keyStrokes.concat(action.keysPressed);\n      }\n\n      text = keyStrokes.join('\\n');\n    } else {\n      text = register.text;\n    }\n\n    if (register.registerMode === RegisterMode.LineWise) {\n      text += '\\n';\n    }\n\n    vimState.currentCommandlineText += text;\n    vimState.statusBarCursorCharacterPos += text.length;\n  }\n}\n\n@RegisterAction\nclass CommandInsertRegisterContentInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = ['<C-r>', '<character>'];\n  isCompleteAction = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    vimState.recordedState.registerName = this.keysPressed[1];\n    const register = await Register.get(vimState);\n    if (register === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister));\n      return;\n    }\n\n    let text: string;\n    if (register.text instanceof Array) {\n      text = register.text.join('\\n');\n    } else if (register.text instanceof RecordedState) {\n      let keyStrokes: string[] = [];\n\n      for (const action of register.text.actionsRun) {\n        keyStrokes = keyStrokes.concat(action.keysPressed);\n      }\n\n      text = keyStrokes.join('\\n');\n    } else {\n      text = register.text;\n    }\n\n    if (register.registerMode === RegisterMode.LineWise) {\n      text += '\\n';\n    }\n\n    globalState.searchState.searchString += text;\n    vimState.statusBarCursorCharacterPos += text.length;\n  }\n}\n\n@RegisterAction\nclass CommandInsertWord extends BaseCommand {\n  modes = [Mode.CommandlineInProgress, Mode.SearchInProgressMode];\n  keys = ['<C-r>', '<C-w>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const word = TextEditor.getWord(vimState.document, position.getLeftIfEOL());\n\n    if (word !== undefined) {\n      if (vimState.currentMode === Mode.SearchInProgressMode) {\n        globalState.searchState.searchString += word;\n      } else {\n        vimState.currentCommandlineText += word;\n      }\n\n      vimState.statusBarCursorCharacterPos += word.length;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandNavigateInCommandlineOrSearchMode extends BaseCommand {\n  modes = [Mode.CommandlineInProgress, Mode.SearchInProgressMode];\n  keys = [['<left>'], ['<right>']];\n  runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  private getTrimmedStatusBarText() {\n    // first regex removes the : / and | from the string\n    // second regex removes a single space from the end of the string\n    const trimmedStatusBarText = StatusBar.getText()\n      .replace(/^(?:\\/|\\:)(.*)(?:\\|)(.*)/, '$1$2')\n      .replace(/(.*) $/, '$1');\n    return trimmedStatusBarText;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const statusBarText = this.getTrimmedStatusBarText();\n    if (key === '<right>') {\n      vimState.statusBarCursorCharacterPos = Math.min(\n        vimState.statusBarCursorCharacterPos + 1,\n        statusBarText.length\n      );\n    } else if (key === '<left>') {\n      vimState.statusBarCursorCharacterPos = Math.max(vimState.statusBarCursorCharacterPos - 1, 0);\n    }\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandPasteInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['<C-v>'], ['<D-v>']];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const pos = vimState.statusBarCursorCharacterPos;\n    const cmdText = vimState.currentCommandlineText;\n    const textFromClipboard = await Clipboard.Paste();\n\n    vimState.currentCommandlineText = cmdText\n      .substring(0, pos)\n      .concat(textFromClipboard)\n      .concat(cmdText.slice(pos));\n    vimState.statusBarCursorCharacterPos += textFromClipboard.length;\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandPasteInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = [['<C-v>'], ['<D-v>']];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n    const searchString = globalState.searchState.searchString;\n    const pos = vimState.statusBarCursorCharacterPos;\n    const textFromClipboard = await Clipboard.Paste();\n\n    globalState.searchState.searchString = searchString\n      .substring(0, pos)\n      .concat(textFromClipboard)\n      .concat(searchString.slice(pos));\n    vimState.statusBarCursorCharacterPos += textFromClipboard.length;\n  }\n}\n\n@RegisterAction\nclass CommandCtrlLInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = ['<C-l>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const nextMatch = globalState.searchState.getNextSearchMatchRange(vimState.editor, position);\n    if (nextMatch?.match) {\n      const line = vimState.document.lineAt(nextMatch.end).text;\n      if (nextMatch.end.character < line.length) {\n        globalState.searchState.searchString += line[nextMatch.end.character];\n        vimState.statusBarCursorCharacterPos++;\n      }\n    }\n  }\n}\n","// prettier-ignore\nexport const DefaultDigraphs = {\n  \"SH\": [\"^A\", 1],\n  \"SX\": [\"^B\", 2],\n  \"EX\": [\"^C\", 3],\n  \"ET\": [\"^D\", 4],\n  \"EQ\": [\"^E\", 5],\n  \"AK\": [\"^F\", 6],\n  \"BL\": [\"^G\", 7],\n  \"BS\": [\"^H\", 8],\n  \"HT\": [\"^I\", 9],\n  \"LF\": [\"^@\", 10],\n  \"NU\": [\"^@\", 10],\n  \"VT\": [\"^K\", 11],\n  \"FF\": [\"^L\", 12],\n  \"CR\": [\"^M\", 13],\n  \"SO\": [\"^N\", 14],\n  \"SI\": [\"^O\", 15],\n  \"DL\": [\"^P\", 16],\n  \"D1\": [\"^Q\", 17],\n  \"D2\": [\"^R\", 18],\n  \"D3\": [\"^S\", 19],\n  \"D4\": [\"^T\", 20],\n  \"NK\": [\"^U\", 21],\n  \"SY\": [\"^V\", 22],\n  \"EB\": [\"^W\", 23],\n  \"CN\": [\"^X\", 24],\n  \"EM\": [\"^Y\", 25],\n  \"SB\": [\"^Z\", 26],\n  \"EC\": [\"^[\", 27],\n  \"FS\": [\"^\\\\\", 28],\n  \"GS\": [\"^]\", 29],\n  \"RS\": [\"^^\", 30],\n  \"US\": [\"^_\", 31],\n  \"SP\": [\" \", 32],\n  \"Nb\": [\"#\", 35],\n  \"DO\": [\"$\", 36],\n  \"At\": [\"@\", 64],\n  \"<(\": [\"[\", 91],\n  \"//\": [\"\\\\\", 92],\n  \")>\": [\"]\", 93],\n  \"'>\": [\"^\", 94],\n  \"'!\": [\"`\", 96],\n  \"(!\": [\"{\", 123],\n  \"!!\": [\"|\", 124],\n  \"!)\": [\"}\", 125],\n  \"'?\": [\"~\", 126],\n  \"DT\": [\"^?\", 127],\n  \"PA\": [\"<80>\", 128],\n  \"HO\": [\"<81>\", 129],\n  \"BH\": [\"<82>\", 130],\n  \"NH\": [\"<83>\", 131],\n  \"IN\": [\"<84>\", 132],\n  \"NL\": [\"<85>\", 133],\n  \"SA\": [\"<86>\", 134],\n  \"ES\": [\"<87>\", 135],\n  \"HS\": [\"<88>\", 136],\n  \"HJ\": [\"<89>\", 137],\n  \"VS\": [\"<8a>\", 138],\n  \"PD\": [\"<8b>\", 139],\n  \"PU\": [\"<8c>\", 140],\n  \"RI\": [\"<8d>\", 141],\n  \"S2\": [\"<8e>\", 142],\n  \"S3\": [\"<8f>\", 143],\n  \"DC\": [\"<90>\", 144],\n  \"P1\": [\"<91>\", 145],\n  \"P2\": [\"<92>\", 146],\n  \"TS\": [\"<93>\", 147],\n  \"CC\": [\"<94>\", 148],\n  \"MW\": [\"<95>\", 149],\n  \"SG\": [\"<96>\", 150],\n  \"EG\": [\"<97>\", 151],\n  \"SS\": [\"<98>\", 152],\n  \"GC\": [\"<99>\", 153],\n  \"SC\": [\"<9a>\", 154],\n  \"CI\": [\"<9b>\", 155],\n  \"ST\": [\"<9c>\", 156],\n  \"OC\": [\"<9d>\", 157],\n  \"PM\": [\"<9e>\", 158],\n  \"AC\": [\"<9f>\", 159],\n  \"NS\": [\"\", 160],\n  \"~!\": [\"\", 161],\n  \"!I\": [\"\", 161],\n  \"Ct\": [\"\", 162],\n  \"c|\": [\"\", 162],\n  \"Pd\": [\"\", 163],\n  \"$$\": [\"\", 163],\n  \"Cu\": [\"\", 164],\n  \"ox\": [\"\", 164],\n  \"Ye\": [\"\", 165],\n  \"Y-\": [\"\", 165],\n  \"BB\": [\"\", 166],\n  \"||\": [\"\", 166],\n  \"SE\": [\"\", 167],\n  \"':\": [\"\", 168],\n  \"Co\": [\"\", 169],\n  \"cO\": [\"\", 169],\n  \"-a\": [\"\", 170],\n  \"<<\": [\"\", 171],\n  \"NO\": [\"\", 172],\n  \"-,\": [\"\", 172],\n  \"--\": [\"\", 173],\n  \"Rg\": [\"\", 174],\n  \"'m\": [\"\", 175],\n  \"-=\": [\"\", 175],\n  \"DG\": [\"\", 176],\n  \"~o\": [\"\", 176],\n  \"+-\": [\"\", 177],\n  \"2S\": [\"\", 178],\n  \"22\": [\"\", 178],\n  \"3S\": [\"\", 179],\n  \"33\": [\"\", 179],\n  \"''\": [\"\", 180],\n  \"My\": [\"\", 181],\n  \"PI\": [\"\", 182],\n  \"pp\": [\"\", 182],\n  \".M\": [\"\", 183],\n  \"~.\": [\"\", 183],\n  \"',\": [\"\", 184],\n  \"1S\": [\"\", 185],\n  \"11\": [\"\", 185],\n  \"-o\": [\"\", 186],\n  \">>\": [\"\", 187],\n  \"14\": [\"\", 188],\n  \"12\": [\"\", 189],\n  \"34\": [\"\", 190],\n  \"?I\": [\"\", 191],\n  \"~?\": [\"\", 191],\n  \"A!\": [\"\", 192],\n  \"A`\": [\"\", 192],\n  \"A'\": [\"\", 193],\n  \"A>\": [\"\", 194],\n  \"A^\": [\"\", 194],\n  \"A?\": [\"\", 195],\n  \"A~\": [\"\", 195],\n  \"A:\": [\"\", 196],\n  \"A\\\"\": [\"\", 196],\n  \"AA\": [\"\", 197],\n  \"A@\": [\"\", 197],\n  \"AE\": [\"\", 198],\n  \"C,\": [\"\", 199],\n  \"E!\": [\"\", 200],\n  \"E`\": [\"\", 200],\n  \"E'\": [\"\", 201],\n  \"E>\": [\"\", 202],\n  \"E^\": [\"\", 202],\n  \"E:\": [\"\", 203],\n  \"E\\\"\": [\"\", 203],\n  \"I!\": [\"\", 204],\n  \"I`\": [\"\", 204],\n  \"I'\": [\"\", 205],\n  \"I>\": [\"\", 206],\n  \"I^\": [\"\", 206],\n  \"I:\": [\"\", 207],\n  \"I\\\"\": [\"\", 207],\n  \"D-\": [\"\", 208],\n  \"N?\": [\"\", 209],\n  \"N~\": [\"\", 209],\n  \"O!\": [\"\", 210],\n  \"O`\": [\"\", 210],\n  \"O'\": [\"\", 211],\n  \"O>\": [\"\", 212],\n  \"O^\": [\"\", 212],\n  \"O?\": [\"\", 213],\n  \"O~\": [\"\", 213],\n  \"O:\": [\"\", 214],\n  \"*X\": [\"\", 215],\n  \"/\\\\\": [\"\", 215],\n  \"O/\": [\"\", 216],\n  \"U!\": [\"\", 217],\n  \"U`\": [\"\", 217],\n  \"U'\": [\"\", 218],\n  \"U>\": [\"\", 219],\n  \"U^\": [\"\", 219],\n  \"U:\": [\"\", 220],\n  \"Y'\": [\"\", 221],\n  \"TH\": [\"\", 222],\n  \"Ip\": [\"\", 222],\n  \"ss\": [\"\", 223],\n  \"a!\": [\"\", 224],\n  \"a`\": [\"\", 224],\n  \"a'\": [\"\", 225],\n  \"a>\": [\"\", 226],\n  \"a^\": [\"\", 226],\n  \"a?\": [\"\", 227],\n  \"a~\": [\"\", 227],\n  \"a:\": [\"\", 228],\n  \"a\\\"\": [\"\", 228],\n  \"aa\": [\"\", 229],\n  \"a@\": [\"\", 229],\n  \"ae\": [\"\", 230],\n  \"c,\": [\"\", 231],\n  \"e!\": [\"\", 232],\n  \"e`\": [\"\", 232],\n  \"e'\": [\"\", 233],\n  \"e>\": [\"\", 234],\n  \"e^\": [\"\", 234],\n  \"e:\": [\"\", 235],\n  \"e\\\"\": [\"\", 235],\n  \"i!\": [\"\", 236],\n  \"i`\": [\"\", 236],\n  \"i'\": [\"\", 237],\n  \"i>\": [\"\", 238],\n  \"i^\": [\"\", 238],\n  \"i:\": [\"\", 239],\n  \"d-\": [\"\", 240],\n  \"n?\": [\"\", 241],\n  \"n~\": [\"\", 241],\n  \"o!\": [\"\", 242],\n  \"o`\": [\"\", 242],\n  \"o'\": [\"\", 243],\n  \"o>\": [\"\", 244],\n  \"o^\": [\"\", 244],\n  \"o?\": [\"\", 245],\n  \"o~\": [\"\", 245],\n  \"o:\": [\"\", 246],\n  \"-:\": [\"\", 247],\n  \"o/\": [\"\", 248],\n  \"u!\": [\"\", 249],\n  \"u`\": [\"\", 249],\n  \"u'\": [\"\", 250],\n  \"u>\": [\"\", 251],\n  \"u^\": [\"\", 251],\n  \"u:\": [\"\", 252],\n  \"y'\": [\"\", 253],\n  \"th\": [\"\", 254],\n  \"y:\": [\"\", 255],\n  \"y\\\"\": [\"\", 255],\n  \"A-\": [\"\", 256],\n  \"a-\": [\"\", 257],\n  \"A(\": [\"\", 258],\n  \"a(\": [\"\", 259],\n  \"A;\": [\"\", 260],\n  \"a;\": [\"\", 261],\n  \"C'\": [\"\", 262],\n  \"c'\": [\"\", 263],\n  \"C>\": [\"\", 264],\n  \"c>\": [\"\", 265],\n  \"C.\": [\"\", 266],\n  \"c.\": [\"\", 267],\n  \"C<\": [\"\", 268],\n  \"c<\": [\"\", 269],\n  \"D<\": [\"\", 270],\n  \"d<\": [\"\", 271],\n  \"D/\": [\"\", 272],\n  \"d/\": [\"\", 273],\n  \"E-\": [\"\", 274],\n  \"e-\": [\"\", 275],\n  \"E(\": [\"\", 276],\n  \"e(\": [\"\", 277],\n  \"E.\": [\"\", 278],\n  \"e.\": [\"\", 279],\n  \"E;\": [\"\", 280],\n  \"e;\": [\"\", 281],\n  \"E<\": [\"\", 282],\n  \"e<\": [\"\", 283],\n  \"G>\": [\"\", 284],\n  \"g>\": [\"\", 285],\n  \"G(\": [\"\", 286],\n  \"g(\": [\"\", 287],\n  \"G.\": [\"\", 288],\n  \"g.\": [\"\", 289],\n  \"G,\": [\"\", 290],\n  \"g,\": [\"\", 291],\n  \"H>\": [\"\", 292],\n  \"h>\": [\"\", 293],\n  \"H/\": [\"\", 294],\n  \"h/\": [\"\", 295],\n  \"I?\": [\"\", 296],\n  \"i?\": [\"\", 297],\n  \"I-\": [\"\", 298],\n  \"i-\": [\"\", 299],\n  \"I(\": [\"\", 300],\n  \"i(\": [\"\", 301],\n  \"I;\": [\"\", 302],\n  \"i;\": [\"\", 303],\n  \"I.\": [\"\", 304],\n  \"i.\": [\"\", 305],\n  \"IJ\": [\"\", 306],\n  \"ij\": [\"\", 307],\n  \"J>\": [\"\", 308],\n  \"j>\": [\"\", 309],\n  \"K,\": [\"\", 310],\n  \"k,\": [\"\", 311],\n  \"kk\": [\"\", 312],\n  \"L'\": [\"\", 313],\n  \"l'\": [\"\", 314],\n  \"L,\": [\"\", 315],\n  \"l,\": [\"\", 316],\n  \"L<\": [\"\", 317],\n  \"l<\": [\"\", 318],\n  \"L.\": [\"\", 319],\n  \"l.\": [\"\", 320],\n  \"L/\": [\"\", 321],\n  \"l/\": [\"\", 322],\n  \"N'\": [\"\", 323],\n  \"n'\": [\"\", 324],\n  \"N,\": [\"\", 325],\n  \"n,\": [\"\", 326],\n  \"N<\": [\"\", 327],\n  \"n<\": [\"\", 328],\n  \"'n\": [\"\", 329],\n  \"NG\": [\"\", 330],\n  \"ng\": [\"\", 331],\n  \"O-\": [\"\", 332],\n  \"o-\": [\"\", 333],\n  \"O(\": [\"\", 334],\n  \"o(\": [\"\", 335],\n  \"O\\\"\": [\"\", 336],\n  \"o\\\"\": [\"\", 337],\n  \"OE\": [\"\", 338],\n  \"oe\": [\"\", 339],\n  \"R'\": [\"\", 340],\n  \"r'\": [\"\", 341],\n  \"R,\": [\"\", 342],\n  \"r,\": [\"\", 343],\n  \"R<\": [\"\", 344],\n  \"r<\": [\"\", 345],\n  \"S'\": [\"\", 346],\n  \"s'\": [\"\", 347],\n  \"S>\": [\"\", 348],\n  \"s>\": [\"\", 349],\n  \"S,\": [\"\", 350],\n  \"s,\": [\"\", 351],\n  \"S<\": [\"\", 352],\n  \"s<\": [\"\", 353],\n  \"T,\": [\"\", 354],\n  \"t,\": [\"\", 355],\n  \"T<\": [\"\", 356],\n  \"t<\": [\"\", 357],\n  \"T/\": [\"\", 358],\n  \"t/\": [\"\", 359],\n  \"U?\": [\"\", 360],\n  \"u?\": [\"\", 361],\n  \"U-\": [\"\", 362],\n  \"u-\": [\"\", 363],\n  \"U(\": [\"\", 364],\n  \"u(\": [\"\", 365],\n  \"U0\": [\"\", 366],\n  \"u0\": [\"\", 367],\n  \"U\\\"\": [\"\", 368],\n  \"u\\\"\": [\"\", 369],\n  \"U;\": [\"\", 370],\n  \"u;\": [\"\", 371],\n  \"W>\": [\"\", 372],\n  \"w>\": [\"\", 373],\n  \"Y>\": [\"\", 374],\n  \"y>\": [\"\", 375],\n  \"Y:\": [\"\", 376],\n  \"Z'\": [\"\", 377],\n  \"z'\": [\"\", 378],\n  \"Z.\": [\"\", 379],\n  \"z.\": [\"\", 380],\n  \"Z<\": [\"\", 381],\n  \"z<\": [\"\", 382],\n  \"fs\": [\"\", 383],\n  \"O9\": [\"\", 416],\n  \"o9\": [\"\", 417],\n  \"OI\": [\"\", 418],\n  \"oi\": [\"\", 419],\n  \"yr\": [\"\", 422],\n  \"U9\": [\"\", 431],\n  \"u9\": [\"\", 432],\n  \"Z/\": [\"\", 437],\n  \"z/\": [\"\", 438],\n  \"ED\": [\"\", 439],\n  \"A<\": [\"\", 461],\n  \"a<\": [\"\", 462],\n  \"I<\": [\"\", 463],\n  \"i<\": [\"\", 464],\n  \"O<\": [\"\", 465],\n  \"o<\": [\"\", 466],\n  \"U<\": [\"\", 467],\n  \"u<\": [\"\", 468],\n  \"A1\": [\"\", 478],\n  \"a1\": [\"\", 479],\n  \"A7\": [\"\", 480],\n  \"a7\": [\"\", 481],\n  \"A3\": [\"\", 482],\n  \"a3\": [\"\", 483],\n  \"G/\": [\"\", 484],\n  \"g/\": [\"\", 485],\n  \"G<\": [\"\", 486],\n  \"g<\": [\"\", 487],\n  \"K<\": [\"\", 488],\n  \"k<\": [\"\", 489],\n  \"O;\": [\"\", 490],\n  \"o;\": [\"\", 491],\n  \"O1\": [\"\", 492],\n  \"o1\": [\"\", 493],\n  \"EZ\": [\"\", 494],\n  \"ez\": [\"\", 495],\n  \"j<\": [\"\", 496],\n  \"G'\": [\"\", 500],\n  \"g'\": [\"\", 501],\n  \";S\": [\"\", 703],\n  \"'<\": [\"\", 711],\n  \"'(\": [\"\", 728],\n  \"'.\": [\"\", 729],\n  \"'0\": [\"\", 730],\n  \"';\": [\"\", 731],\n  \"'\\\"\": [\"\", 733],\n  \"A%\": [\"\", 902],\n  \"E%\": [\"\", 904],\n  \"Y%\": [\"\", 905],\n  \"I%\": [\"\", 906],\n  \"O%\": [\"\", 908],\n  \"U%\": [\"\", 910],\n  \"W%\": [\"\", 911],\n  \"i3\": [\"\", 912],\n  \"A*\": [\"\", 913],\n  \"B*\": [\"\", 914],\n  \"G*\": [\"\", 915],\n  \"D*\": [\"\", 916],\n  \"E*\": [\"\", 917],\n  \"Z*\": [\"\", 918],\n  \"Y*\": [\"\", 919],\n  \"H*\": [\"\", 920],\n  \"I*\": [\"\", 921],\n  \"K*\": [\"\", 922],\n  \"L*\": [\"\", 923],\n  \"M*\": [\"\", 924],\n  \"N*\": [\"\", 925],\n  \"C*\": [\"\", 926],\n  \"O*\": [\"\", 927],\n  \"P*\": [\"\", 928],\n  \"R*\": [\"\", 929],\n  \"S*\": [\"\", 931],\n  \"T*\": [\"\", 932],\n  \"U*\": [\"\", 933],\n  \"F*\": [\"\", 934],\n  \"X*\": [\"\", 935],\n  \"Q*\": [\"\", 936],\n  \"W*\": [\"\", 937],\n  \"J*\": [\"\", 938],\n  \"V*\": [\"\", 939],\n  \"a%\": [\"\", 940],\n  \"e%\": [\"\", 941],\n  \"y%\": [\"\", 942],\n  \"i%\": [\"\", 943],\n  \"u3\": [\"\", 944],\n  \"a*\": [\"\", 945],\n  \"b*\": [\"\", 946],\n  \"g*\": [\"\", 947],\n  \"d*\": [\"\", 948],\n  \"e*\": [\"\", 949],\n  \"z*\": [\"\", 950],\n  \"y*\": [\"\", 951],\n  \"h*\": [\"\", 952],\n  \"i*\": [\"\", 953],\n  \"k*\": [\"\", 954],\n  \"l*\": [\"\", 955],\n  \"m*\": [\"\", 956],\n  \"n*\": [\"\", 957],\n  \"c*\": [\"\", 958],\n  \"o*\": [\"\", 959],\n  \"p*\": [\"\", 960],\n  \"r*\": [\"\", 961],\n  \"*s\": [\"\", 962],\n  \"s*\": [\"\", 963],\n  \"t*\": [\"\", 964],\n  \"u*\": [\"\", 965],\n  \"f*\": [\"\", 966],\n  \"x*\": [\"\", 967],\n  \"q*\": [\"\", 968],\n  \"w*\": [\"\", 969],\n  \"j*\": [\"\", 970],\n  \"v*\": [\"\", 971],\n  \"o%\": [\"\", 972],\n  \"u%\": [\"\", 973],\n  \"w%\": [\"\", 974],\n  \"'G\": [\"\", 984],\n  \",G\": [\"\", 985],\n  \"T3\": [\"\", 986],\n  \"t3\": [\"\", 987],\n  \"M3\": [\"\", 988],\n  \"m3\": [\"\", 989],\n  \"K3\": [\"\", 990],\n  \"k3\": [\"\", 991],\n  \"P3\": [\"\", 992],\n  \"p3\": [\"\", 993],\n  \"'%\": [\"\", 1012],\n  \"j3\": [\"\", 1013],\n  \"IO\": [\"\", 1025],\n  \"D%\": [\"\", 1026],\n  \"G%\": [\"\", 1027],\n  \"IE\": [\"\", 1028],\n  \"DS\": [\"\", 1029],\n  \"II\": [\"\", 1030],\n  \"YI\": [\"\", 1031],\n  \"J%\": [\"\", 1032],\n  \"LJ\": [\"\", 1033],\n  \"NJ\": [\"\", 1034],\n  \"Ts\": [\"\", 1035],\n  \"KJ\": [\"\", 1036],\n  \"V%\": [\"\", 1038],\n  \"DZ\": [\"\", 1039],\n  \"A=\": [\"\", 1040],\n  \"B=\": [\"\", 1041],\n  \"V=\": [\"\", 1042],\n  \"G=\": [\"\", 1043],\n  \"D=\": [\"\", 1044],\n  \"E=\": [\"\", 1045],\n  \"Z%\": [\"\", 1046],\n  \"Z=\": [\"\", 1047],\n  \"I=\": [\"\", 1048],\n  \"J=\": [\"\", 1049],\n  \"K=\": [\"\", 1050],\n  \"L=\": [\"\", 1051],\n  \"M=\": [\"\", 1052],\n  \"N=\": [\"\", 1053],\n  \"O=\": [\"\", 1054],\n  \"P=\": [\"\", 1055],\n  \"R=\": [\"\", 1056],\n  \"S=\": [\"\", 1057],\n  \"T=\": [\"\", 1058],\n  \"U=\": [\"\", 1059],\n  \"F=\": [\"\", 1060],\n  \"H=\": [\"\", 1061],\n  \"C=\": [\"\", 1062],\n  \"C%\": [\"\", 1063],\n  \"S%\": [\"\", 1064],\n  \"Sc\": [\"\", 1065],\n  \"=\\\"\": [\"\", 1066],\n  \"Y=\": [\"\", 1067],\n  \"%\\\"\": [\"\", 1068],\n  \"JE\": [\"\", 1069],\n  \"JU\": [\"\", 1070],\n  \"JA\": [\"\", 1071],\n  \"a=\": [\"\", 1072],\n  \"b=\": [\"\", 1073],\n  \"v=\": [\"\", 1074],\n  \"g=\": [\"\", 1075],\n  \"d=\": [\"\", 1076],\n  \"e=\": [\"\", 1077],\n  \"z%\": [\"\", 1078],\n  \"z=\": [\"\", 1079],\n  \"i=\": [\"\", 1080],\n  \"j=\": [\"\", 1081],\n  \"k=\": [\"\", 1082],\n  \"l=\": [\"\", 1083],\n  \"m=\": [\"\", 1084],\n  \"n=\": [\"\", 1085],\n  \"o=\": [\"\", 1086],\n  \"p=\": [\"\", 1087],\n  \"r=\": [\"\", 1088],\n  \"s=\": [\"\", 1089],\n  \"t=\": [\"\", 1090],\n  \"u=\": [\"\", 1091],\n  \"f=\": [\"\", 1092],\n  \"h=\": [\"\", 1093],\n  \"c=\": [\"\", 1094],\n  \"c%\": [\"\", 1095],\n  \"s%\": [\"\", 1096],\n  \"sc\": [\"\", 1097],\n  \"='\": [\"\", 1098],\n  \"y=\": [\"\", 1099],\n  \"%'\": [\"\", 1100],\n  \"je\": [\"\", 1101],\n  \"ju\": [\"\", 1102],\n  \"ja\": [\"\", 1103],\n  \"io\": [\"\", 1105],\n  \"d%\": [\"\", 1106],\n  \"g%\": [\"\", 1107],\n  \"ie\": [\"\", 1108],\n  \"ds\": [\"\", 1109],\n  \"ii\": [\"\", 1110],\n  \"yi\": [\"\", 1111],\n  \"j%\": [\"\", 1112],\n  \"lj\": [\"\", 1113],\n  \"nj\": [\"\", 1114],\n  \"ts\": [\"\", 1115],\n  \"kj\": [\"\", 1116],\n  \"v%\": [\"\", 1118],\n  \"dz\": [\"\", 1119],\n  \"Y3\": [\"\", 1122],\n  \"y3\": [\"\", 1123],\n  \"O3\": [\"\", 1130],\n  \"o3\": [\"\", 1131],\n  \"F3\": [\"\", 1138],\n  \"f3\": [\"\", 1139],\n  \"V3\": [\"\", 1140],\n  \"v3\": [\"\", 1141],\n  \"C3\": [\"\", 1152],\n  \"c3\": [\"\", 1153],\n  \"G3\": [\"\", 1168],\n  \"g3\": [\"\", 1169],\n  \"A+\": [\"\", 1488],\n  \"B+\": [\"\", 1489],\n  \"G+\": [\"\", 1490],\n  \"D+\": [\"\", 1491],\n  \"H+\": [\"\", 1492],\n  \"W+\": [\"\", 1493],\n  \"Z+\": [\"\", 1494],\n  \"X+\": [\"\", 1495],\n  \"Tj\": [\"\", 1496],\n  \"J+\": [\"\", 1497],\n  \"K%\": [\"\", 1498],\n  \"K+\": [\"\", 1499],\n  \"L+\": [\"\", 1500],\n  \"M%\": [\"\", 1501],\n  \"M+\": [\"\", 1502],\n  \"N%\": [\"\", 1503],\n  \"N+\": [\"\", 1504],\n  \"S+\": [\"\", 1505],\n  \"E+\": [\"\", 1506],\n  \"P%\": [\"\", 1507],\n  \"P+\": [\"\", 1508],\n  \"Zj\": [\"\", 1509],\n  \"ZJ\": [\"\", 1510],\n  \"Q+\": [\"\", 1511],\n  \"R+\": [\"\", 1512],\n  \"Sh\": [\"\", 1513],\n  \"T+\": [\"\", 1514],\n  \",+\": [\"\", 1548],\n  \";+\": [\"\", 1563],\n  \"?+\": [\"\", 1567],\n  \"H'\": [\"\", 1569],\n  \"aM\": [\"\", 1570],\n  \"aH\": [\"\", 1571],\n  \"wH\": [\"\", 1572],\n  \"ah\": [\"\", 1573],\n  \"yH\": [\"\", 1574],\n  \"a+\": [\"\", 1575],\n  \"b+\": [\"\", 1576],\n  \"tm\": [\"\", 1577],\n  \"t+\": [\"\", 1578],\n  \"tk\": [\"\", 1579],\n  \"g+\": [\"\", 1580],\n  \"hk\": [\"\", 1581],\n  \"x+\": [\"\", 1582],\n  \"d+\": [\"\", 1583],\n  \"dk\": [\"\", 1584],\n  \"r+\": [\"\", 1585],\n  \"z+\": [\"\", 1586],\n  \"s+\": [\"\", 1587],\n  \"sn\": [\"\", 1588],\n  \"c+\": [\"\", 1589],\n  \"dd\": [\"\", 1590],\n  \"tj\": [\"\", 1591],\n  \"zH\": [\"\", 1592],\n  \"e+\": [\"\", 1593],\n  \"i+\": [\"\", 1594],\n  \"++\": [\"\", 1600],\n  \"f+\": [\"\", 1601],\n  \"q+\": [\"\", 1602],\n  \"k+\": [\"\", 1603],\n  \"l+\": [\"\", 1604],\n  \"m+\": [\"\", 1605],\n  \"n+\": [\"\", 1606],\n  \"h+\": [\"\", 1607],\n  \"w+\": [\"\", 1608],\n  \"j+\": [\"\", 1609],\n  \"y+\": [\"\", 1610],\n  \":+\": [\"\", 1611],\n  \"\\\"+\": [\"\", 1612],\n  \"=+\": [\"\", 1613],\n  \"/+\": [\"\", 1614],\n  \"'+\": [\"\", 1615],\n  \"1+\": [\"\", 1616],\n  \"3+\": [\"\", 1617],\n  \"0+\": [\"\", 1618],\n  \"aS\": [\"\", 1648],\n  \"p+\": [\"\", 1662],\n  \"v+\": [\"\", 1700],\n  \"gf\": [\"\", 1711],\n  \"0a\": [\"\", 1776],\n  \"1a\": [\"\", 1777],\n  \"2a\": [\"\", 1778],\n  \"3a\": [\"\", 1779],\n  \"4a\": [\"\", 1780],\n  \"5a\": [\"\", 1781],\n  \"6a\": [\"\", 1782],\n  \"7a\": [\"\", 1783],\n  \"8a\": [\"\", 1784],\n  \"9a\": [\"\", 1785],\n  \"B.\": [\"\", 7682],\n  \"b.\": [\"\", 7683],\n  \"B_\": [\"\", 7686],\n  \"b_\": [\"\", 7687],\n  \"D.\": [\"\", 7690],\n  \"d.\": [\"\", 7691],\n  \"D_\": [\"\", 7694],\n  \"d_\": [\"\", 7695],\n  \"D,\": [\"\", 7696],\n  \"d,\": [\"\", 7697],\n  \"F.\": [\"\", 7710],\n  \"f.\": [\"\", 7711],\n  \"G-\": [\"\", 7712],\n  \"g-\": [\"\", 7713],\n  \"H.\": [\"\", 7714],\n  \"h.\": [\"\", 7715],\n  \"H:\": [\"\", 7718],\n  \"h:\": [\"\", 7719],\n  \"H,\": [\"\", 7720],\n  \"h,\": [\"\", 7721],\n  \"K'\": [\"\", 7728],\n  \"k'\": [\"\", 7729],\n  \"K_\": [\"\", 7732],\n  \"k_\": [\"\", 7733],\n  \"L_\": [\"\", 7738],\n  \"l_\": [\"\", 7739],\n  \"M'\": [\"\", 7742],\n  \"m'\": [\"\", 7743],\n  \"M.\": [\"\", 7744],\n  \"m.\": [\"\", 7745],\n  \"N.\": [\"\", 7748],\n  \"n.\": [\"\", 7749],\n  \"N_\": [\"\", 7752],\n  \"n_\": [\"\", 7753],\n  \"P'\": [\"\", 7764],\n  \"p'\": [\"\", 7765],\n  \"P.\": [\"\", 7766],\n  \"p.\": [\"\", 7767],\n  \"R.\": [\"\", 7768],\n  \"r.\": [\"\", 7769],\n  \"R_\": [\"\", 7774],\n  \"r_\": [\"\", 7775],\n  \"S.\": [\"\", 7776],\n  \"s.\": [\"\", 7777],\n  \"T.\": [\"\", 7786],\n  \"t.\": [\"\", 7787],\n  \"T_\": [\"\", 7790],\n  \"t_\": [\"\", 7791],\n  \"V?\": [\"\", 7804],\n  \"v?\": [\"\", 7805],\n  \"W!\": [\"\", 7808],\n  \"w!\": [\"\", 7809],\n  \"W'\": [\"\", 7810],\n  \"w'\": [\"\", 7811],\n  \"W:\": [\"\", 7812],\n  \"w:\": [\"\", 7813],\n  \"W.\": [\"\", 7814],\n  \"w.\": [\"\", 7815],\n  \"X.\": [\"\", 7818],\n  \"x.\": [\"\", 7819],\n  \"X:\": [\"\", 7820],\n  \"x:\": [\"\", 7821],\n  \"Y.\": [\"\", 7822],\n  \"y.\": [\"\", 7823],\n  \"Z>\": [\"\", 7824],\n  \"z>\": [\"\", 7825],\n  \"Z_\": [\"\", 7828],\n  \"z_\": [\"\", 7829],\n  \"h_\": [\"\", 7830],\n  \"t:\": [\"\", 7831],\n  \"w0\": [\"\", 7832],\n  \"y0\": [\"\", 7833],\n  \"A2\": [\"\", 7842],\n  \"a2\": [\"\", 7843],\n  \"E2\": [\"\", 7866],\n  \"e2\": [\"\", 7867],\n  \"E?\": [\"\", 7868],\n  \"e?\": [\"\", 7869],\n  \"I2\": [\"\", 7880],\n  \"i2\": [\"\", 7881],\n  \"O2\": [\"\", 7886],\n  \"o2\": [\"\", 7887],\n  \"U2\": [\"\", 7910],\n  \"u2\": [\"\", 7911],\n  \"Y!\": [\"\", 7922],\n  \"y!\": [\"\", 7923],\n  \"Y2\": [\"\", 7926],\n  \"y2\": [\"\", 7927],\n  \"Y?\": [\"\", 7928],\n  \"y?\": [\"\", 7929],\n  \";'\": [\"\", 7936],\n  \",'\": [\"\", 7937],\n  \";!\": [\"\", 7938],\n  \",!\": [\"\", 7939],\n  \"?;\": [\"\", 7940],\n  \"?,\": [\"\", 7941],\n  \"!:\": [\"\", 7942],\n  \"?:\": [\"\", 7943],\n  \"1N\": [\"\", 8194],\n  \"1M\": [\"\", 8195],\n  \"3M\": [\"\", 8196],\n  \"4M\": [\"\", 8197],\n  \"6M\": [\"\", 8198],\n  \"1T\": [\"\", 8201],\n  \"1H\": [\"\", 8202],\n  \"-1\": [\"\", 8208],\n  \"-N\": [\"\", 8211],\n  \"-M\": [\"\", 8212],\n  \"-3\": [\"\", 8213],\n  \"!2\": [\"\", 8214],\n  \"=2\": [\"\", 8215],\n  \"'6\": [\"\", 8216],\n  \"'9\": [\"\", 8217],\n  \".9\": [\"\", 8218],\n  \"9'\": [\"\", 8219],\n  \"\\\"6\": [\"\", 8220],\n  \"\\\"9\": [\"\", 8221],\n  \":9\": [\"\", 8222],\n  \"9\\\"\": [\"\", 8223],\n  \"/-\": [\"\", 8224],\n  \"/=\": [\"\", 8225],\n  \"..\": [\"\", 8229],\n  \",.\": [\"\", 8230],\n  \"%0\": [\"\", 8240],\n  \"1'\": [\"\", 8242],\n  \"2'\": [\"\", 8243],\n  \"3'\": [\"\", 8244],\n  \"1\\\"\": [\"\", 8245],\n  \"2\\\"\": [\"\", 8246],\n  \"3\\\"\": [\"\", 8247],\n  \"Ca\": [\"\", 8248],\n  \"<1\": [\"\", 8249],\n  \">1\": [\"\", 8250],\n  \":X\": [\"\", 8251],\n  \"'-\": [\"\", 8254],\n  \"/f\": [\"\", 8260],\n  \"0S\": [\"\", 8304],\n  \"4S\": [\"\", 8308],\n  \"5S\": [\"\", 8309],\n  \"6S\": [\"\", 8310],\n  \"7S\": [\"\", 8311],\n  \"8S\": [\"\", 8312],\n  \"9S\": [\"\", 8313],\n  \"+S\": [\"\", 8314],\n  \"-S\": [\"\", 8315],\n  \"=S\": [\"\", 8316],\n  \"(S\": [\"\", 8317],\n  \")S\": [\"\", 8318],\n  \"nS\": [\"\", 8319],\n  \"0s\": [\"\", 8320],\n  \"1s\": [\"\", 8321],\n  \"2s\": [\"\", 8322],\n  \"3s\": [\"\", 8323],\n  \"4s\": [\"\", 8324],\n  \"5s\": [\"\", 8325],\n  \"6s\": [\"\", 8326],\n  \"7s\": [\"\", 8327],\n  \"8s\": [\"\", 8328],\n  \"9s\": [\"\", 8329],\n  \"+s\": [\"\", 8330],\n  \"-s\": [\"\", 8331],\n  \"=s\": [\"\", 8332],\n  \"(s\": [\"\", 8333],\n  \")s\": [\"\", 8334],\n  \"Li\": [\"\", 8356],\n  \"Pt\": [\"\", 8359],\n  \"W=\": [\"\", 8361],\n  \"=e\": [\"\", 8364],\n  \"Eu\": [\"\", 8364],\n  \"=R\": [\"\", 8381],\n  \"=P\": [\"\", 8381],\n  \"oC\": [\"\", 8451],\n  \"co\": [\"\", 8453],\n  \"oF\": [\"\", 8457],\n  \"N0\": [\"\", 8470],\n  \"PO\": [\"\", 8471],\n  \"Rx\": [\"\", 8478],\n  \"SM\": [\"\", 8480],\n  \"TM\": [\"\", 8482],\n  \"Om\": [\"\", 8486],\n  \"AO\": [\"\", 8491],\n  \"13\": [\"\", 8531],\n  \"23\": [\"\", 8532],\n  \"15\": [\"\", 8533],\n  \"25\": [\"\", 8534],\n  \"35\": [\"\", 8535],\n  \"45\": [\"\", 8536],\n  \"16\": [\"\", 8537],\n  \"56\": [\"\", 8538],\n  \"18\": [\"\", 8539],\n  \"38\": [\"\", 8540],\n  \"58\": [\"\", 8541],\n  \"78\": [\"\", 8542],\n  \"1R\": [\"\", 8544],\n  \"2R\": [\"\", 8545],\n  \"3R\": [\"\", 8546],\n  \"4R\": [\"\", 8547],\n  \"5R\": [\"\", 8548],\n  \"6R\": [\"\", 8549],\n  \"7R\": [\"\", 8550],\n  \"8R\": [\"\", 8551],\n  \"9R\": [\"\", 8552],\n  \"aR\": [\"\", 8553],\n  \"bR\": [\"\", 8554],\n  \"cR\": [\"\", 8555],\n  \"1r\": [\"\", 8560],\n  \"2r\": [\"\", 8561],\n  \"3r\": [\"\", 8562],\n  \"4r\": [\"\", 8563],\n  \"5r\": [\"\", 8564],\n  \"6r\": [\"\", 8565],\n  \"7r\": [\"\", 8566],\n  \"8r\": [\"\", 8567],\n  \"9r\": [\"\", 8568],\n  \"ar\": [\"\", 8569],\n  \"br\": [\"\", 8570],\n  \"cr\": [\"\", 8571],\n  \"<-\": [\"\", 8592],\n  \"-!\": [\"\", 8593],\n  \"->\": [\"\", 8594],\n  \"-v\": [\"\", 8595],\n  \"<>\": [\"\", 8596],\n  \"UD\": [\"\", 8597],\n  \"<=\": [\"\", 8656],\n  \"=>\": [\"\", 8658],\n  \"==\": [\"\", 8660],\n  \"FA\": [\"\", 8704],\n  \"dP\": [\"\", 8706],\n  \"TE\": [\"\", 8707],\n  \"/0\": [\"\", 8709],\n  \"DE\": [\"\", 8710],\n  \"NB\": [\"\", 8711],\n  \"(-\": [\"\", 8712],\n  \"-)\": [\"\", 8715],\n  \"*P\": [\"\", 8719],\n  \"+Z\": [\"\", 8721],\n  \"-2\": [\"\", 8722],\n  \"-+\": [\"\", 8723],\n  \"*-\": [\"\", 8727],\n  \"Ob\": [\"\", 8728],\n  \"Sb\": [\"\", 8729],\n  \"RT\": [\"\", 8730],\n  \"0(\": [\"\", 8733],\n  \"00\": [\"\", 8734],\n  \"-L\": [\"\", 8735],\n  \"-V\": [\"\", 8736],\n  \"PP\": [\"\", 8741],\n  \"AN\": [\"\", 8743],\n  \"OR\": [\"\", 8744],\n  \"(U\": [\"\", 8745],\n  \")U\": [\"\", 8746],\n  \"In\": [\"\", 8747],\n  \"DI\": [\"\", 8748],\n  \"Io\": [\"\", 8750],\n  \".:\": [\"\", 8756],\n  \":.\": [\"\", 8757],\n  \":R\": [\"\", 8758],\n  \"::\": [\"\", 8759],\n  \"?1\": [\"\", 8764],\n  \"CG\": [\"\", 8766],\n  \"?-\": [\"\", 8771],\n  \"?=\": [\"\", 8773],\n  \"?2\": [\"\", 8776],\n  \"=?\": [\"\", 8780],\n  \"HI\": [\"\", 8787],\n  \"!=\": [\"\", 8800],\n  \"=3\": [\"\", 8801],\n  \"=<\": [\"\", 8804],\n  \">=\": [\"\", 8805],\n  \"<*\": [\"\", 8810],\n  \"*>\": [\"\", 8811],\n  \"!<\": [\"\", 8814],\n  \"!>\": [\"\", 8815],\n  \"(C\": [\"\", 8834],\n  \")C\": [\"\", 8835],\n  \"(_\": [\"\", 8838],\n  \")_\": [\"\", 8839],\n  \"0.\": [\"\", 8857],\n  \"02\": [\"\", 8858],\n  \"-T\": [\"\", 8869],\n  \".P\": [\"\", 8901],\n  \":3\": [\"\", 8942],\n  \".3\": [\"\", 8943],\n  \"Eh\": [\"\", 8962],\n  \"<7\": [\"\", 8968],\n  \">7\": [\"\", 8969],\n  \"7<\": [\"\", 8970],\n  \"7>\": [\"\", 8971],\n  \"NI\": [\"\", 8976],\n  \"(A\": [\"\", 8978],\n  \"TR\": [\"\", 8981],\n  \"Iu\": [\"\", 8992],\n  \"Il\": [\"\", 8993],\n  \"</\": [\"\", 9001],\n  \"/>\": [\"\", 9002],\n  \"Vs\": [\"\", 9251],\n  \"1h\": [\"\", 9280],\n  \"3h\": [\"\", 9281],\n  \"2h\": [\"\", 9282],\n  \"4h\": [\"\", 9283],\n  \"1j\": [\"\", 9286],\n  \"2j\": [\"\", 9287],\n  \"3j\": [\"\", 9288],\n  \"4j\": [\"\", 9289],\n  \"1.\": [\"\", 9352],\n  \"2.\": [\"\", 9353],\n  \"3.\": [\"\", 9354],\n  \"4.\": [\"\", 9355],\n  \"5.\": [\"\", 9356],\n  \"6.\": [\"\", 9357],\n  \"7.\": [\"\", 9358],\n  \"8.\": [\"\", 9359],\n  \"9.\": [\"\", 9360],\n  \"hh\": [\"\", 9472],\n  \"HH\": [\"\", 9473],\n  \"vv\": [\"\", 9474],\n  \"VV\": [\"\", 9475],\n  \"3-\": [\"\", 9476],\n  \"3_\": [\"\", 9477],\n  \"3!\": [\"\", 9478],\n  \"3/\": [\"\", 9479],\n  \"4-\": [\"\", 9480],\n  \"4_\": [\"\", 9481],\n  \"4!\": [\"\", 9482],\n  \"4/\": [\"\", 9483],\n  \"dr\": [\"\", 9484],\n  \"dR\": [\"\", 9485],\n  \"Dr\": [\"\", 9486],\n  \"DR\": [\"\", 9487],\n  \"dl\": [\"\", 9488],\n  \"dL\": [\"\", 9489],\n  \"Dl\": [\"\", 9490],\n  \"LD\": [\"\", 9491],\n  \"ur\": [\"\", 9492],\n  \"uR\": [\"\", 9493],\n  \"Ur\": [\"\", 9494],\n  \"UR\": [\"\", 9495],\n  \"ul\": [\"\", 9496],\n  \"uL\": [\"\", 9497],\n  \"Ul\": [\"\", 9498],\n  \"UL\": [\"\", 9499],\n  \"vr\": [\"\", 9500],\n  \"vR\": [\"\", 9501],\n  \"Vr\": [\"\", 9504],\n  \"VR\": [\"\", 9507],\n  \"vl\": [\"\", 9508],\n  \"vL\": [\"\", 9509],\n  \"Vl\": [\"\", 9512],\n  \"VL\": [\"\", 9515],\n  \"dh\": [\"\", 9516],\n  \"dH\": [\"\", 9519],\n  \"Dh\": [\"\", 9520],\n  \"DH\": [\"\", 9523],\n  \"uh\": [\"\", 9524],\n  \"uH\": [\"\", 9527],\n  \"Uh\": [\"\", 9528],\n  \"UH\": [\"\", 9531],\n  \"vh\": [\"\", 9532],\n  \"vH\": [\"\", 9535],\n  \"Vh\": [\"\", 9538],\n  \"VH\": [\"\", 9547],\n  \"FD\": [\"\", 9585],\n  \"BD\": [\"\", 9586],\n  \"TB\": [\"\", 9600],\n  \"LB\": [\"\", 9604],\n  \"FB\": [\"\", 9608],\n  \"lB\": [\"\", 9612],\n  \"RB\": [\"\", 9616],\n  \".S\": [\"\", 9617],\n  \":S\": [\"\", 9618],\n  \"?S\": [\"\", 9619],\n  \"fS\": [\"\", 9632],\n  \"OS\": [\"\", 9633],\n  \"RO\": [\"\", 9634],\n  \"Rr\": [\"\", 9635],\n  \"RF\": [\"\", 9636],\n  \"RY\": [\"\", 9637],\n  \"RH\": [\"\", 9638],\n  \"RZ\": [\"\", 9639],\n  \"RK\": [\"\", 9640],\n  \"RX\": [\"\", 9641],\n  \"sB\": [\"\", 9642],\n  \"SR\": [\"\", 9644],\n  \"Or\": [\"\", 9645],\n  \"UT\": [\"\", 9650],\n  \"uT\": [\"\", 9651],\n  \"PR\": [\"\", 9654],\n  \"Tr\": [\"\", 9655],\n  \"Dt\": [\"\", 9660],\n  \"dT\": [\"\", 9661],\n  \"PL\": [\"\", 9664],\n  \"Tl\": [\"\", 9665],\n  \"Db\": [\"\", 9670],\n  \"Dw\": [\"\", 9671],\n  \"LZ\": [\"\", 9674],\n  \"0m\": [\"\", 9675],\n  \"0o\": [\"\", 9678],\n  \"0M\": [\"\", 9679],\n  \"0L\": [\"\", 9680],\n  \"0R\": [\"\", 9681],\n  \"Sn\": [\"\", 9688],\n  \"Ic\": [\"\", 9689],\n  \"Fd\": [\"\", 9698],\n  \"Bd\": [\"\", 9699],\n  \"*2\": [\"\", 9733],\n  \"*1\": [\"\", 9734],\n  \"<H\": [\"\", 9756],\n  \">H\": [\"\", 9758],\n  \"0u\": [\"\", 9786],\n  \"0U\": [\"\", 9787],\n  \"SU\": [\"\", 9788],\n  \"Fm\": [\"\", 9792],\n  \"Ml\": [\"\", 9794],\n  \"cS\": [\"\", 9824],\n  \"cH\": [\"\", 9825],\n  \"cD\": [\"\", 9826],\n  \"cC\": [\"\", 9827],\n  \"Md\": [\"\", 9833],\n  \"M8\": [\"\", 9834],\n  \"M2\": [\"\", 9835],\n  \"Mb\": [\"\", 9837],\n  \"Mx\": [\"\", 9838],\n  \"MX\": [\"\", 9839],\n  \"OK\": [\"\", 10003],\n  \"XX\": [\"\", 10007],\n  \"-X\": [\"\", 10016],\n  \"IS\": [\"\", 12288],\n  \",_\": [\"\", 12289],\n  \"._\": [\"\", 12290],\n  \"+\\\"\": [\"\", 12291],\n  \"+_\": [\"\", 12292],\n  \"*_\": [\"\", 12293],\n  \";_\": [\"\", 12294],\n  \"0_\": [\"\", 12295],\n  \"<+\": [\"\", 12298],\n  \">+\": [\"\", 12299],\n  \"<'\": [\"\", 12300],\n  \">'\": [\"\", 12301],\n  \"<\\\"\": [\"\", 12302],\n  \">\\\"\": [\"\", 12303],\n  \"(\\\"\": [\"\", 12304],\n  \")\\\"\": [\"\", 12305],\n  \"=T\": [\"\", 12306],\n  \"=_\": [\"\", 12307],\n  \"('\": [\"\", 12308],\n  \")'\": [\"\", 12309],\n  \"(I\": [\"\", 12310],\n  \")I\": [\"\", 12311],\n  \"-?\": [\"\", 12316],\n  \"A5\": [\"\", 12353],\n  \"a5\": [\"\", 12354],\n  \"I5\": [\"\", 12355],\n  \"i5\": [\"\", 12356],\n  \"U5\": [\"\", 12357],\n  \"u5\": [\"\", 12358],\n  \"E5\": [\"\", 12359],\n  \"e5\": [\"\", 12360],\n  \"O5\": [\"\", 12361],\n  \"o5\": [\"\", 12362],\n  \"ka\": [\"\", 12363],\n  \"ga\": [\"\", 12364],\n  \"ki\": [\"\", 12365],\n  \"gi\": [\"\", 12366],\n  \"ku\": [\"\", 12367],\n  \"gu\": [\"\", 12368],\n  \"ke\": [\"\", 12369],\n  \"ge\": [\"\", 12370],\n  \"ko\": [\"\", 12371],\n  \"go\": [\"\", 12372],\n  \"sa\": [\"\", 12373],\n  \"za\": [\"\", 12374],\n  \"si\": [\"\", 12375],\n  \"zi\": [\"\", 12376],\n  \"su\": [\"\", 12377],\n  \"zu\": [\"\", 12378],\n  \"se\": [\"\", 12379],\n  \"ze\": [\"\", 12380],\n  \"so\": [\"\", 12381],\n  \"zo\": [\"\", 12382],\n  \"ta\": [\"\", 12383],\n  \"da\": [\"\", 12384],\n  \"ti\": [\"\", 12385],\n  \"di\": [\"\", 12386],\n  \"tU\": [\"\", 12387],\n  \"tu\": [\"\", 12388],\n  \"du\": [\"\", 12389],\n  \"te\": [\"\", 12390],\n  \"de\": [\"\", 12391],\n  \"to\": [\"\", 12392],\n  \"do\": [\"\", 12393],\n  \"na\": [\"\", 12394],\n  \"ni\": [\"\", 12395],\n  \"nu\": [\"\", 12396],\n  \"ne\": [\"\", 12397],\n  \"no\": [\"\", 12398],\n  \"ha\": [\"\", 12399],\n  \"ba\": [\"\", 12400],\n  \"pa\": [\"\", 12401],\n  \"hi\": [\"\", 12402],\n  \"bi\": [\"\", 12403],\n  \"pi\": [\"\", 12404],\n  \"hu\": [\"\", 12405],\n  \"bu\": [\"\", 12406],\n  \"pu\": [\"\", 12407],\n  \"he\": [\"\", 12408],\n  \"be\": [\"\", 12409],\n  \"pe\": [\"\", 12410],\n  \"ho\": [\"\", 12411],\n  \"bo\": [\"\", 12412],\n  \"po\": [\"\", 12413],\n  \"ma\": [\"\", 12414],\n  \"mi\": [\"\", 12415],\n  \"mu\": [\"\", 12416],\n  \"me\": [\"\", 12417],\n  \"mo\": [\"\", 12418],\n  \"yA\": [\"\", 12419],\n  \"ya\": [\"\", 12420],\n  \"yU\": [\"\", 12421],\n  \"yu\": [\"\", 12422],\n  \"yO\": [\"\", 12423],\n  \"yo\": [\"\", 12424],\n  \"ra\": [\"\", 12425],\n  \"ri\": [\"\", 12426],\n  \"ru\": [\"\", 12427],\n  \"re\": [\"\", 12428],\n  \"ro\": [\"\", 12429],\n  \"wA\": [\"\", 12430],\n  \"wa\": [\"\", 12431],\n  \"wi\": [\"\", 12432],\n  \"we\": [\"\", 12433],\n  \"wo\": [\"\", 12434],\n  \"n5\": [\"\", 12435],\n  \"vu\": [\"\", 12436],\n  \"\\\"5\": [\"\", 12443],\n  \"05\": [\"\", 12444],\n  \"*5\": [\"\", 12445],\n  \"+5\": [\"\", 12446],\n  \"a6\": [\"\", 12449],\n  \"A6\": [\"\", 12450],\n  \"i6\": [\"\", 12451],\n  \"I6\": [\"\", 12452],\n  \"u6\": [\"\", 12453],\n  \"U6\": [\"\", 12454],\n  \"e6\": [\"\", 12455],\n  \"E6\": [\"\", 12456],\n  \"o6\": [\"\", 12457],\n  \"O6\": [\"\", 12458],\n  \"Ka\": [\"\", 12459],\n  \"Ga\": [\"\", 12460],\n  \"Ki\": [\"\", 12461],\n  \"Gi\": [\"\", 12462],\n  \"Ku\": [\"\", 12463],\n  \"Gu\": [\"\", 12464],\n  \"Ke\": [\"\", 12465],\n  \"Ge\": [\"\", 12466],\n  \"Ko\": [\"\", 12467],\n  \"Go\": [\"\", 12468],\n  \"Sa\": [\"\", 12469],\n  \"Za\": [\"\", 12470],\n  \"Si\": [\"\", 12471],\n  \"Zi\": [\"\", 12472],\n  \"Su\": [\"\", 12473],\n  \"Zu\": [\"\", 12474],\n  \"Se\": [\"\", 12475],\n  \"Ze\": [\"\", 12476],\n  \"So\": [\"\", 12477],\n  \"Zo\": [\"\", 12478],\n  \"Ta\": [\"\", 12479],\n  \"Da\": [\"\", 12480],\n  \"Ti\": [\"\", 12481],\n  \"Di\": [\"\", 12482],\n  \"TU\": [\"\", 12483],\n  \"Tu\": [\"\", 12484],\n  \"Du\": [\"\", 12485],\n  \"Te\": [\"\", 12486],\n  \"De\": [\"\", 12487],\n  \"To\": [\"\", 12488],\n  \"Do\": [\"\", 12489],\n  \"Na\": [\"\", 12490],\n  \"Ni\": [\"\", 12491],\n  \"Nu\": [\"\", 12492],\n  \"Ne\": [\"\", 12493],\n  \"No\": [\"\", 12494],\n  \"Ha\": [\"\", 12495],\n  \"Ba\": [\"\", 12496],\n  \"Pa\": [\"\", 12497],\n  \"Hi\": [\"\", 12498],\n  \"Bi\": [\"\", 12499],\n  \"Pi\": [\"\", 12500],\n  \"Hu\": [\"\", 12501],\n  \"Bu\": [\"\", 12502],\n  \"Pu\": [\"\", 12503],\n  \"He\": [\"\", 12504],\n  \"Be\": [\"\", 12505],\n  \"Pe\": [\"\", 12506],\n  \"Ho\": [\"\", 12507],\n  \"Bo\": [\"\", 12508],\n  \"Po\": [\"\", 12509],\n  \"Ma\": [\"\", 12510],\n  \"Mi\": [\"\", 12511],\n  \"Mu\": [\"\", 12512],\n  \"Me\": [\"\", 12513],\n  \"Mo\": [\"\", 12514],\n  \"YA\": [\"\", 12515],\n  \"Ya\": [\"\", 12516],\n  \"YU\": [\"\", 12517],\n  \"Yu\": [\"\", 12518],\n  \"YO\": [\"\", 12519],\n  \"Yo\": [\"\", 12520],\n  \"Ra\": [\"\", 12521],\n  \"Ri\": [\"\", 12522],\n  \"Ru\": [\"\", 12523],\n  \"Re\": [\"\", 12524],\n  \"Ro\": [\"\", 12525],\n  \"WA\": [\"\", 12526],\n  \"Wa\": [\"\", 12527],\n  \"Wi\": [\"\", 12528],\n  \"We\": [\"\", 12529],\n  \"Wo\": [\"\", 12530],\n  \"N6\": [\"\", 12531],\n  \"Vu\": [\"\", 12532],\n  \"KA\": [\"\", 12533],\n  \"KE\": [\"\", 12534],\n  \"Va\": [\"\", 12535],\n  \"Vi\": [\"\", 12536],\n  \"Ve\": [\"\", 12537],\n  \"Vo\": [\"\", 12538],\n  \".6\": [\"\", 12539],\n  \"-6\": [\"\", 12540],\n  \"*6\": [\"\", 12541],\n  \"+6\": [\"\", 12542],\n  \"b4\": [\"\", 12549],\n  \"p4\": [\"\", 12550],\n  \"m4\": [\"\", 12551],\n  \"f4\": [\"\", 12552],\n  \"d4\": [\"\", 12553],\n  \"t4\": [\"\", 12554],\n  \"n4\": [\"\", 12555],\n  \"l4\": [\"\", 12556],\n  \"g4\": [\"\", 12557],\n  \"k4\": [\"\", 12558],\n  \"h4\": [\"\", 12559],\n  \"j4\": [\"\", 12560],\n  \"q4\": [\"\", 12561],\n  \"x4\": [\"\", 12562],\n  \"zh\": [\"\", 12563],\n  \"ch\": [\"\", 12564],\n  \"sh\": [\"\", 12565],\n  \"r4\": [\"\", 12566],\n  \"z4\": [\"\", 12567],\n  \"c4\": [\"\", 12568],\n  \"s4\": [\"\", 12569],\n  \"a4\": [\"\", 12570],\n  \"o4\": [\"\", 12571],\n  \"e4\": [\"\", 12572],\n  \"ai\": [\"\", 12574],\n  \"ei\": [\"\", 12575],\n  \"au\": [\"\", 12576],\n  \"ou\": [\"\", 12577],\n  \"an\": [\"\", 12578],\n  \"en\": [\"\", 12579],\n  \"aN\": [\"\", 12580],\n  \"eN\": [\"\", 12581],\n  \"er\": [\"\", 12582],\n  \"i4\": [\"\", 12583],\n  \"u4\": [\"\", 12584],\n  \"iu\": [\"\", 12585],\n  \"v4\": [\"\", 12586],\n  \"nG\": [\"\", 12587],\n  \"gn\": [\"\", 12588],\n  \"1c\": [\"\", 12832],\n  \"2c\": [\"\", 12833],\n  \"3c\": [\"\", 12834],\n  \"4c\": [\"\", 12835],\n  \"5c\": [\"\", 12836],\n  \"6c\": [\"\", 12837],\n  \"7c\": [\"\", 12838],\n  \"8c\": [\"\", 12839],\n  \"9c\": [\"\", 12840],\n  \"ff\": [\"\", 64256],\n  \"fi\": [\"\", 64257],\n  \"fl\": [\"\", 64258],\n  \"ft\": [\"\", 64261],\n  \"st\": [\"\", 64262],\n  \"W`\": [\"\", 7808],\n  \"w`\": [\"\", 7809],\n  \"Y`\": [\"\", 7922],\n  \"y`\": [\"\", 7923],\n};\n","import * as vscode from 'vscode';\n\nimport { lineCompletionProvider } from '../../completion/lineCompletionProvider';\nimport { RecordedState } from '../../state/recordedState';\nimport { VimState } from '../../state/vimState';\nimport { PositionDiff } from './../../common/motion/position';\nimport { Range } from './../../common/motion/range';\nimport { configuration } from './../../configuration/configuration';\nimport { Mode } from './../../mode/mode';\nimport { Register, RegisterMode } from './../../register/register';\nimport { TextEditor } from './../../textEditor';\nimport { RegisterAction, BaseCommand } from './../base';\nimport { ArrowsInInsertMode } from './../motion';\nimport {\n  CommandInsertAfterCursor,\n  CommandInsertAtCursor,\n  CommandInsertAtFirstCharacter,\n  CommandInsertAtLineEnd,\n  DocumentContentChangeAction,\n  CommandReplaceAtCursorFromNormalMode,\n} from './actions';\nimport { DefaultDigraphs } from './digraphs';\nimport { Clipboard } from '../../util/clipboard';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { Position } from 'vscode';\nimport { PutCommand } from './put';\n\n@RegisterAction\nclass CommandEscInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vscode.commands.executeCommand('closeParameterHints');\n\n    vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getLeft()));\n    if (vimState.returnToInsertAfterCommand && position.character !== 0) {\n      vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getRight()));\n    }\n\n    // only remove leading spaces inserted by vscode.\n    // vscode only inserts them when user enter a new line,\n    // ie, o/O in Normal mode or \\n in Insert mode.\n    for (let i = 0; i < vimState.cursors.length; i++) {\n      const lastActionBeforeEsc = vimState.keyHistory[vimState.keyHistory.length - 2];\n      if (\n        ['o', 'O', '\\n'].includes(lastActionBeforeEsc) &&\n        vimState.document.languageId !== 'plaintext' &&\n        /^\\s+$/.test(vimState.document.lineAt(vimState.cursors[i].stop).text)\n      ) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'deleteRange',\n          range: new Range(\n            vimState.cursors[i].stop.getLineBegin(),\n            vimState.cursors[i].stop.getLineEnd()\n          ),\n        });\n        vimState.cursors[i] = vimState.cursors[i].withNewStop(\n          vimState.cursors[i].stop.getLineBegin()\n        );\n      }\n    }\n    await vimState.setCurrentMode(Mode.Normal);\n\n    // If we wanted to repeat this insert (only for i and a), now is the time to do it. Insert\n    // count amount of these strings before returning back to normal mode\n    const typeOfInsert =\n      vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 3];\n    const isTypeToRepeatInsert =\n      typeOfInsert instanceof CommandInsertAtCursor ||\n      typeOfInsert instanceof CommandInsertAfterCursor ||\n      typeOfInsert instanceof CommandInsertAtLineEnd ||\n      typeOfInsert instanceof CommandInsertAtFirstCharacter;\n\n    // If this is the type to repeat insert, do this now\n    if (vimState.recordedState.count > 1 && isTypeToRepeatInsert) {\n      const changeAction = vimState.recordedState.actionsRun[\n        vimState.recordedState.actionsRun.length - 2\n      ] as DocumentContentChangeAction;\n\n      // Add count amount of inserts in the case of 4i=<esc>\n      for (let i = 0; i < vimState.recordedState.count - 1; i++) {\n        // If this is the last transform, move cursor back one character\n        const positionDiff =\n          i === vimState.recordedState.count - 2\n            ? new PositionDiff({ character: -1 })\n            : new PositionDiff();\n\n        // Add a transform containing the change\n        vimState.recordedState.transformer.addTransformation(\n          changeAction.getTransformation(positionDiff)\n        );\n      }\n    }\n\n    if (vimState.historyTracker.currentContentChanges.length > 0) {\n      vimState.historyTracker.lastContentChanges = vimState.historyTracker.currentContentChanges;\n      vimState.historyTracker.currentContentChanges = [];\n    }\n\n    if (vimState.isFakeMultiCursor) {\n      vimState.cursors = [vimState.cursors[0]];\n      vimState.isMultiCursor = false;\n      vimState.isFakeMultiCursor = false;\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandInsertPreviousText extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-a>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = await Register.get(vimState, '.');\n    if (\n      register === undefined ||\n      !(register.text instanceof RecordedState) ||\n      !register.text.actionsRun\n    ) {\n      throw VimError.fromCode(ErrorCode.NoInsertedTextYet);\n    }\n\n    const actions = [...register.text.actionsRun];\n    // let actions = Register.lastContentChange.actionsRun.slice(0);\n    // The first action is entering Insert Mode, which is not necessary in this case\n    actions.shift();\n    // The last action is leaving Insert Mode, which is not necessary in this case\n    // actions.pop();\n\n    if (actions.length > 0 && actions[0] instanceof ArrowsInInsertMode) {\n      // Note, arrow keys are the only Insert action command that can't be repeated here as far as @rebornix knows.\n      actions.shift();\n    }\n\n    for (const action of actions) {\n      if (action instanceof BaseCommand) {\n        await action.execCount(vimState.cursorStopPosition, vimState);\n      }\n\n      if (action instanceof DocumentContentChangeAction) {\n        await action.exec(vimState.cursorStopPosition, vimState);\n      }\n    }\n\n    vimState.cursorStopPosition = vimState.editor.selection.end;\n    vimState.cursorStartPosition = vimState.editor.selection.start;\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nclass CommandInsertPreviousTextAndQuit extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-shift+2>']; // <C-@>\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new CommandInsertPreviousText().exec(position, vimState);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandInsertBelowChar extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-e>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.line === vimState.document.lineCount - 1) {\n      return;\n    }\n\n    const charBelowCursorPosition = position.getDown();\n\n    if (charBelowCursorPosition.isLineEnd()) {\n      return;\n    }\n\n    const char = vimState.document.getText(\n      new vscode.Range(charBelowCursorPosition, charBelowCursorPosition.getRight())\n    );\n    await TextEditor.insert(vimState.editor, char, position);\n\n    vimState.cursorStartPosition = vimState.editor.selection.start;\n    vimState.cursorStopPosition = vimState.editor.selection.start;\n  }\n}\n\n@RegisterAction\nclass CommandInsertIndentInCurrentLine extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-t>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const originalText = vimState.document.lineAt(position).text;\n    const indentationWidth = TextEditor.getIndentationLevel(originalText);\n    const tabSize = configuration.tabstop || Number(vimState.editor.options.tabSize);\n    const newIndentationWidth = (indentationWidth / tabSize + 1) * tabSize;\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      text: TextEditor.setIndentationLevel(originalText, newIndentationWidth),\n      range: new Range(position.getLineBegin(), position.getLineEnd()),\n      diff: new PositionDiff({ character: newIndentationWidth - indentationWidth }),\n    });\n  }\n}\n\n// Upon thinking about it some more, I'm not really sure how to fix this\n// elegantly. Tab is just used for so many things in the VSCode editor, and all\n// of them happen to be overloaded. Sometimes tab does a tab, sometimes it does\n// an emmet completion, sometimes a snippet completion, etc.\n// @RegisterAction\n// export class CommandInsertTabInInsertMode extends BaseCommand {\n//   modes = [ModeName.Insert];\n//   keys = [\"<tab>\"];\n//   runsOnceForEveryCursor() { return false; }\n\n//   public async exec(position: Position, vimState: VimState): Promise<void> {\n//     vimState.recordedState.transformer.addTransformation({\n//       type: \"tab\"\n//     });\n//   }\n// }\n\n@RegisterAction\nexport class CommandBackspaceInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<BS>'], ['<C-h>']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const line = vimState.document.lineAt(position).text;\n    const selection = vimState.editor.selections.find((s) => s.contains(position));\n\n    if (selection && !selection.isEmpty) {\n      // If a selection is active, delete it\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new Range(selection.start, selection.end),\n      });\n    } else if (\n      position.character > 0 &&\n      line.length > 0 &&\n      line.match(/^\\s+$/) &&\n      configuration.expandtab\n    ) {\n      // If the line is empty except whitespace and we're not on the first\n      // character of the line, backspace should return to the next lowest\n      // level of indentation.\n      // TODO: similar logic is needed for whitespace at the start or end of a line. See #1691\n\n      const tabSize = vimState.editor.options.tabSize as number;\n      const desiredLineLength = Math.floor((position.character - 1) / tabSize) * tabSize;\n\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new Range(position.withColumn(desiredLineLength), position.withColumn(line.length)),\n      });\n    } else if (!position.isAtDocumentBegin()) {\n      // Otherwise, just delete a character (unless we're at the start of the document)\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteText',\n        position,\n      });\n    }\n\n    vimState.cursorStopPosition = vimState.cursorStopPosition.getLeft();\n    vimState.cursorStartPosition = vimState.cursorStartPosition.getLeft();\n  }\n}\n\n@RegisterAction\nexport class CommandDeleteInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<Del>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const selection = vimState.editor.selection;\n\n    if (!selection.isEmpty) {\n      // If a selection is active, delete it\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new Range(selection.start, selection.end),\n      });\n    } else if (!position.isAtDocumentEnd()) {\n      // Otherwise, just delete a character (unless we're at the end of the document)\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteText',\n        position: position.getRightThroughLineBreaks(true),\n      });\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandInsertInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<character>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const char = this.keysPressed[this.keysPressed.length - 1];\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertTextVSCode',\n      text: char,\n      isMultiCursor: vimState.isMultiCursor,\n    });\n  }\n\n  public toString(): string {\n    return this.keysPressed[this.keysPressed.length - 1];\n  }\n}\n\n@RegisterAction\nclass CommandInsertDigraph extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-k>', '<any>', '<any>'];\n  isCompleteAction = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const digraph = this.keysPressed.slice(1, 3).join('');\n    const reverseDigraph = digraph.split('').reverse().join('');\n    let charCodes = (DefaultDigraphs[digraph] ||\n      DefaultDigraphs[reverseDigraph] ||\n      configuration.digraphs[digraph] ||\n      configuration.digraphs[reverseDigraph])[1];\n    if (!(charCodes instanceof Array)) {\n      charCodes = [charCodes];\n    }\n    const char = String.fromCharCode(...charCodes);\n    await TextEditor.insertAt(vimState.editor, char, position);\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStartPosition = vimState.editor.selection.start;\n    vimState.cursorStopPosition = vimState.editor.selection.start;\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!super.doesActionApply(vimState, keysPressed)) {\n      return false;\n    }\n    const chars = keysPressed.slice(1, 3).join('');\n    const reverseChars = chars.split('').reverse().join('');\n    return (\n      chars in configuration.digraphs ||\n      reverseChars in configuration.digraphs ||\n      chars in DefaultDigraphs ||\n      reverseChars in DefaultDigraphs\n    );\n  }\n\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!super.couldActionApply(vimState, keysPressed)) {\n      return false;\n    }\n    const chars = keysPressed.slice(1, keysPressed.length).join('');\n    const reverseChars = chars.split('').reverse().join('');\n    if (chars.length > 0) {\n      const predicate = (digraph: string) => {\n        const digraphChars = digraph.substring(0, chars.length);\n        return chars === digraphChars || reverseChars === digraphChars;\n      };\n      const match =\n        Object.keys(configuration.digraphs).find(predicate) ||\n        Object.keys(DefaultDigraphs).find(predicate);\n      return match !== undefined;\n    }\n    return true;\n  }\n}\n\n@RegisterAction\nclass CommandInsertRegisterContent extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-r>', '<character>'];\n  isCompleteAction = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.registerName = this.keysPressed[1];\n    const register = await Register.get(vimState);\n    if (register === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister));\n      return;\n    }\n\n    let text: string;\n    if (register.text instanceof Array) {\n      text =\n        // when we yanked with MC and insert with MC, we insert register[i] at cusor[i]\n        vimState.isMultiCursor && vimState.cursors.length === register.text.length\n          ? await PutCommand.getText(vimState, register, this.multicursorIndex)\n          : register.text.join('\\n');\n    } else if (register.text instanceof RecordedState) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register: vimState.recordedState.registerName,\n        replay: 'keystrokes',\n      });\n\n      return;\n    } else {\n      text = register.text;\n    }\n\n    if (register.registerMode === RegisterMode.LineWise && !vimState.isMultiCursor) {\n      text += '\\n';\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertText',\n      text,\n      position,\n    });\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStartPosition = vimState.editor.selection.start;\n    vimState.cursorStopPosition = vimState.editor.selection.start;\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const register = keysPressed[1];\n\n    return super.doesActionApply(vimState, keysPressed) && Register.isValidRegister(register);\n  }\n}\n\n@RegisterAction\nexport class CommandOneNormalCommandInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-o>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.returnToInsertAfterCommand = true;\n    vimState.actionCount = 0;\n    await new CommandEscInsertMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandCtrlW extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-w>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    let wordBegin: Position;\n    if (position.isInLeadingWhitespace(vimState.document)) {\n      wordBegin = position.getLineBegin();\n    } else if (position.isLineBeginning()) {\n      wordBegin = position.getPreviousLineBegin().getLineEnd();\n    } else {\n      wordBegin = position.getWordLeft();\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRange',\n      range: new Range(wordBegin, position),\n    });\n\n    vimState.cursorStopPosition = wordBegin;\n  }\n}\n\n@RegisterAction\nclass CommandDeleteIndentInCurrentLine extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-d>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const originalText = vimState.document.lineAt(position).text;\n    const indentationWidth = TextEditor.getIndentationLevel(originalText);\n\n    if (indentationWidth === 0) {\n      return;\n    }\n\n    const tabSize = configuration.tabstop;\n    const newIndentationWidth = (indentationWidth / tabSize - 1) * tabSize;\n\n    await TextEditor.replace(\n      vimState.editor,\n      new vscode.Range(position.getLineBegin(), position.getLineEnd()),\n      TextEditor.setIndentationLevel(\n        originalText,\n        newIndentationWidth < 0 ? 0 : newIndentationWidth\n      )\n    );\n\n    const cursorPosition = position.with(\n      position.line,\n      position.character + (newIndentationWidth - indentationWidth) / tabSize\n    );\n    vimState.cursorStopPosition = cursorPosition;\n    vimState.cursorStartPosition = cursorPosition;\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nclass CommandInsertAboveChar extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-y>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.line === 0) {\n      return;\n    }\n\n    const charAboveCursorPosition = position.getUp(1);\n\n    if (charAboveCursorPosition.isLineEnd()) {\n      return;\n    }\n\n    const char = vimState.document.getText(\n      new vscode.Range(charAboveCursorPosition, charAboveCursorPosition.getRight())\n    );\n    await TextEditor.insert(vimState.editor, char, position);\n\n    vimState.cursorStartPosition = vimState.editor.selection.start;\n    vimState.cursorStopPosition = vimState.editor.selection.start;\n  }\n}\n\n@RegisterAction\nclass CommandCtrlUInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-u>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const start = position.isInLeadingWhitespace(vimState.document)\n      ? position.getLineBegin()\n      : position.getLineBeginRespectingIndent(vimState.document);\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRange',\n      range: new Range(start, position),\n    });\n    vimState.cursorStopPosition = start;\n    vimState.cursorStartPosition = start;\n  }\n}\n\n@RegisterAction\nclass CommandNavigateAutocompleteDown extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<C-n>'], ['<C-j>']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    /* if we're in a multi cursor state, we check to see if the current active text selection\n     * is the same as the position we've been passed when we exec this function\n     * this has the effect of only ever executing `selectNextSuggestion` once.\n     * without this we execute it once per multi cursor, meaning it skips over the autocomplete\n     * list suggestions\n     */\n    if (vimState.isMultiCursor) {\n      const selection = vimState.editor.selection;\n      if (\n        selection.active.line === position.line &&\n        selection.active.character === position.character\n      ) {\n        await vscode.commands.executeCommand('selectNextSuggestion');\n      }\n    } else {\n      await vscode.commands.executeCommand('selectNextSuggestion');\n    }\n  }\n}\n\n@RegisterAction\nclass CommandNavigateAutocompleteUp extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-p>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    /* if we're in a multi cursor state, we check to see if the current active text selection\n     * is the same as the position we've been passed when we exec this function\n     * this has the effect of only ever executing `selectPrevSuggestion` once.\n     * without this we execute it once per multi cursor, meaning it skips over the autocomplete\n     * list suggestions\n     */\n    if (vimState.isMultiCursor) {\n      const selection = vimState.editor.selection;\n      if (\n        selection.active.line === position.line &&\n        selection.active.character === position.character\n      ) {\n        await vscode.commands.executeCommand('selectPrevSuggestion');\n      }\n    } else {\n      await vscode.commands.executeCommand('selectPrevSuggestion');\n    }\n  }\n}\n\n@RegisterAction\nclass CommandCtrlVInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-v>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const textFromClipboard = await Clipboard.Paste();\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRange',\n      range: new Range(vimState.cursorStartPosition, vimState.cursorStopPosition),\n    });\n\n    if (vimState.isMultiCursor) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'insertText',\n        text: textFromClipboard,\n        position: vimState.cursorStopPosition,\n      });\n    } else {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'insertTextVSCode',\n        text: textFromClipboard,\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass CommandShowLineAutocomplete extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-x>', '<C-l>'];\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await lineCompletionProvider.showLineCompletionsQuickPick(position, vimState);\n  }\n}\n\n@RegisterAction\nclass NewLineInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<C-j>'], ['<C-m>']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertText',\n      text: '\\n',\n      position,\n      diff: new PositionDiff({ character: -1 }),\n    });\n  }\n}\n\n@RegisterAction\nclass CommandReplaceAtCursorFromInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<Insert>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new CommandReplaceAtCursorFromNormalMode().exec(position, vimState);\n  }\n}\n","import { PositionDiff, PositionDiffType, sorted } from '../../common/motion/position';\nimport { configuration } from '../../configuration/configuration';\nimport { isVisualMode, Mode } from '../../mode/mode';\nimport { Register, RegisterMode, IRegisterContent, RegisterContent } from '../../register/register';\nimport { RecordedState } from '../../state/recordedState';\nimport { VimState } from '../../state/vimState';\nimport { TextEditor } from '../../textEditor';\nimport { reportLinesChanged } from '../../util/statusBarTextUtils';\nimport { BaseCommand, RegisterAction } from '../base';\nimport * as operator from '../operator';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { Position } from 'vscode';\n\n/**\n * Flags used for executing PutCommand.\n */\nexport interface IPutCommandOptions {\n  /**\n   * Determines whether to put the text before or after the cursor position.\n   *\n   * True for commands like `P` and `gP`\n   */\n  pasteBeforeCursor?: boolean;\n\n  /**\n   * Adjust the indent of the put to match the current line's indentation.\n   *\n   * True for commands like `]p` and `[p`\n   */\n  adjustIndent?: boolean;\n\n  /**\n   * Forces a linewise register mode put.\n   *\n   * True only for `:p[ut]`\n   */\n  forceLinewise?: boolean;\n\n  /**\n   * Forces the cursor to move to the last line of what you pasted.\n   *\n   * True only for `:p[ut]`\n   */\n  forceCursorLastLine?: boolean;\n}\n\n@RegisterAction\nexport class PutCommand extends BaseCommand {\n  keys = ['p'];\n  modes = [Mode.Normal];\n  runsOnceForEachCountPrefix = true;\n  canBeRepeatedWithDot = true;\n\n  constructor(multicursorIndex?: number) {\n    super();\n    this.multicursorIndex = multicursorIndex;\n  }\n\n  public static async getText(\n    vimState: VimState,\n    registerContent: IRegisterContent,\n    multicursorIndex: number | undefined\n  ): Promise<string> {\n    if (vimState.isMultiCursor) {\n      if (multicursorIndex === undefined) {\n        throw new Error('No multi-cursor index when calling PutCommand#getText');\n      }\n\n      if (typeof registerContent.text === 'object') {\n        return registerContent.text[multicursorIndex];\n      }\n    }\n\n    // if we yanked with multicursors before (=text is an array), but paste with one cursor only\n    // we need to the register\n    return registerContent.text instanceof Array\n      ? registerContent.text.join('\\n')\n      : (registerContent.text as string);\n  }\n\n  public async exec(\n    position: Position,\n    vimState: VimState,\n    options: IPutCommandOptions = {}\n  ): Promise<void> {\n    const register = await Register.get(vimState);\n    if (register === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister));\n      return;\n    }\n\n    const dest = options.pasteBeforeCursor ? position : position.getRight();\n    const registerMode = options.forceLinewise ? RegisterMode.LineWise : register.registerMode;\n\n    if (register.text instanceof RecordedState) {\n      /**\n       *  Paste content from recordedState. This one is actually complex as\n       *  Vim has internal key code for key strokes.For example, Backspace\n       *  is stored as `<80>kb`. So if you replay a macro, which is stored\n       *  in a register as `a1<80>kb2`, youshall just get `2` inserted as\n       *  `a` represents entering Insert Mode, `<80>bk` represents\n       *  Backspace. However here, we shall\n       *  insert the plain text content of the register, which is `a1<80>kb2`.\n       */\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register: vimState.recordedState.registerName,\n        replay: 'keystrokes',\n      });\n      return;\n    } else if (typeof register.text === 'object' && vimState.currentMode === Mode.VisualBlock) {\n      await this.execVisualBlockPaste(\n        register.text,\n        position,\n        vimState,\n        options.pasteBeforeCursor || false\n      );\n    }\n\n    let text = await PutCommand.getText(vimState, register, this.multicursorIndex);\n\n    const noPrevLine = vimState.cursorStartPosition.line === 0;\n    const noNextLine = vimState.cursorStopPosition.line === vimState.document.lineCount - 1;\n\n    let textToAdd: string;\n    let whereToAddText: Position;\n    if (registerMode === RegisterMode.CharacterWise) {\n      textToAdd = text;\n      whereToAddText = dest;\n    } else if (vimState.currentMode === Mode.Visual && registerMode === RegisterMode.LineWise) {\n      // in the specific case of linewise register data during visual mode,\n      // we need extra newline feeds\n      textToAdd = '\\n' + text + '\\n';\n      whereToAddText = dest;\n    } else if (vimState.currentMode === Mode.VisualLine && registerMode === RegisterMode.LineWise) {\n      // in the specific case of linewise register data during visual mode,\n      // we need extra newline feeds\n      const left = !noPrevLine && noNextLine ? '\\n' : '';\n      const right = noNextLine ? '' : '\\n';\n      textToAdd = left + text + right;\n      whereToAddText = dest;\n    } else {\n      if (options.adjustIndent) {\n        // Adjust indent to current line\n        const indentationWidth = TextEditor.getIndentationLevel(\n          vimState.document.lineAt(position).text\n        );\n        const firstLineIdentationWidth = TextEditor.getIndentationLevel(text.split('\\n')[0]);\n\n        text = text\n          .split('\\n')\n          .map((line) => {\n            const currentIdentationWidth = TextEditor.getIndentationLevel(line);\n            const newIndentationWidth =\n              currentIdentationWidth - firstLineIdentationWidth + indentationWidth;\n\n            return TextEditor.setIndentationLevel(line, newIndentationWidth);\n          })\n          .join('\\n');\n      }\n\n      if (registerMode === RegisterMode.LineWise) {\n        // P insert before current line\n        if (options.pasteBeforeCursor) {\n          textToAdd = text + '\\n';\n          whereToAddText = dest.getLineBegin();\n        } else {\n          textToAdd = '\\n' + text;\n          whereToAddText = dest.getLineEnd();\n        }\n      } else {\n        textToAdd = text;\n        whereToAddText = options.pasteBeforeCursor ? position : position.getRight();\n      }\n    }\n\n    // After using \"p\" or \"P\" in Visual mode the text that was put will be\n    // selected (from Vim's \":help gv\").\n    if (isVisualMode(vimState.currentMode)) {\n      let textToEnd = textToAdd;\n      if (vimState.currentMode === Mode.VisualLine && textToAdd[textToAdd.length - 1] === '\\n') {\n        // don't go next line\n        textToEnd = textToAdd.substring(0, textToAdd.length - 1);\n      }\n      vimState.lastVisualSelection = {\n        mode: vimState.currentMode,\n        start: whereToAddText,\n        end: whereToAddText.advancePositionByText(textToEnd),\n      };\n    }\n\n    // More vim weirdness: If the thing you're pasting has a newline, the cursor\n    // stays in the same place. Otherwise, it moves to the end of what you pasted.\n\n    const numNewlines = text.split('\\n').length - 1;\n    const currentLineLength = vimState.document.lineAt(position).text.length;\n\n    let diff: PositionDiff;\n    if (vimState.currentMode === Mode.VisualLine) {\n      const lines = text.split('\\n');\n      const whitespaceOnFirstLine = /^\\s*/.exec(lines[0])?.[0].length ?? 0;\n      let lineDiff = lines.length - 1;\n      if (register.registerMode === RegisterMode.LineWise && !noNextLine) {\n        lineDiff++;\n      }\n      diff = {\n        type: PositionDiffType.ExactCharacter,\n        line: -lineDiff,\n        character: whitespaceOnFirstLine,\n      };\n    } else if (registerMode === RegisterMode.LineWise && options.forceCursorLastLine) {\n      // Move to cursor to last line, first non-whitespace character of what you pasted\n      const lastLine = text.split('\\n')[numNewlines];\n      const check = lastLine.match(/^\\s*/);\n      const numWhitespace = check ? check[0].length : 0;\n\n      let lineDiff: number;\n      if (options.pasteBeforeCursor) {\n        lineDiff = -numNewlines;\n      } else {\n        lineDiff = currentLineLength > 0 ? numNewlines + 1 : 0;\n      }\n\n      diff = new PositionDiff({\n        line: lineDiff,\n        character: numWhitespace,\n        type: PositionDiffType.ExactCharacter,\n      });\n    } else if (registerMode === RegisterMode.LineWise) {\n      const check = text.match(/^\\s*/);\n      const numWhitespace = check ? check[0].length : 0;\n\n      if (options.pasteBeforeCursor) {\n        diff = new PositionDiff({\n          line: -numNewlines - 1,\n          character: numWhitespace,\n          type: PositionDiffType.ExactCharacter,\n        });\n      } else {\n        diff = new PositionDiff({\n          line: currentLineLength > 0 ? 1 : -numNewlines,\n          character: numWhitespace,\n          type: PositionDiffType.ExactCharacter,\n        });\n      }\n    } else if (!text.includes('\\n')) {\n      if (!position.isLineEnd()) {\n        let characterOffset: number;\n        if (registerMode === RegisterMode.BlockWise) {\n          characterOffset = options.pasteBeforeCursor ? -text.length : 1;\n        } else {\n          characterOffset = options.pasteBeforeCursor ? -1 : textToAdd.length;\n        }\n        diff = new PositionDiff({\n          character: characterOffset,\n        });\n      } else {\n        diff = new PositionDiff();\n      }\n    } else if (position.isLineEnd()) {\n      diff = new PositionDiff({\n        line: -numNewlines,\n        character: position.character,\n        type: PositionDiffType.ExactCharacter,\n      });\n    } else if (options.pasteBeforeCursor) {\n      diff = new PositionDiff({\n        line: -numNewlines,\n        character: position.character,\n        type: PositionDiffType.ExactCharacter,\n      });\n    } else {\n      diff = new PositionDiff({\n        character: 1,\n      });\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertText',\n      text: textToAdd,\n      position: whereToAddText,\n      diff,\n    });\n    let numNewlinesAfterPut = textToAdd.split('\\n').length;\n    if (registerMode === RegisterMode.LineWise) {\n      numNewlinesAfterPut--;\n    }\n    reportLinesChanged(numNewlinesAfterPut, vimState);\n\n    vimState.currentRegisterMode = registerMode;\n  }\n\n  private async execVisualBlockPaste(\n    block: string[],\n    position: Position,\n    vimState: VimState,\n    pasteBeforeCursor: boolean\n  ): Promise<void> {\n    if (pasteBeforeCursor) {\n      position = position.getRight();\n    }\n\n    // Add empty lines at the end of the document, if necessary.\n    const linesToAdd = Math.max(\n      0,\n      block.length - (vimState.document.lineCount - position.line) + 1\n    );\n    if (linesToAdd > 0) {\n      await TextEditor.insertAt(\n        vimState.editor,\n        Array(linesToAdd).join('\\n'),\n        new Position(\n          vimState.document.lineCount - 1,\n          TextEditor.getLineLength(vimState.document.lineCount - 1)\n        )\n      );\n    }\n\n    // paste the entire block.\n    for (let lineIndex = position.line; lineIndex < position.line + block.length; lineIndex++) {\n      const line = block[lineIndex - position.line];\n      const insertPos = new Position(\n        lineIndex,\n        Math.min(position.character, TextEditor.getLineLength(lineIndex))\n      );\n\n      await TextEditor.insertAt(vimState.editor, line, insertPos);\n    }\n\n    vimState.currentRegisterMode = RegisterMode.AscertainFromCurrentMode;\n  }\n\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    const register = await Register.get(vimState);\n    if (register === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister));\n      return;\n    }\n\n    await super.execCount(position, vimState);\n\n    if (\n      vimState.effectiveRegisterMode === RegisterMode.LineWise &&\n      vimState.recordedState.count > 0\n    ) {\n      const numNewlines =\n        (await PutCommand.getText(vimState, register, this.multicursorIndex)).split('\\n').length *\n        vimState.recordedState.count;\n\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: new PositionDiff({ line: -numNewlines + 1 }),\n        cursorIndex: this.multicursorIndex,\n      });\n\n      reportLinesChanged(numNewlines, vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass PutBeforeCommand extends BaseCommand {\n  public keys = ['P'];\n  public modes = [Mode.Normal];\n  canBeRepeatedWithDot = true;\n  runsOnceForEachCountPrefix = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new PutCommand(this.multicursorIndex).exec(position, vimState, {\n      pasteBeforeCursor: true,\n    });\n  }\n}\n\n@RegisterAction\nclass PutCommandVisual extends BaseCommand {\n  keys = [['p'], ['P']];\n  modes = [Mode.Visual];\n  runsOnceForEachCountPrefix = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = await Register.get(vimState);\n    if (register === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister));\n      return;\n    }\n    const putRegisterIsLineWise = register.registerMode === RegisterMode.LineWise;\n\n    let [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    if (vimState.currentMode === Mode.VisualLine) {\n      [start, end] = [start.getLineBegin(), end.getLineEnd()];\n    }\n\n    const oldMode = vimState.currentMode;\n    if (putRegisterIsLineWise) {\n      // If the to-be-inserted text is linewise, we have separate logic:\n      // first delete the selection, then insert\n      const replaceRegisterName = vimState.recordedState.registerName;\n      const replaceRegister = (await Register.get(vimState, replaceRegisterName))!;\n      vimState.recordedState.registerName = configuration.useSystemClipboard ? '*' : '\"';\n      // visual paste breaks for multicursor as of november 2020 because of the yank part\n      // so we disable it for now, see: https://github.com/VSCodeVim/Vim/issues/5493#issuecomment-731147687\n      const yank = !vimState.isMultiCursor;\n      await new operator.DeleteOperator(this.multicursorIndex).run(vimState, start, end, yank);\n      const deletedRegisterName = vimState.recordedState.registerName;\n      const deletedRegister = (await Register.get(vimState, deletedRegisterName))!;\n      if (replaceRegisterName === deletedRegisterName) {\n        Register.putByKey(replaceRegister.text, replaceRegisterName, replaceRegister.registerMode);\n      }\n      // To ensure that the put command knows this is\n      // a linewise register insertion in visual mode of\n      // characterwise, linewise\n      const resultMode = vimState.currentMode;\n      await vimState.setCurrentMode(oldMode);\n      vimState.recordedState.registerName = replaceRegisterName;\n      await new PutCommand(this.multicursorIndex).exec(start, vimState, {\n        pasteBeforeCursor: true,\n      });\n      await vimState.setCurrentMode(resultMode);\n      if (replaceRegisterName === deletedRegisterName) {\n        Register.putByKey(deletedRegister.text, deletedRegisterName, deletedRegister.registerMode);\n      }\n    } else {\n      // The reason we need to handle Delete and Yank separately is because of\n      // linewise mode. If we're in visualLine mode, then we want to copy\n      // linewise but not necessarily delete linewise.\n      await new PutCommand(this.multicursorIndex).exec(start, vimState, {\n        pasteBeforeCursor: true,\n      });\n      vimState.currentRegisterMode =\n        oldMode === Mode.VisualLine ? RegisterMode.LineWise : RegisterMode.CharacterWise;\n      vimState.recordedState.registerName = configuration.useSystemClipboard ? '*' : '\"';\n      // see above\n      if (!vimState.isMultiCursor) {\n        await new operator.YankOperator(this.multicursorIndex).run(vimState, start, end);\n      }\n      vimState.currentRegisterMode = RegisterMode.CharacterWise;\n      await new operator.DeleteOperator(this.multicursorIndex).run(\n        vimState,\n        start,\n        end.getLeftIfEOL(),\n        false\n      );\n      vimState.currentRegisterMode = RegisterMode.AscertainFromCurrentMode;\n    }\n  }\n}\n\n@RegisterAction\nclass PutCommandVisualLine extends BaseCommand {\n  keys = [['p'], ['P']];\n  modes = [Mode.VisualLine];\n  runsOnceForEachCountPrefix = false;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const isMultiLinePaste = vimState.recordedState.count > 1;\n    const replaceRegisterName = vimState.recordedState.registerName;\n    let oldText: RegisterContent = '';\n\n    if (isMultiLinePaste) {\n      oldText = (await Register.get(vimState, replaceRegisterName))!.text;\n      // Repeat register content requested number of times and save this into the register\n      Register.putByKey(\n        Array(vimState.recordedState.count).fill(oldText).join('\\n'),\n        replaceRegisterName,\n        RegisterMode.LineWise,\n        true\n      );\n      // Only put the register content once as it's repeated in the register\n      vimState.recordedState.count = 1;\n    }\n\n    // Call regular visual put command implementation\n    await new PutCommandVisual().exec(position, vimState);\n\n    // Restore register content\n    if (isMultiLinePaste) {\n      Register.putByKey(oldText, replaceRegisterName, RegisterMode.LineWise, true);\n    }\n  }\n}\n\n@RegisterAction\nclass GPutCommand extends BaseCommand {\n  keys = ['g', 'p'];\n  modes = [Mode.Normal, Mode.Visual];\n  runsOnceForEachCountPrefix = true;\n  canBeRepeatedWithDot = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new PutCommand(this.multicursorIndex).exec(position, vimState);\n  }\n\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    const register = await Register.get(vimState);\n    if (register === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister));\n      return;\n    }\n\n    let addedLinesCount: number;\n    if (register.text instanceof RecordedState) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register: vimState.recordedState.registerName,\n        replay: 'keystrokes',\n      });\n\n      return;\n    }\n    if (typeof register.text === 'object') {\n      // visual block mode\n      addedLinesCount = register.text.length * vimState.recordedState.count;\n    } else {\n      addedLinesCount = register.text.split('\\n').length;\n    }\n\n    await super.execCount(position, vimState);\n\n    if (vimState.effectiveRegisterMode === RegisterMode.LineWise) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: PositionDiff.newBOLDiff(addedLinesCount),\n        cursorIndex: this.multicursorIndex,\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass GPutCommandVisualLine extends PutCommandVisualLine {\n  keys = [\n    ['g', 'p'],\n    ['g', 'P'],\n  ];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const repeats = vimState.recordedState.count === 0 ? 1 : vimState.recordedState.count;\n    await super.exec(position, vimState);\n    // Vgp should place the cursor on the next line\n    if (vimState.effectiveRegisterMode === RegisterMode.LineWise) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: new PositionDiff({ line: repeats, character: 0 }),\n        cursorIndex: this.multicursorIndex,\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass GPutBeforeCommand extends BaseCommand {\n  keys = ['g', 'P'];\n  modes = [Mode.Normal];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new PutCommand(this.multicursorIndex).exec(position, vimState, {\n      pasteBeforeCursor: true,\n    });\n    const register = await Register.get(vimState);\n    if (register === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister));\n      return;\n    }\n\n    let addedLinesCount: number;\n    if (register.text instanceof RecordedState) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register: vimState.recordedState.registerName,\n        replay: 'keystrokes',\n      });\n\n      return;\n    } else if (typeof register.text === 'object') {\n      // visual block mode\n      addedLinesCount = register.text.length * vimState.recordedState.count;\n    } else {\n      addedLinesCount = register.text.split('\\n').length;\n    }\n\n    if (vimState.effectiveRegisterMode === RegisterMode.LineWise) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: PositionDiff.newBOLDiff(addedLinesCount),\n        cursorIndex: this.multicursorIndex,\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass PutWithIndentCommand extends BaseCommand {\n  keys = [']', 'p'];\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  runsOnceForEachCountPrefix = true;\n  canBeRepeatedWithDot = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new PutCommand(this.multicursorIndex).exec(position, vimState, { adjustIndent: true });\n  }\n}\n\n@RegisterAction\nclass PutBeforeWithIndentCommand extends BaseCommand {\n  keys = [\n    ['[', 'P'],\n    [']', 'P'],\n    ['[', 'p'],\n  ];\n  modes = [Mode.Normal];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await new PutCommand(this.multicursorIndex).exec(position, vimState, {\n      pasteBeforeCursor: true,\n      adjustIndent: true,\n    });\n\n    if (vimState.effectiveRegisterMode === RegisterMode.LineWise) {\n      vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n        vimState.document,\n        vimState.cursorStopPosition.getUp().line\n      );\n    }\n  }\n}\n","import { Position } from 'vscode';\nimport { PositionDiff } from '../../common/motion/position';\nimport { Range } from '../../common/motion/range';\nimport { Mode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { RegisterAction, BaseCommand } from '../base';\n\n@RegisterAction\nclass ExitReplaceMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.replaceState!.timesToRepeat;\n    let textToAdd = '';\n\n    for (let i = 1; i < timesToRepeat; i++) {\n      textToAdd += vimState.replaceState!.newChars.join('');\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertText',\n      text: textToAdd,\n      position,\n      diff: new PositionDiff({ character: -1 }),\n    });\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ReplaceModeToInsertMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = ['<Insert>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nclass BackspaceInReplaceMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = [['<BS>'], ['<C-h>']];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const replaceState = vimState.replaceState!;\n    if (position.isBeforeOrEqual(replaceState.replaceCursorStartPosition)) {\n      // If you backspace before the beginning of where you started to replace, just move the cursor back.\n\n      vimState.cursorStopPosition = position.getLeft();\n      vimState.cursorStartPosition = position.getLeft();\n    } else if (\n      position.line > replaceState.replaceCursorStartPosition.line ||\n      position.character > replaceState.originalChars.length\n    ) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteText',\n        position,\n      });\n    } else {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: replaceState.originalChars[position.character - 1],\n        range: new Range(position.getLeft(), position),\n        diff: new PositionDiff({ character: -1 }),\n      });\n    }\n\n    replaceState.newChars.pop();\n  }\n}\n\n@RegisterAction\nclass ReplaceInReplaceMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = ['<character>'];\n  canBeRepeatedWithDot = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const char = this.keysPressed[0];\n    const replaceState = vimState.replaceState!;\n\n    if (!position.isLineEnd() && char !== '\\n') {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: char,\n        range: new Range(position, position.getRight()),\n        diff: new PositionDiff({ character: 1 }),\n      });\n    } else {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'insertText',\n        text: char,\n        position,\n      });\n    }\n\n    replaceState.newChars.push(char);\n  }\n}\n","import * as _ from 'lodash';\nimport { Position, Selection } from 'vscode';\nimport { configuration } from '../../configuration/configuration';\nimport { VimError, ErrorCode } from '../../error';\nimport { Mode } from '../../mode/mode';\nimport { Register } from '../../register/register';\nimport { globalState } from '../../state/globalState';\nimport { SearchDirection, SearchState } from '../../state/searchState';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\nimport { TextEditor } from '../../textEditor';\nimport { reportSearch } from '../../util/statusBarTextUtils';\nimport { RegisterAction, BaseCommand } from '../base';\n\n/**\n * Search for the word under the cursor; used by [g]* and [g]#\n */\nasync function searchCurrentWord(\n  position: Position,\n  vimState: VimState,\n  direction: SearchDirection,\n  isExact: boolean\n): Promise<void> {\n  let currentWord = TextEditor.getWord(vimState.document, position);\n\n  if (currentWord) {\n    if (/\\W/.test(currentWord[0]) || /\\W/.test(currentWord[currentWord.length - 1])) {\n      // TODO: this kind of sucks. JS regex does not consider the boundary between a special\n      // character and whitespace to be a \"word boundary\", so we can't easily do an exact search.\n      isExact = false;\n    }\n\n    if (isExact) {\n      currentWord = _.escapeRegExp(currentWord);\n    }\n    // If the search is going left then use `getWordLeft()` on position to start\n    // at the beginning of the word. This ensures that any matches happen\n    // outside of the currently selected word.\n    const searchStartCursorPosition =\n      direction === SearchDirection.Backward\n        ? vimState.cursorStopPosition.getWordLeft(true)\n        : vimState.cursorStopPosition;\n\n    await createSearchStateAndMoveToMatch({\n      needle: currentWord,\n      vimState,\n      direction,\n      isExact,\n      searchStartCursorPosition,\n    });\n  }\n\n  StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NoStringUnderCursor));\n}\n\n/**\n * Search for the word under the cursor; used by [g]* and [g]# in visual mode when `visualstar` is enabled\n */\nasync function searchCurrentSelection(vimState: VimState, direction: SearchDirection) {\n  const selection = vimState.editor.selection;\n  const end = new Position(selection.end.line, selection.end.character);\n  const currentSelection = vimState.document.getText(selection.with(selection.start, end));\n\n  // Go back to Normal mode, otherwise the selection grows to the next match.\n  await vimState.setCurrentMode(Mode.Normal);\n\n  // If the search is going left then use `getLeft()` on the selection start.\n  // If going right then use `getRight()` on the selection end. This ensures\n  // that any matches happen outside of the currently selected word.\n  const searchStartCursorPosition =\n    direction === SearchDirection.Backward\n      ? vimState.lastVisualSelection!.start.getLeft()\n      : vimState.lastVisualSelection!.end.getRight();\n\n  await createSearchStateAndMoveToMatch({\n    needle: currentSelection,\n    vimState,\n    direction,\n    isExact: false,\n    searchStartCursorPosition,\n  });\n}\n\n/**\n * Used by [g]* and [g]#\n */\nasync function createSearchStateAndMoveToMatch(args: {\n  needle?: string | undefined;\n  vimState: VimState;\n  direction: SearchDirection;\n  isExact: boolean;\n  searchStartCursorPosition: Position;\n}): Promise<void> {\n  const { needle, vimState, isExact } = args;\n\n  if (needle === undefined || needle.length === 0) {\n    return;\n  }\n\n  const searchString = isExact ? `\\\\b${needle}\\\\b` : needle;\n\n  // Start a search for the given term.\n  globalState.searchState = new SearchState(\n    args.direction,\n    vimState.cursorStopPosition,\n    searchString,\n    { isRegex: isExact, ignoreSmartcase: true },\n    vimState.currentMode\n  );\n  Register.putByKey(globalState.searchState.searchString, '/', undefined, true);\n  globalState.addSearchStateToHistory(globalState.searchState);\n\n  // Turn one of the highlighting flags back on (turned off with :nohl)\n  globalState.hl = true;\n\n  const nextMatch = globalState.searchState.getNextSearchMatchPosition(\n    vimState.editor,\n    args.searchStartCursorPosition\n  );\n  if (nextMatch) {\n    vimState.cursorStopPosition = nextMatch.pos;\n\n    reportSearch(\n      nextMatch.index,\n      globalState.searchState.getMatchRanges(vimState.editor).length,\n      vimState\n    );\n  } else {\n    StatusBar.displayError(\n      vimState,\n      VimError.fromCode(\n        args.direction === SearchDirection.Forward\n          ? ErrorCode.SearchHitBottom\n          : ErrorCode.SearchHitTop,\n        globalState.searchState.searchString\n      )\n    );\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordExactForward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['*'];\n  isMotion = true;\n  runsOnceForEachCountPrefix = true;\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Forward, true);\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordForward extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['g', '*'];\n  isMotion = true;\n  runsOnceForEachCountPrefix = true;\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Forward, false);\n  }\n}\n\n@RegisterAction\nclass CommandSearchVisualForward extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['*'];\n  isMotion = true;\n  runsOnceForEachCountPrefix = true;\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (configuration.visualstar) {\n      await searchCurrentSelection(vimState, SearchDirection.Forward);\n    } else {\n      await searchCurrentWord(position, vimState, SearchDirection.Forward, true);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordExactBackward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['#'];\n  isMotion = true;\n  runsOnceForEachCountPrefix = true;\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Backward, true);\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordBackward extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['g', '#'];\n  isMotion = true;\n  runsOnceForEachCountPrefix = true;\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Backward, false);\n  }\n}\n\n@RegisterAction\nclass CommandSearchVisualBackward extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['#'];\n  isMotion = true;\n  runsOnceForEachCountPrefix = true;\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    if (configuration.visualstar) {\n      await searchCurrentSelection(vimState, SearchDirection.Backward);\n    } else {\n      await searchCurrentWord(position, vimState, SearchDirection.Backward, true);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandSearchForwards extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['/'];\n  isMotion = true;\n  isJump = true;\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    globalState.searchState = new SearchState(\n      SearchDirection.Forward,\n      vimState.cursorStopPosition,\n      '',\n      { isRegex: true },\n      vimState.currentMode\n    );\n    await vimState.setCurrentMode(Mode.SearchInProgressMode);\n\n    // Reset search history index\n    globalState.searchStateIndex = globalState.searchStatePrevious.length;\n  }\n}\n\n@RegisterAction\nclass CommandSearchBackwards extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['?'];\n  isMotion = true;\n  isJump = true;\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    globalState.searchState = new SearchState(\n      SearchDirection.Backward,\n      vimState.cursorStopPosition,\n      '',\n      { isRegex: true },\n      vimState.currentMode\n    );\n    await vimState.setCurrentMode(Mode.SearchInProgressMode);\n\n    // Reset search history index\n    globalState.searchStateIndex = globalState.searchStatePrevious.length;\n  }\n}\n\nasync function selectLastSearchWord(vimState: VimState, direction: SearchDirection): Promise<void> {\n  const searchState = globalState.searchState;\n  if (!searchState || searchState.searchString === '') {\n    return;\n  }\n\n  const newSearchState = new SearchState(\n    direction,\n    vimState.cursorStopPosition,\n    searchState.searchString,\n    { isRegex: true },\n    vimState.currentMode\n  );\n\n  let result:\n    | {\n        start: Position;\n        end: Position;\n        match: boolean;\n        index: number;\n      }\n    | undefined;\n\n  // At first, try to search for current word, and stop searching if matched.\n  // Try to search for the next word if not matched or\n  // if the cursor is at the end of a match string in visual-mode.\n  result = newSearchState.getSearchMatchRangeOf(vimState.editor, vimState.cursorStopPosition);\n  if (\n    vimState.currentMode === Mode.Visual &&\n    vimState.cursorStopPosition.isEqual(result.end.getLeftThroughLineBreaks())\n  ) {\n    result.match = false;\n  }\n\n  if (!result.match) {\n    // Try to search for the next word\n    result = newSearchState.getNextSearchMatchRange(vimState.editor, vimState.cursorStopPosition);\n    if (!result?.match) {\n      return; // no match...\n    }\n  }\n\n  vimState.cursorStartPosition =\n    vimState.currentMode === Mode.Normal ? result.start : vimState.cursorStopPosition;\n  vimState.cursorStopPosition = result.end.getLeftThroughLineBreaks(); // end is exclusive\n\n  // Move the cursor, this is a bit hacky...\n  vimState.editor.selection = new Selection(\n    vimState.cursorStartPosition,\n    vimState.cursorStopPosition\n  );\n\n  reportSearch(result.index, searchState.getMatchRanges(vimState.editor).length, vimState);\n\n  await vimState.setCurrentMode(Mode.Visual);\n}\n\n@RegisterAction\nclass CommandSelectNextLastSearchWord extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  keys = ['g', 'n'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await selectLastSearchWord(vimState, SearchDirection.Forward);\n  }\n}\n\n@RegisterAction\nclass CommandSelectPreviousLastSearchWord extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  keys = ['g', 'N'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await selectLastSearchWord(vimState, SearchDirection.Backward);\n  }\n}\n","import './base';\nimport './operator';\nimport './motion';\nimport '../textobject/textobject';\n\n// commands\nimport './commands/insert';\nimport './commands/replace';\nimport './commands/actions';\nimport './commands/commandLine';\nimport './commands/search';\n","import * as vscode from 'vscode';\n\nimport { ChangeOperator, DeleteOperator, YankOperator } from './operator';\nimport { CursorMoveByUnit, CursorMovePosition, TextEditor } from './../textEditor';\nimport { Mode } from './../mode/mode';\nimport { PairMatcher } from './../common/matching/matcher';\nimport { QuoteMatcher } from './../common/matching/quoteMatcher';\nimport { RegisterAction } from './base';\nimport { RegisterMode } from './../register/register';\nimport { ReplaceState } from './../state/replaceState';\nimport { TagMatcher } from './../common/matching/tagMatcher';\nimport { VimState } from './../state/vimState';\nimport { configuration } from './../configuration/configuration';\nimport { shouldWrapKey } from './wrapping';\nimport { VimError, ErrorCode } from '../error';\nimport { BaseMovement, SelectionType, IMovement, isIMovement, failedMovement } from './baseMotion';\nimport { globalState } from '../state/globalState';\nimport { reportSearch } from '../util/statusBarTextUtils';\nimport { SneakForward, SneakBackward } from './plugins/sneak';\nimport { Notation } from '../configuration/notation';\nimport { SearchDirection } from '../state/searchState';\nimport { StatusBar } from '../statusBar';\nimport { clamp } from '../util/util';\nimport { getCurrentParagraphBeginning, getCurrentParagraphEnd } from '../textobject/paragraph';\nimport { Position } from 'vscode';\nimport { sorted } from '../common/motion/position';\n\n/**\n * A movement is something like 'h', 'k', 'w', 'b', 'gg', etc.\n */\n\nexport abstract class ExpandingSelection extends BaseMovement {\n  protected selectionType = SelectionType.Expanding;\n\n  protected adjustPosition(position: Position, result: IMovement, lastIteration: boolean) {\n    if (!lastIteration) {\n      position = result.stop;\n    }\n    return position;\n  }\n}\n\nabstract class MoveByScreenLine extends BaseMovement {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  abstract movementType: CursorMovePosition;\n  by: CursorMoveByUnit;\n  value: number = 1;\n\n  public async execAction(position: Position, vimState: VimState) {\n    return this.execActionWithCount(position, vimState, 1);\n  }\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const multicursorIndex = this.multicursorIndex ?? 0;\n\n    if (multicursorIndex === 0) {\n      if (vimState.currentMode === Mode.Visual) {\n        // If we change the `vimState.editor.selections` directly with the forEach\n        // for some reason vscode doesn't update them. But doing it this way does\n        // update vscode's selections.\n        const selections = vimState.editor.selections;\n        selections.forEach((s, i) => {\n          if (s.active.isAfter(s.anchor)) {\n            // The selection is on the right side of the cursor, while our representation\n            // considers the cursor to be the left edge, so we need to move the selection\n            // to the right place before executing the 'cursorMove' command.\n            const active = s.active.getLeftThroughLineBreaks();\n            vimState.editor.selections[i] = new vscode.Selection(s.anchor, active);\n          }\n        });\n        vimState.editor.selections = selections;\n      }\n\n      // When we have multicursors and run a 'cursorMove' command, vscode applies that command\n      // to all cursors at the same time. So we should only run it once.\n      await vscode.commands.executeCommand('cursorMove', {\n        to: this.movementType,\n        select: vimState.currentMode !== Mode.Normal,\n        by: this.by,\n        value: this.value * count,\n      });\n    }\n\n    if (vimState.currentMode === Mode.Normal) {\n      return vimState.editor.selections[multicursorIndex].active;\n    } else {\n      /**\n       * cursorMove command is handling the selection for us.\n       * So we are not following our design principal (do no real movement inside an action) here.\n       */\n      if (!vimState.editor.selections[multicursorIndex]) {\n        // Vscode selections no longer have the same amount of cursors as we do. This means that\n        // two or more selections combined into one. In this case we return these cursors as they\n        // were with the removed flag so that they can be removed.\n        return {\n          start: vimState.cursorStartPosition,\n          stop: vimState.cursorStopPosition,\n          removed: true,\n        };\n      }\n\n      let start = vimState.editor.selections[multicursorIndex].anchor;\n      const stop = vimState.editor.selections[multicursorIndex].active;\n\n      // If we are moving up we need to keep getting the left of anchor/start because vscode is\n      // to the right of the character in order to include it but our positions are always on the\n      // left side of the character.\n      // Also when we switch from being before anchor to being after anchor we need to move\n      // the anchor/start to the left as well in order to include the character.\n      if (\n        (start.isAfter(stop) &&\n          vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) ||\n        (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition) &&\n          start.isBeforeOrEqual(stop))\n      ) {\n        start = start.getLeft();\n      }\n\n      return { start, stop };\n    }\n  }\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<IMovement> {\n    const multicursorIndex = this.multicursorIndex ?? 0;\n    if (multicursorIndex === 0) {\n      // When we have multicursors and run a 'cursorMove' command, vscode applies that command\n      // to all cursors at the same time. So we should only run it once.\n      await vscode.commands.executeCommand('cursorMove', {\n        to: this.movementType,\n        select: true,\n        by: this.by,\n        value: this.value,\n      });\n    }\n\n    if (!vimState.editor.selections[multicursorIndex]) {\n      // Vscode selections no longer have the same amount of cursors as we do. This means that\n      // two or more selections combined into one. In this case we return these cursors as they\n      // were with the removed flag so that they can be removed.\n      return {\n        start: vimState.cursorStartPosition,\n        stop: vimState.cursorStopPosition,\n        removed: true,\n      };\n    }\n\n    return {\n      start: vimState.editor.selections[multicursorIndex].start,\n      stop: vimState.editor.selections[multicursorIndex].end,\n    };\n  }\n}\n\nclass MoveUpByScreenLine extends MoveByScreenLine {\n  movementType: CursorMovePosition = 'up';\n  by: CursorMoveByUnit = 'wrappedLine';\n  value = 1;\n}\n\nclass MoveDownByScreenLine extends MoveByScreenLine {\n  movementType: CursorMovePosition = 'down';\n  by: CursorMoveByUnit = 'wrappedLine';\n  value = 1;\n}\n\nabstract class MoveByScreenLineMaintainDesiredColumn extends MoveByScreenLine {\n  preservesDesiredColumn() {\n    return true;\n  }\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    const prevDesiredColumn = vimState.desiredColumn;\n    const prevLine = vimState.editor.selection.active.line;\n\n    if (vimState.currentMode !== Mode.Normal) {\n      /**\n       * As VIM and VSCode handle the end of selection index a little\n       * differently we need to sometimes move the cursor at the end\n       * of the selection back by a character.\n       */\n      const start = vimState.editor.selection.start;\n      if (\n        (this.movementType === 'down' && position.line > start.line) ||\n        (this.movementType === 'up' && position.line < prevLine)\n      ) {\n        await vscode.commands.executeCommand('cursorMove', {\n          to: 'left',\n          select: true,\n          by: 'character',\n          value: 1,\n        });\n      }\n    }\n\n    await vscode.commands.executeCommand('cursorMove', {\n      to: this.movementType,\n      select: vimState.currentMode !== Mode.Normal,\n      by: this.by,\n      value: this.value,\n    });\n\n    if (vimState.currentMode === Mode.Normal) {\n      let returnedPos = vimState.editor.selection.active;\n      if (prevLine !== returnedPos.line) {\n        returnedPos = returnedPos.withColumn(prevDesiredColumn);\n      }\n      return returnedPos;\n    } else {\n      /**\n       * cursorMove command is handling the selection for us.\n       * So we are not following our design principal (do no real movement inside an action) here.\n       */\n      let start = vimState.editor.selection.start;\n      let stop = vimState.editor.selection.end;\n      const curPos = vimState.editor.selection.active;\n\n      // We want to swap the cursor start stop positions based on which direction we are moving, up or down\n      if (start.isEqual(curPos) && !start.isEqual(stop)) {\n        [start, stop] = [stop, start];\n        if (prevLine !== start.line) {\n          start = start.getLeft();\n        }\n      }\n\n      if (position.line !== stop.line) {\n        stop = stop.withColumn(prevDesiredColumn);\n      }\n\n      return { start, stop };\n    }\n  }\n}\n\nclass MoveDownByScreenLineMaintainDesiredColumn extends MoveByScreenLineMaintainDesiredColumn {\n  movementType: CursorMovePosition = 'down';\n  by: CursorMoveByUnit = 'wrappedLine';\n  value = 1;\n}\n\nclass MoveUpByScreenLineMaintainDesiredColumn extends MoveByScreenLineMaintainDesiredColumn {\n  movementType: CursorMovePosition = 'up';\n  by: CursorMoveByUnit = 'wrappedLine';\n  value = 1;\n}\n\nclass MoveDownFoldFix extends MoveByScreenLineMaintainDesiredColumn {\n  movementType: CursorMovePosition = 'down';\n  by: CursorMoveByUnit = 'line';\n  value = 1;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    if (position.line >= vimState.document.lineCount - 1) {\n      return position;\n    }\n    let t: Position | IMovement = position;\n    let prevLine: number = position.line;\n    let prevChar: number = position.character;\n    const prevDesiredColumn = vimState.desiredColumn;\n    const moveDownByScreenLine = new MoveDownByScreenLine();\n    do {\n      t = await moveDownByScreenLine.execAction(t, vimState);\n      t = t instanceof Position ? t : t.stop;\n      const lineChanged = prevLine !== t.line;\n      // wrappedLine movement goes to eol character only when at the last line\n      // thus a column change on wrappedLine movement represents a visual last line\n      const colChanged = prevChar !== t.character;\n      if (lineChanged || !colChanged) {\n        break;\n      }\n      prevChar = t.character;\n      prevLine = t.line;\n    } while (t.line === position.line);\n    // fix column change at last line caused by wrappedLine movement\n    // causes cursor lag and flicker if a large repeat prefix is given to movement\n    if (t.character !== prevDesiredColumn) {\n      t = new Position(t.line, prevDesiredColumn);\n    }\n    return t;\n  }\n}\n\n@RegisterAction\nclass MoveDown extends BaseMovement {\n  keys = [['j'], ['<down>']];\n  preservesDesiredColumn() {\n    return true;\n  }\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    if (configuration.foldfix && vimState.currentMode !== Mode.VisualBlock) {\n      return new MoveDownFoldFix().execAction(position, vimState);\n    }\n\n    if (position.line < vimState.document.lineCount - 1) {\n      return position.with({ character: vimState.desiredColumn }).getDown();\n    } else {\n      return position;\n    }\n  }\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getDown();\n  }\n}\n\n@RegisterAction\nclass MoveUp extends BaseMovement {\n  keys = [['k'], ['<up>']];\n  preservesDesiredColumn() {\n    return true;\n  }\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    if (configuration.foldfix && vimState.currentMode !== Mode.VisualBlock) {\n      return new MoveUpFoldFix().execAction(position, vimState);\n    }\n\n    if (position.line > 0) {\n      return position.with({ character: vimState.desiredColumn }).getUp();\n    } else {\n      return position;\n    }\n  }\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getUp();\n  }\n}\n\n@RegisterAction\nclass MoveUpFoldFix extends MoveByScreenLineMaintainDesiredColumn {\n  movementType: CursorMovePosition = 'up';\n  by: CursorMoveByUnit = 'line';\n  value = 1;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    if (position.line === 0) {\n      return position;\n    }\n    let t: Position | IMovement;\n    const prevDesiredColumn = vimState.desiredColumn;\n    const moveUpByScreenLine = new MoveUpByScreenLine();\n    do {\n      t = await moveUpByScreenLine.execAction(position, vimState);\n      t = t instanceof Position ? t : t.stop;\n    } while (t.line === position.line);\n    // fix column change at last line caused by wrappedLine movement\n    // causes cursor lag and flicker if a large repeat prefix is given to movement\n    if (t.character !== prevDesiredColumn) {\n      t = new Position(t.line, prevDesiredColumn);\n    }\n    return t;\n  }\n}\n\n@RegisterAction\nexport class ArrowsInInsertMode extends BaseMovement {\n  modes = [Mode.Insert];\n  keys = [['<up>'], ['<down>'], ['<left>'], ['<right>']];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    // we are in Insert Mode and arrow keys will clear all other actions except the first action, which enters Insert Mode.\n    // Please note the arrow key movement can be repeated while using `.` but it can't be repeated when using `<C-A>` in Insert Mode.\n    const firstAction = vimState.recordedState.actionsRun.shift();\n    const lastAction = vimState.recordedState.actionsRun.pop();\n    vimState.recordedState.actionsRun = [];\n    if (firstAction) {\n      vimState.recordedState.actionsRun.push(firstAction);\n    }\n    if (lastAction) {\n      vimState.recordedState.actionsRun.push(lastAction);\n    }\n    // TODO: assert vimState.recordedState.actionsRun.length === 2?\n\n    let newPosition: Position;\n    switch (this.keysPressed[0]) {\n      case '<up>':\n        newPosition = (await new MoveUp().execAction(position, vimState)) as Position;\n        break;\n      case '<down>':\n        newPosition = (await new MoveDown().execAction(position, vimState)) as Position;\n        break;\n      case '<left>':\n        newPosition = await new MoveLeft(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<right>':\n        newPosition = await new MoveRight(this.keysPressed).execAction(position, vimState);\n        break;\n      default:\n        throw new Error(`Unexpected 'arrow' key: ${this.keys[0]}`);\n    }\n    vimState.replaceState = new ReplaceState(vimState, newPosition);\n    return newPosition;\n  }\n}\n\n@RegisterAction\nclass ArrowsInReplaceMode extends BaseMovement {\n  modes = [Mode.Replace];\n  keys = [['<up>'], ['<down>'], ['<left>'], ['<right>']];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    let newPosition: Position = position;\n\n    switch (this.keysPressed[0]) {\n      case '<up>':\n        newPosition = (await new MoveUp().execAction(position, vimState)) as Position;\n        break;\n      case '<down>':\n        newPosition = (await new MoveDown().execAction(position, vimState)) as Position;\n        break;\n      case '<left>':\n        newPosition = await new MoveLeft(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<right>':\n        newPosition = await new MoveRight(this.keysPressed).execAction(position, vimState);\n        break;\n      default:\n        throw new Error(`Unexpected 'arrow' key: ${this.keys[0]}`);\n    }\n    vimState.replaceState = new ReplaceState(vimState, newPosition);\n    return newPosition;\n  }\n}\n\n@RegisterAction\nclass CommandNextSearchMatch extends BaseMovement {\n  keys = ['n'];\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const searchState = globalState.searchState;\n\n    if (!searchState || searchState.searchString === '') {\n      return position;\n    }\n\n    // Turn one of the highlighting flags back on (turned off with :nohl)\n    globalState.hl = true;\n\n    if (searchState.getMatchRanges(vimState.editor).length === 0) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.PatternNotFound, searchState.searchString)\n      );\n      return position;\n    }\n\n    // we have to handle a special case here: searching for $ or \\n,\n    // which we approximate by positionIsEOL. In that case (but only when searching forward)\n    // we need to \"offset\" by getRight for searching the next match, otherwise we get stuck.\n    const searchForward = searchState.searchDirection === SearchDirection.Forward;\n    const positionIsEOL = position.getRight().isEqual(position.getLineEnd());\n    const nextMatch =\n      positionIsEOL && searchForward\n        ? searchState.getNextSearchMatchPosition(vimState.editor, position.getRight())\n        : searchState.getNextSearchMatchPosition(vimState.editor, position);\n\n    if (!nextMatch) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(\n          searchState.searchDirection === SearchDirection.Forward\n            ? ErrorCode.SearchHitBottom\n            : ErrorCode.SearchHitTop,\n          searchState.searchString\n        )\n      );\n      return position;\n    }\n\n    reportSearch(nextMatch.index, searchState.getMatchRanges(vimState.editor).length, vimState);\n\n    return nextMatch.pos;\n  }\n}\n\n@RegisterAction\nclass CommandPreviousSearchMatch extends BaseMovement {\n  keys = ['N'];\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const searchState = globalState.searchState;\n\n    if (!searchState || searchState.searchString === '') {\n      return position;\n    }\n\n    // Turn one of the highlighting flags back on (turned off with :nohl)\n    globalState.hl = true;\n\n    if (searchState.getMatchRanges(vimState.editor).length === 0) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.PatternNotFound, searchState.searchString)\n      );\n      return position;\n    }\n\n    const searchForward = searchState.searchDirection === SearchDirection.Forward;\n    const positionIsEOL = position.getRight().isEqual(position.getLineEnd());\n\n    // see implementation of n, above.\n    const prevMatch =\n      positionIsEOL && !searchForward\n        ? searchState.getNextSearchMatchPosition(\n            vimState.editor,\n            position.getRight(),\n            SearchDirection.Backward\n          )\n        : searchState.getNextSearchMatchPosition(\n            vimState.editor,\n            position,\n            SearchDirection.Backward\n          );\n\n    if (!prevMatch) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(\n          searchState.searchDirection === SearchDirection.Forward\n            ? ErrorCode.SearchHitTop\n            : ErrorCode.SearchHitBottom,\n          searchState.searchString\n        )\n      );\n      return position;\n    }\n\n    reportSearch(prevMatch.index, searchState.getMatchRanges(vimState.editor).length, vimState);\n\n    return prevMatch.pos;\n  }\n}\n\nenum VisualMark {\n  SelectionStart,\n  SelectionEnd,\n}\nabstract class MarkMovementVisual extends BaseMovement {\n  isJump = true;\n  registerMode: RegisterMode;\n  modes = [Mode.Normal];\n  mark: VisualMark;\n\n  private startOrEnd(lastVisualSelection: {\n    start: vscode.Position;\n    end: vscode.Position;\n  }): Position {\n    // marks from vimstate are sorted by direction of selection (moving forward vs backwards).\n    // must sort to document order\n    const [start, end] = sorted(lastVisualSelection.start, lastVisualSelection.end);\n    return this.mark === VisualMark.SelectionStart ? start : end;\n  }\n\n  private inLineCorrection(document: vscode.TextDocument, position: Position): Position {\n    // for ' mark, we must go to BOL.\n    // for `> mark, we must correct by one char left\n    return this.registerMode === RegisterMode.LineWise\n      ? position.getLineBeginRespectingIndent(document)\n      : this.mark === VisualMark.SelectionEnd\n      ? position.getLeft()\n      : position;\n  }\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    vimState.currentRegisterMode = this.registerMode;\n\n    if (vimState.lastVisualSelection !== undefined) {\n      // todo: wait for pipe operator ;-)\n      return this.inLineCorrection(\n        vimState.document,\n        this.startOrEnd(vimState.lastVisualSelection)\n      );\n    }\n\n    throw VimError.fromCode(ErrorCode.MarkNotSet);\n  }\n}\n\n@RegisterAction\nclass MarkMovementVisualStart extends MarkMovementVisual {\n  keys = ['`', '<'];\n  registerMode = RegisterMode.CharacterWise;\n  mark = VisualMark.SelectionStart;\n}\n\n@RegisterAction\nclass MarkMovementVisualEnd extends MarkMovementVisual {\n  keys = ['`', '>'];\n  registerMode = RegisterMode.CharacterWise;\n  mark = VisualMark.SelectionEnd;\n}\n\n@RegisterAction\nclass MarkMovementVisualStartLine extends MarkMovementVisual {\n  keys = [\"'\", '<'];\n  registerMode = RegisterMode.LineWise;\n  mark = VisualMark.SelectionStart;\n}\n\n@RegisterAction\nclass MarkMovementVisualEndLine extends MarkMovementVisual {\n  keys = [\"'\", '>'];\n  registerMode = RegisterMode.LineWise;\n  mark = VisualMark.SelectionEnd;\n}\n\n@RegisterAction\nexport class MarkMovementBOL extends BaseMovement {\n  keys = [\"'\", '<character>'];\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const markName = this.keysPressed[1];\n    const mark = vimState.historyTracker.getMark(markName);\n\n    if (mark === undefined) {\n      throw VimError.fromCode(ErrorCode.MarkNotSet);\n    }\n\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    if (mark.isUppercaseMark && mark.editor !== undefined) {\n      await ensureEditorIsActive(mark.editor);\n    }\n\n    return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, mark.position.line);\n  }\n}\n\n@RegisterAction\nexport class MarkMovement extends BaseMovement {\n  keys = ['`', '<character>'];\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const markName = this.keysPressed[1];\n    const mark = vimState.historyTracker.getMark(markName);\n\n    if (mark === undefined) {\n      throw VimError.fromCode(ErrorCode.MarkNotSet);\n    }\n\n    if (mark.isUppercaseMark && mark.editor !== undefined) {\n      await ensureEditorIsActive(mark.editor);\n    }\n\n    return mark.position;\n  }\n}\n\nasync function ensureEditorIsActive(editor: vscode.TextEditor) {\n  if (editor !== vscode.window.activeTextEditor) {\n    await vscode.window.showTextDocument(editor.document);\n  }\n}\n\n@RegisterAction\nexport class MoveLeft extends BaseMovement {\n  keys = [['h'], ['<left>'], ['<BS>'], ['<C-BS>'], ['<S-BS>']];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return shouldWrapKey(vimState.currentMode, this.keysPressed[0])\n      ? position.getLeftThroughLineBreaks(\n          [Mode.Insert, Mode.Replace].includes(vimState.currentMode)\n        )\n      : position.getLeft();\n  }\n}\n\n@RegisterAction\nclass MoveRight extends BaseMovement {\n  keys = [['l'], ['<right>'], [' ']];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return shouldWrapKey(vimState.currentMode, this.keysPressed[0])\n      ? position.getRightThroughLineBreaks(\n          [Mode.Insert, Mode.Replace].includes(vimState.currentMode)\n        )\n      : position.getRight();\n  }\n}\n\n@RegisterAction\nclass MoveDownNonBlank extends BaseMovement {\n  keys = ['+'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      position.getDown(Math.max(count, 1)).line\n    );\n  }\n}\n\n@RegisterAction\nclass MoveUpNonBlank extends BaseMovement {\n  keys = ['-'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      position.getUp(Math.max(count, 1)).line\n    );\n  }\n}\n\n@RegisterAction\nclass MoveDownUnderscore extends BaseMovement {\n  keys = ['_'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    return TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      position.getDown(Math.max(count - 1, 0)).line\n    );\n  }\n}\n\n@RegisterAction\nclass MoveToColumn extends BaseMovement {\n  keys = ['|'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    return new Position(position.line, Math.max(0, count - 1));\n  }\n}\n\n/**\n * Returns the Postion of the next instance of `char` on the line\n * @param char character to look for\n * @param count number of times to look\n * @param direction direction to look in\n */\nfunction findHelper(\n  vimState: VimState,\n  start: Position,\n  char: string,\n  count: number,\n  direction: 'forward' | 'backward'\n): Position | undefined {\n  const line = vimState.document.lineAt(start);\n\n  let index = start.character;\n  while (count > 0 && index >= 0) {\n    if (direction === 'forward') {\n      index = line.text.indexOf(char, index + 1);\n    } else {\n      index = line.text.lastIndexOf(char, index - 1);\n    }\n    count--;\n  }\n\n  if (index >= 0) {\n    return new Position(start.line, index);\n  }\n\n  return undefined;\n}\n\n@RegisterAction\nclass MoveFindForward extends BaseMovement {\n  keys = ['f', '<character>'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    if (configuration.sneakReplacesF) {\n      const pos = await new SneakForward(\n        this.keysPressed.concat('\\n'),\n        this.isRepeat\n      ).execActionWithCount(position, vimState, count);\n      if (vimState.recordedState.operator && !isIMovement(pos)) {\n        return pos.getRight();\n      }\n\n      return pos;\n    }\n\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    let result = findHelper(vimState, position, toFind, count, 'forward');\n\n    vimState.lastSemicolonRepeatableMovement = new MoveFindForward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveFindBackward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (vimState.recordedState.operator) {\n      result = result.getRight();\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveFindBackward extends BaseMovement {\n  keys = ['F', '<character>'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    if (configuration.sneakReplacesF) {\n      return new SneakBackward(this.keysPressed.concat('\\n'), this.isRepeat).execActionWithCount(\n        position,\n        vimState,\n        count\n      );\n    }\n\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    const result = findHelper(vimState, position, toFind, count, 'backward');\n\n    vimState.lastSemicolonRepeatableMovement = new MoveFindBackward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveFindForward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    return result;\n  }\n}\n\nfunction tilHelper(\n  vimState: VimState,\n  start: Position,\n  char: string,\n  count: number,\n  direction: 'forward' | 'backward'\n) {\n  const result = findHelper(vimState, start, char, count, direction);\n  return direction === 'forward' ? result?.getLeft() : result?.getRight();\n}\n\n@RegisterAction\nclass MoveTilForward extends BaseMovement {\n  keys = ['t', '<character>'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    let result = tilHelper(vimState, position, toFind, count, 'forward');\n\n    // For t<character> vim executes ; as 2; and , as 2,\n    if (result && this.isRepeat && position.isEqual(result) && count === 1) {\n      result = tilHelper(vimState, position, toFind, 2, 'forward');\n    }\n\n    vimState.lastSemicolonRepeatableMovement = new MoveTilForward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveTilBackward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (vimState.recordedState.operator) {\n      result = result.getRight();\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveTilBackward extends BaseMovement {\n  keys = ['T', '<character>'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    let result = tilHelper(vimState, position, toFind, count, 'backward');\n\n    // For T<character> vim executes ; as 2; and , as 2,\n    if (result && this.isRepeat && position.isEqual(result) && count === 1) {\n      result = tilHelper(vimState, position, toFind, 2, 'backward');\n    }\n\n    vimState.lastSemicolonRepeatableMovement = new MoveTilBackward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveTilForward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveRepeat extends BaseMovement {\n  keys = [';'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const movement = vimState.lastSemicolonRepeatableMovement;\n    if (movement) {\n      return movement.execActionWithCount(position, vimState, count);\n    }\n    return position;\n  }\n}\n\n@RegisterAction\nclass MoveRepeatReversed extends BaseMovement {\n  keys = [','];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const semiColonMovement = vimState.lastSemicolonRepeatableMovement;\n    const commaMovement = vimState.lastCommaRepeatableMovement;\n    if (commaMovement) {\n      const result = commaMovement.execActionWithCount(position, vimState, count);\n\n      // Make sure these don't change. Otherwise, comma's direction flips back\n      // and forth when done repeatedly. This is a bit hacky, so feel free to refactor.\n      vimState.lastSemicolonRepeatableMovement = semiColonMovement;\n      vimState.lastCommaRepeatableMovement = commaMovement;\n\n      return result;\n    }\n    return position;\n  }\n}\n\n@RegisterAction\nclass MoveLineEnd extends BaseMovement {\n  keys = [['$'], ['<End>'], ['<D-right>']];\n  setsDesiredColumnToEOL = true;\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    return position.getDown(Math.max(count - 1, 0)).getLineEnd();\n  }\n}\n\n@RegisterAction\nclass MoveLineBegin extends BaseMovement {\n  keys = [['0'], ['<Home>'], ['<D-left>']];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getLineBegin();\n  }\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && vimState.recordedState.count === 0;\n  }\n\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.couldActionApply(vimState, keysPressed) && vimState.recordedState.count === 0;\n  }\n}\n\n@RegisterAction\nclass MoveScreenLineBegin extends MoveByScreenLine {\n  keys = ['g', '0'];\n  movementType: CursorMovePosition = 'wrappedLineStart';\n}\n\n@RegisterAction\nclass MoveScreenNonBlank extends MoveByScreenLine {\n  keys = ['g', '^'];\n  movementType: CursorMovePosition = 'wrappedLineFirstNonWhitespaceCharacter';\n}\n\n@RegisterAction\nclass MoveScreenLineEnd extends MoveByScreenLine {\n  keys = ['g', '$'];\n  movementType: CursorMovePosition = 'wrappedLineEnd';\n}\n\n@RegisterAction\nclass MoveScreenLineEndNonBlank extends MoveByScreenLine {\n  keys = ['g', '_'];\n  movementType: CursorMovePosition = 'wrappedLineLastNonWhitespaceCharacter';\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    count ||= 1;\n    const pos = await super.execActionWithCount(position, vimState, count);\n\n    // If in visual, return a selection\n    if (pos instanceof Position) {\n      return pos.getDown(count - 1);\n    } else {\n      return { start: pos.start, stop: pos.stop.getDown(count - 1).getLeftThroughLineBreaks() };\n    }\n  }\n}\n\n@RegisterAction\nclass MoveScreenLineCenter extends MoveByScreenLine {\n  keys = ['g', 'm'];\n  movementType: CursorMovePosition = 'wrappedLineColumnCenter';\n}\n\n@RegisterAction\nexport class MoveUpByDisplayLine extends MoveByScreenLine {\n  modes = [Mode.Insert, Mode.Normal, Mode.Visual];\n  keys = [\n    ['g', 'k'],\n    ['g', '<up>'],\n  ];\n  movementType: CursorMovePosition = 'up';\n  by: CursorMoveByUnit = 'wrappedLine';\n  value = 1;\n}\n\n@RegisterAction\nclass MoveDownByDisplayLine extends MoveByScreenLine {\n  modes = [Mode.Insert, Mode.Normal, Mode.Visual];\n  keys = [\n    ['g', 'j'],\n    ['g', '<down>'],\n  ];\n  movementType: CursorMovePosition = 'down';\n  by: CursorMoveByUnit = 'wrappedLine';\n  value = 1;\n}\n\n// Because we can't support moving by screen line when in visualLine mode,\n// we change to moving by regular line in visualLine mode. We can't move by\n// screen line is that our ranges only support a start and stop attribute,\n// and moving by screen line just snaps us back to the original position.\n// Check PR #1600 for discussion.\n@RegisterAction\nclass MoveUpByScreenLineVisualLine extends MoveByScreenLine {\n  modes = [Mode.VisualLine];\n  keys = [\n    ['g', 'k'],\n    ['g', '<up>'],\n  ];\n  movementType: CursorMovePosition = 'up';\n  by: CursorMoveByUnit = 'line';\n  value = 1;\n}\n\n@RegisterAction\nclass MoveDownByScreenLineVisualLine extends MoveByScreenLine {\n  modes = [Mode.VisualLine];\n  keys = [\n    ['g', 'j'],\n    ['g', '<down>'],\n  ];\n  movementType: CursorMovePosition = 'down';\n  by: CursorMoveByUnit = 'line';\n  value = 1;\n}\n\n@RegisterAction\nclass MoveUpByScreenLineVisualBlock extends BaseMovement {\n  modes = [Mode.VisualBlock];\n  keys = [\n    ['g', 'k'],\n    ['g', '<up>'],\n  ];\n  preservesDesiredColumn() {\n    return true;\n  }\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    if (position.line > 0) {\n      return position.with({ character: vimState.desiredColumn }).getUp();\n    } else {\n      return position;\n    }\n  }\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getUp();\n  }\n}\n\n@RegisterAction\nclass MoveDownByScreenLineVisualBlock extends BaseMovement {\n  modes = [Mode.VisualBlock];\n  keys = [\n    ['g', 'j'],\n    ['g', '<down>'],\n  ];\n  preservesDesiredColumn() {\n    return true;\n  }\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    if (position.line < vimState.document.lineCount - 1) {\n      return position.with({ character: vimState.desiredColumn }).getDown();\n    } else {\n      return position;\n    }\n  }\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getDown();\n  }\n}\n\n@RegisterAction\nclass MoveScreenToRight extends MoveByScreenLine {\n  modes = [Mode.Insert, Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'h'];\n  movementType: CursorMovePosition = 'right';\n  by: CursorMoveByUnit = 'character';\n  value = 1;\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveScreenToLeft extends MoveByScreenLine {\n  modes = [Mode.Insert, Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'l'];\n  movementType: CursorMovePosition = 'left';\n  by: CursorMoveByUnit = 'character';\n  value = 1;\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveScreenToRightHalf extends MoveByScreenLine {\n  modes = [Mode.Insert, Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'H'];\n  movementType: CursorMovePosition = 'right';\n  by: CursorMoveByUnit = 'halfLine';\n  value = 1;\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveScreenToLeftHalf extends MoveByScreenLine {\n  modes = [Mode.Insert, Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'L'];\n  movementType: CursorMovePosition = 'left';\n  by: CursorMoveByUnit = 'halfLine';\n  value = 1;\n  isJump = true;\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveToLineFromViewPortTop extends MoveByScreenLine {\n  keys = ['H'];\n  movementType: CursorMovePosition = 'viewPortTop';\n  by: CursorMoveByUnit = 'line';\n  value = 1;\n  isJump = true;\n}\n\n@RegisterAction\nclass MoveToLineFromViewPortBottom extends MoveByScreenLine {\n  keys = ['L'];\n  movementType: CursorMovePosition = 'viewPortBottom';\n  by: CursorMoveByUnit = 'line';\n  value = 1;\n  isJump = true;\n}\n\n@RegisterAction\nclass MoveToMiddleLineInViewPort extends MoveByScreenLine {\n  keys = ['M'];\n  movementType: CursorMovePosition = 'viewPortCenter';\n  by: CursorMoveByUnit = 'line';\n  isJump = true;\n}\n\n@RegisterAction\nclass MoveNonBlank extends BaseMovement {\n  keys = ['^'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line);\n  }\n}\n\n@RegisterAction\nclass MoveNextLineNonBlank extends BaseMovement {\n  keys = ['\\n'];\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    // Count === 0 if just pressing enter in normal mode, need to still go down 1 line\n    if (count === 0) {\n      count++;\n    }\n\n    return TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      position.getDown(count).line\n    );\n  }\n}\n\n@RegisterAction\nclass MoveNonBlankFirst extends BaseMovement {\n  keys = ['g', 'g'];\n  isJump = true;\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const lineNumber = clamp(count, 1, vimState.document.lineCount) - 1;\n    return {\n      start: vimState.cursorStartPosition,\n      stop: position.withLine(lineNumber).obeyStartOfLine(vimState.document),\n      registerMode: RegisterMode.LineWise,\n    };\n  }\n}\n\n@RegisterAction\nclass MoveNonBlankLast extends BaseMovement {\n  keys = ['G'];\n  isJump = true;\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    let stop: Position;\n\n    if (count === 0) {\n      stop = new Position(vimState.document.lineCount - 1, position.character).obeyStartOfLine(\n        vimState.document\n      );\n    } else {\n      stop = new Position(\n        Math.min(count, vimState.document.lineCount) - 1,\n        position.character\n      ).obeyStartOfLine(vimState.document);\n    }\n\n    return {\n      start: vimState.cursorStartPosition,\n      stop,\n      registerMode: RegisterMode.LineWise,\n    };\n  }\n}\n\n@RegisterAction\nexport class MoveWordBegin extends BaseMovement {\n  keys = ['w'];\n\n  public async execAction(\n    position: Position,\n    vimState: VimState,\n    isLastIteration: boolean = false\n  ): Promise<Position> {\n    if (\n      isLastIteration &&\n      !configuration.changeWordIncludesWhitespace &&\n      vimState.recordedState.operator instanceof ChangeOperator\n    ) {\n      const line = vimState.document.lineAt(position);\n      if (line.text.length === 0) {\n        return position;\n      }\n\n      const char = line.text[position.character];\n\n      /*\n      From the Vim manual:\n\n      Special case: \"cw\" and \"cW\" are treated like \"ce\" and \"cE\" if the cursor is\n      on a non-blank.  This is because \"cw\" is interpreted as change-word, and a\n      word does not include the following white space.\n      */\n\n      if (' \\t'.includes(char)) {\n        return position.getWordRight();\n      } else {\n        return position.getCurrentWordEnd(true).getRight();\n      }\n    } else {\n      return position.getWordRight();\n    }\n  }\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<Position> {\n    const result = await this.execAction(position, vimState, true);\n\n    /*\n    From the Vim documentation:\n\n    Another special case: When using the \"w\" motion in combination with an\n    operator and the last word moved over is at the end of a line, the end of\n    that word becomes the end of the operated text, not the first word in the\n    next line.\n    */\n\n    if (\n      result.line > position.line + 1 ||\n      (result.line === position.line + 1 && result.isFirstWordOfLine(vimState.document))\n    ) {\n      return position.getLineEnd();\n    }\n\n    if (result.isLineEnd()) {\n      return new Position(result.line, result.character + 1);\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveFullWordBegin extends BaseMovement {\n  keys = [['W'], ['<C-right>']];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    if (\n      !configuration.changeWordIncludesWhitespace &&\n      vimState.recordedState.operator instanceof ChangeOperator\n    ) {\n      // TODO use execForOperator? Or maybe dont?\n\n      // See note for w\n      return position.getCurrentBigWordEnd().getRight();\n    } else {\n      return position.getBigWordRight();\n    }\n  }\n}\n\n@RegisterAction\nclass MoveWordEnd extends BaseMovement {\n  keys = ['e'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getCurrentWordEnd();\n  }\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<Position> {\n    const end = position.getCurrentWordEnd();\n\n    return new Position(end.line, end.character + 1);\n  }\n}\n\n@RegisterAction\nclass MoveFullWordEnd extends BaseMovement {\n  keys = ['E'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getCurrentBigWordEnd();\n  }\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<Position> {\n    return position.getCurrentBigWordEnd().getRight();\n  }\n}\n\n@RegisterAction\nclass MoveLastWordEnd extends BaseMovement {\n  keys = ['g', 'e'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getLastWordEnd();\n  }\n}\n\n@RegisterAction\nclass MoveLastFullWordEnd extends BaseMovement {\n  keys = ['g', 'E'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getLastBigWordEnd();\n  }\n}\n\n@RegisterAction\nclass MoveBeginningWord extends BaseMovement {\n  keys = [['b'], ['<C-left>']];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getWordLeft();\n  }\n}\n\n@RegisterAction\nclass MoveBeginningFullWord extends BaseMovement {\n  keys = ['B'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getBigWordLeft();\n  }\n}\n\n@RegisterAction\nclass MovePreviousSentenceBegin extends BaseMovement {\n  keys = ['('];\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getSentenceBegin({ forward: false });\n  }\n}\n\n@RegisterAction\nclass MoveNextSentenceBegin extends BaseMovement {\n  keys = [')'];\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getSentenceBegin({ forward: true });\n  }\n}\n\n@RegisterAction\nclass MoveParagraphEnd extends BaseMovement {\n  keys = ['}'];\n  isJump = true;\n  iteration = 0;\n  isFirstLineWise = false;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const hasOperator = vimState.recordedState.operator;\n    const paragraphEnd = getCurrentParagraphEnd(position);\n\n    if (hasOperator) {\n      /**\n       * When paired with an `operator` and a `count` this move will be executed\n       * multiple times which could cause issues like https://github.com/VSCodeVim/Vim/issues/4488\n       * because subsequent runs will receive back whatever position we return\n       * (See comment in `BaseMotion.execActionWithCount()`).\n       *\n       * We keep track of the iteration we are in, this way we can\n       * return the correct position when on the last iteration, and we don't\n       * accidentally set the `registerMode` incorrectly.\n       */\n      this.iteration++;\n\n      const isLineWise = position.isLineBeginning() && vimState.currentMode === Mode.Normal;\n\n      const isLastIteration = vimState.recordedState.count\n        ? vimState.recordedState.count === this.iteration\n        : true;\n\n      /**\n       * `position` may not represent the position of the cursor from which the command was initiated.\n       * In the case that we will be repeating this move more than once\n       * we want to respect whether the starting position was at the beginning of line or not.\n       */\n      this.isFirstLineWise = this.iteration === 1 ? isLineWise : this.isFirstLineWise;\n\n      vimState.currentRegisterMode = this.isFirstLineWise\n        ? RegisterMode.LineWise\n        : RegisterMode.AscertainFromCurrentMode;\n\n      /**\n       * `paragraphEnd` is the first blank line after the last word in the\n       * current paragraph, we want the position just before that one to\n       * accurately emulate Vim's behaviour, unless we are at EOF.\n       */\n      return isLastIteration && !paragraphEnd.isAtDocumentEnd()\n        ? paragraphEnd.getLeftThroughLineBreaks(true)\n        : paragraphEnd;\n    }\n\n    return paragraphEnd;\n  }\n}\n\n@RegisterAction\nclass MoveParagraphBegin extends BaseMovement {\n  keys = ['{'];\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return getCurrentParagraphBeginning(position);\n  }\n}\n\nabstract class MoveSectionBoundary extends BaseMovement {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  abstract boundary: string;\n  abstract forward: boolean;\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position> {\n    let line = position.line;\n\n    if (\n      (this.forward && line === vimState.document.lineCount - 1) ||\n      (!this.forward && line === 0)\n    ) {\n      return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n    }\n\n    line = this.forward ? line + 1 : line - 1;\n\n    while (!vimState.document.lineAt(line).text.startsWith(this.boundary)) {\n      if (this.forward) {\n        if (line === vimState.document.lineCount - 1) {\n          break;\n        }\n\n        line++;\n      } else {\n        if (line === 0) {\n          break;\n        }\n\n        line--;\n      }\n    }\n\n    return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n  }\n}\n\n@RegisterAction\nclass MoveNextSectionBegin extends MoveSectionBoundary {\n  keys = [']', ']'];\n  boundary = '{';\n  forward = true;\n}\n\n@RegisterAction\nclass MoveNextSectionEnd extends MoveSectionBoundary {\n  keys = [']', '['];\n  boundary = '}';\n  forward = true;\n}\n\n@RegisterAction\nclass MovePreviousSectionBegin extends MoveSectionBoundary {\n  keys = ['[', '['];\n  boundary = '{';\n  forward = false;\n}\n\n@RegisterAction\nclass MovePreviousSectionEnd extends MoveSectionBoundary {\n  keys = ['[', ']'];\n  boundary = '}';\n  forward = false;\n}\n\n@RegisterAction\nclass MoveToMatchingBracket extends BaseMovement {\n  keys = ['%'];\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    position = position.getLeftIfEOL();\n\n    const lineText = vimState.document.lineAt(position).text;\n    const failure = failedMovement(vimState);\n\n    for (let col = position.character; col < lineText.length; col++) {\n      const pairing = PairMatcher.pairings[lineText[col]];\n      if (pairing && pairing.matchesWithPercentageMotion) {\n        // We found an opening char, now move to the matching closing char\n        return (\n          PairMatcher.nextPairedChar(\n            new Position(position.line, col),\n            lineText[col],\n            vimState,\n            false\n          ) || failure\n        );\n      }\n    }\n\n    // No matchable character on the line; admit defeat\n    return failure;\n  }\n\n  public async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const result = await this.execAction(position, vimState);\n\n    if (isIMovement(result)) {\n      if (result.failed) {\n        return result;\n      } else {\n        throw new Error('Did not ever handle this case!');\n      }\n    }\n\n    if (position.isAfter(result)) {\n      return {\n        start: result,\n        stop: position.getRight(),\n      };\n    } else {\n      return result.getRight();\n    }\n  }\n\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    // % has a special mode that lets you use it to jump to a percentage of the file\n    // However, some other bracket motions inherit from this so only do this behavior for % explicitly\n    if (Object.getPrototypeOf(this) === MoveToMatchingBracket.prototype) {\n      if (count === 0) {\n        if (vimState.recordedState.operator) {\n          return this.execActionForOperator(position, vimState);\n        } else {\n          return this.execAction(position, vimState);\n        }\n      }\n\n      // Check to make sure this is a valid percentage\n      if (count < 0 || count > 100) {\n        return failedMovement(vimState);\n      }\n\n      const targetLine = Math.round((count * vimState.document.lineCount) / 100);\n\n      return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, targetLine - 1);\n    } else {\n      return super.execActionWithCount(position, vimState, count);\n    }\n  }\n}\n\nexport abstract class MoveInsideCharacter extends ExpandingSelection {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  protected abstract charToMatch: string;\n\n  /** True for \"around\" actions, such as `a(`, and false for \"inside\" actions, such as `i(`  */\n  protected includeSurrounding = false;\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const closingChar = PairMatcher.pairings[this.charToMatch].match;\n    let cursorStartPos = vimState.cursorStartPosition;\n    const failure = failedMovement(vimState);\n\n    // when matching inside content of a pair, search for the next pair if\n    // the inner content is already selected in full\n    if (!this.includeSurrounding) {\n      const adjacentPosLeft = cursorStartPos.getLeftThroughLineBreaks(false);\n      let adjacentPosRight = vimState.recordedState.operator\n        ? position\n        : position.getRightThroughLineBreaks();\n      if (adjacentPosRight.isLineBeginning()) {\n        adjacentPosRight = adjacentPosRight.getLineBeginRespectingIndent(vimState.document);\n      }\n      const adjacentCharLeft = TextEditor.getCharAt(vimState.document, adjacentPosLeft);\n      const adjacentCharRight = TextEditor.getCharAt(vimState.document, adjacentPosRight);\n      if (adjacentCharLeft === this.charToMatch && adjacentCharRight === closingChar) {\n        cursorStartPos = adjacentPosLeft;\n        vimState.cursorStartPosition = adjacentPosLeft;\n        position = adjacentPosRight;\n        vimState.cursorStopPosition = adjacentPosRight;\n      }\n    }\n    // First, search backwards for the opening character of the sequence\n    let startPos = PairMatcher.nextPairedChar(cursorStartPos, closingChar, vimState, true);\n    if (startPos === undefined) {\n      return failure;\n    }\n\n    let startPlusOne: Position;\n\n    if (startPos.isAfterOrEqual(startPos.getLineEnd().getLeft())) {\n      startPlusOne = new Position(startPos.line + 1, 0);\n    } else {\n      startPlusOne = new Position(startPos.line, startPos.character + 1);\n    }\n\n    let endPos = PairMatcher.nextPairedChar(position, this.charToMatch, vimState, true);\n\n    if (endPos === undefined) {\n      return failure;\n    }\n\n    if (this.includeSurrounding) {\n      if (vimState.currentMode !== Mode.Visual) {\n        endPos = new Position(endPos.line, endPos.character + 1);\n      }\n    } else {\n      startPos = startPlusOne;\n\n      // If the closing character is the first on the line, don't swallow it.\n      if (endPos.isInLeadingWhitespace(vimState.document)) {\n        endPos = endPos.getLineBegin();\n      }\n\n      if (vimState.currentMode === Mode.Visual) {\n        endPos = endPos.getLeftThroughLineBreaks();\n      }\n    }\n\n    if (position.isBefore(startPos)) {\n      vimState.recordedState.operatorPositionDiff = startPos.subtract(position);\n    }\n\n    vimState.cursorStartPosition = startPos;\n    return {\n      start: startPos,\n      stop: endPos,\n    };\n  }\n}\n\n@RegisterAction\nclass MoveInsideParentheses extends MoveInsideCharacter {\n  keys = [\n    ['i', '('],\n    ['i', ')'],\n    ['i', 'b'],\n  ];\n  charToMatch = '(';\n}\n\n@RegisterAction\nexport class MoveAroundParentheses extends MoveInsideCharacter {\n  keys = [\n    ['a', '('],\n    ['a', ')'],\n    ['a', 'b'],\n  ];\n  charToMatch = '(';\n  includeSurrounding = true;\n}\n\n@RegisterAction\nclass MoveInsideCurlyBrace extends MoveInsideCharacter {\n  keys = [\n    ['i', '{'],\n    ['i', '}'],\n    ['i', 'B'],\n  ];\n  charToMatch = '{';\n}\n\n@RegisterAction\nexport class MoveAroundCurlyBrace extends MoveInsideCharacter {\n  keys = [\n    ['a', '{'],\n    ['a', '}'],\n    ['a', 'B'],\n  ];\n  charToMatch = '{';\n  includeSurrounding = true;\n}\n\n@RegisterAction\nclass MoveInsideCaret extends MoveInsideCharacter {\n  keys = [\n    ['i', '<'],\n    ['i', '>'],\n  ];\n  charToMatch = '<';\n}\n\n@RegisterAction\nexport class MoveAroundCaret extends MoveInsideCharacter {\n  keys = [\n    ['a', '<'],\n    ['a', '>'],\n  ];\n  charToMatch = '<';\n  includeSurrounding = true;\n}\n\n@RegisterAction\nclass MoveInsideSquareBracket extends MoveInsideCharacter {\n  keys = [\n    ['i', '['],\n    ['i', ']'],\n  ];\n  charToMatch = '[';\n}\n\n@RegisterAction\nexport class MoveAroundSquareBracket extends MoveInsideCharacter {\n  keys = [\n    ['a', '['],\n    ['a', ']'],\n  ];\n  charToMatch = '[';\n  includeSurrounding = true;\n}\n\nexport abstract class MoveQuoteMatch extends BaseMovement {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  protected abstract charToMatch: string;\n  protected includeSurrounding = false;\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    // TODO: Don't limit quote matching to the same line\n    const text = vimState.document.lineAt(position).text;\n    const quoteMatcher = new QuoteMatcher(this.charToMatch, text);\n    let start = quoteMatcher.findOpening(position.character);\n    let end = quoteMatcher.findClosing(start + 1);\n\n    if (end < start && start === position.character) {\n      // start character is a match and no forward match found\n      // search backwards instead\n      end = start;\n      start = quoteMatcher.findOpening(end - 1);\n    }\n\n    if (start === -1 || end === -1 || end === start || end < position.character) {\n      return failedMovement(vimState);\n    }\n\n    let startPos = new Position(position.line, start);\n    let endPos = new Position(position.line, end);\n\n    if (!this.includeSurrounding) {\n      startPos = startPos.getRight();\n      endPos = endPos.getLeft();\n    }\n\n    if (position.isBefore(startPos)) {\n      vimState.recordedState.operatorPositionDiff = startPos.subtract(position);\n    }\n\n    return {\n      start: startPos,\n      stop: endPos,\n    };\n  }\n\n  public async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const result = await this.execAction(position, vimState);\n    if (isIMovement(result)) {\n      if (result.failed) {\n        vimState.recordedState.hasRunOperator = false;\n        vimState.recordedState.actionsRun = [];\n      } else {\n        result.stop = result.stop.getRight();\n      }\n    }\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveInsideSingleQuotes extends MoveQuoteMatch {\n  keys = ['i', \"'\"];\n  charToMatch = \"'\";\n  includeSurrounding = false;\n}\n\n@RegisterAction\nexport class MoveAroundSingleQuotes extends MoveQuoteMatch {\n  keys = ['a', \"'\"];\n  charToMatch = \"'\";\n  includeSurrounding = true;\n}\n\n@RegisterAction\nclass MoveInsideDoubleQuotes extends MoveQuoteMatch {\n  keys = ['i', '\"'];\n  charToMatch = '\"';\n  includeSurrounding = false;\n}\n\n@RegisterAction\nexport class MoveAroundDoubleQuotes extends MoveQuoteMatch {\n  keys = ['a', '\"'];\n  charToMatch = '\"';\n  includeSurrounding = true;\n}\n\n@RegisterAction\nclass MoveInsideBacktick extends MoveQuoteMatch {\n  keys = ['i', '`'];\n  charToMatch = '`';\n  includeSurrounding = false;\n}\n\n@RegisterAction\nexport class MoveAroundBacktick extends MoveQuoteMatch {\n  keys = ['a', '`'];\n  charToMatch = '`';\n  includeSurrounding = true;\n}\n\n@RegisterAction\nclass MoveToUnclosedRoundBracketBackward extends MoveToMatchingBracket {\n  keys = ['[', '('];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    const charToMatch = ')';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveToUnclosedRoundBracketForward extends MoveToMatchingBracket {\n  keys = [']', ')'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    const charToMatch = '(';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (\n      vimState.recordedState.operator instanceof ChangeOperator ||\n      vimState.recordedState.operator instanceof DeleteOperator ||\n      vimState.recordedState.operator instanceof YankOperator\n    ) {\n      return result.getLeftThroughLineBreaks();\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveToUnclosedCurlyBracketBackward extends MoveToMatchingBracket {\n  keys = ['[', '{'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    const charToMatch = '}';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveToUnclosedCurlyBracketForward extends MoveToMatchingBracket {\n  keys = [']', '}'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    const charToMatch = '{';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (\n      vimState.recordedState.operator instanceof ChangeOperator ||\n      vimState.recordedState.operator instanceof DeleteOperator ||\n      vimState.recordedState.operator instanceof YankOperator\n    ) {\n      return result.getLeftThroughLineBreaks();\n    }\n\n    return result;\n  }\n}\n\nabstract class MoveTagMatch extends ExpandingSelection {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  protected includeTag = false;\n  isJump = true;\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const editorText = vimState.document.getText();\n    const offset = vimState.document.offsetAt(position);\n    const tagMatcher = new TagMatcher(editorText, offset, vimState);\n    const start = tagMatcher.findOpening(this.includeTag);\n    const end = tagMatcher.findClosing(this.includeTag);\n\n    if (start === undefined || end === undefined) {\n      return failedMovement(vimState);\n    }\n\n    const startPosition =\n      start >= 0 ? vimState.document.positionAt(start) : vimState.cursorStartPosition;\n    let endPosition = end >= 0 ? vimState.document.positionAt(end) : position;\n    if (vimState.currentMode === Mode.Visual || vimState.currentMode === Mode.SurroundInputMode) {\n      endPosition = endPosition.getLeftThroughLineBreaks();\n    }\n\n    if (position.isAfter(endPosition)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: endPosition.subtract(position),\n      });\n    } else if (position.isBefore(startPosition)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: startPosition.subtract(position),\n      });\n    }\n    // if (start === end) {\n    //   if (vimState.recordedState.operator instanceof ChangeOperator) {\n    //     await vimState.setCurrentMode(ModeName.Insert);\n    //   }\n    //   return failedMovement(vimState);\n    // }\n    vimState.cursorStartPosition = startPosition;\n    return {\n      start: startPosition,\n      stop: endPosition,\n    };\n  }\n}\n\n@RegisterAction\nexport class MoveInsideTag extends MoveTagMatch {\n  keys = ['i', 't'];\n  includeTag = false;\n}\n\n@RegisterAction\nexport class MoveAroundTag extends MoveTagMatch {\n  keys = ['a', 't'];\n  includeTag = true;\n}\n","import * as vscode from 'vscode';\n\nimport { PositionDiff, PositionDiffType, earlierOf, sorted } from './../common/motion/position';\nimport { Range } from './../common/motion/range';\nimport { configuration } from './../configuration/configuration';\nimport { Mode, isVisualMode } from './../mode/mode';\nimport { Register, RegisterMode } from './../register/register';\nimport { VimState } from './../state/vimState';\nimport { TextEditor } from './../textEditor';\nimport { BaseAction, RegisterAction } from './base';\nimport { CommandNumber } from './commands/actions';\nimport { TextObjectMovement } from '../textobject/textobject';\nimport { reportLinesChanged, reportLinesYanked } from '../util/statusBarTextUtils';\nimport { commandLine } from './../cmd_line/commandLine';\nimport { Position } from 'vscode';\n\nexport abstract class BaseOperator extends BaseAction {\n  isOperator = true;\n\n  constructor(multicursorIndex?: number) {\n    super();\n    this.multicursorIndex = multicursorIndex;\n  }\n  canBeRepeatedWithDot = true;\n\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (this.doesRepeatedOperatorApply(vimState, keysPressed)) {\n      return true;\n    }\n    if (!this.modes.includes(vimState.currentMode)) {\n      return false;\n    }\n    if (!BaseAction.CompareKeypressSequence(this.keys, keysPressed)) {\n      return false;\n    }\n    if (\n      this.mustBeFirstKey &&\n      vimState.recordedState.commandWithoutCountPrefix.length - keysPressed.length > 0\n    ) {\n      return false;\n    }\n    if (this instanceof BaseOperator && vimState.recordedState.operator) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!this.modes.includes(vimState.currentMode)) {\n      return false;\n    }\n    if (!BaseAction.CompareKeypressSequence(this.keys.slice(0, keysPressed.length), keysPressed)) {\n      return false;\n    }\n    if (\n      this.mustBeFirstKey &&\n      vimState.recordedState.commandWithoutCountPrefix.length - keysPressed.length > 0\n    ) {\n      return false;\n    }\n    if (this instanceof BaseOperator && vimState.recordedState.operator) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public doesRepeatedOperatorApply(vimState: VimState, keysPressed: string[]) {\n    const nonCountActions = vimState.recordedState.actionsRun.filter(\n      (x) => !(x instanceof CommandNumber)\n    );\n    const prevAction = nonCountActions[nonCountActions.length - 1];\n    return (\n      keysPressed.length === 1 &&\n      prevAction &&\n      this.modes.includes(vimState.currentMode) &&\n      // The previous action is the same as the one we're testing\n      prevAction.constructor === this.constructor &&\n      // The key pressed is the same as the previous action's last key.\n      BaseAction.CompareKeypressSequence(prevAction.keysPressed.slice(-1), keysPressed)\n    );\n  }\n\n  /**\n   * Run this operator on a range, returning the new location of the cursor.\n   */\n  public abstract run(vimState: VimState, start: Position, stop: Position): Promise<void>;\n\n  public async runRepeat(vimState: VimState, position: Position, count: number): Promise<void> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    await this.run(\n      vimState,\n      position.getLineBegin(),\n      position.getDown(Math.max(0, count - 1)).getLineEnd()\n    );\n  }\n\n  public highlightYankedRanges(vimState: VimState, ranges: vscode.Range[]) {\n    if (!configuration.highlightedyank.enable) {\n      return;\n    }\n\n    const yankDecoration = vscode.window.createTextEditorDecorationType({\n      backgroundColor: configuration.highlightedyank.color,\n      color: configuration.highlightedyank.textColor,\n    });\n\n    vimState.editor.setDecorations(yankDecoration, ranges);\n    setTimeout(() => yankDecoration.dispose(), configuration.highlightedyank.duration);\n  }\n}\n\n@RegisterAction\nexport class DeleteOperator extends BaseOperator {\n  public keys = ['d'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n\n  /**\n   * Deletes from the position of start to 1 past the position of end.\n   */\n  public async delete(\n    start: Position,\n    end: Position,\n    currentMode: Mode,\n    registerMode: RegisterMode,\n    vimState: VimState,\n    yank = true\n  ): Promise<Position> {\n    if (registerMode === RegisterMode.LineWise) {\n      start = start.getLineBegin();\n      end = end.getLineEnd();\n    }\n\n    end = new Position(end.line, end.character + 1);\n\n    const isOnLastLine = end.line === vimState.document.lineCount - 1;\n\n    // Vim does this weird thing where it allows you to select and delete\n    // the newline character, which it places 1 past the last character\n    // in the line. Here we interpret a character position 1 past the end\n    // as selecting the newline character. Don't allow this in visual block mode\n    if (\n      vimState.currentMode !== Mode.VisualBlock &&\n      !isOnLastLine &&\n      end.character === vimState.document.lineAt(end).text.length + 1\n    ) {\n      end = end.with({ character: 0 }).getDown();\n    }\n\n    let text = vimState.document.getText(new vscode.Range(start, end));\n\n    // If we delete linewise to the final line of the document, we expect the line\n    // to be removed. This is actually a special case because the newline\n    // character we've selected to delete is the newline on the end of the document,\n    // but we actually delete the newline on the second to last line.\n\n    // Just writing about this is making me more confused. -_-\n\n    // rebornix: johnfn's description about this corner case is perfectly correct. The only catch is\n    // that we definitely don't want to put the EOL in the register. So here we run the `getText`\n    // expression first and then update the start position.\n\n    // Now rebornix is confused as well.\n    if (isOnLastLine && start.line !== 0 && registerMode === RegisterMode.LineWise) {\n      start = start.getPreviousLineBegin().getLineEnd();\n    }\n\n    if (registerMode === RegisterMode.LineWise) {\n      // slice final newline in linewise mode - linewise put will add it back.\n      text = text.endsWith('\\r\\n')\n        ? text.slice(0, -2)\n        : text.endsWith('\\n')\n        ? text.slice(0, -1)\n        : text;\n    }\n\n    if (yank) {\n      Register.put(text, vimState, this.multicursorIndex);\n    }\n\n    let diff = new PositionDiff();\n    let resultingPosition: Position;\n\n    if (currentMode === Mode.Visual) {\n      resultingPosition = earlierOf(start, end);\n    }\n\n    if (start.character > vimState.document.lineAt(start).text.length) {\n      resultingPosition = start.getLeft();\n      diff = new PositionDiff({ character: -1 });\n    } else {\n      resultingPosition = start;\n    }\n\n    if (registerMode === RegisterMode.LineWise) {\n      resultingPosition = resultingPosition.obeyStartOfLine(vimState.document);\n      diff = new PositionDiff({\n        type: PositionDiffType.ObeyStartOfLine,\n      });\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRange',\n      range: new Range(start, end),\n      diff,\n    });\n\n    return resultingPosition;\n  }\n\n  public async run(vimState: VimState, start: Position, end: Position, yank = true): Promise<void> {\n    const newPos = await this.delete(\n      start,\n      end,\n      vimState.currentMode,\n      vimState.effectiveRegisterMode,\n      vimState,\n      yank\n    );\n\n    await vimState.setCurrentMode(Mode.Normal);\n    if (vimState.currentMode === Mode.Visual) {\n      vimState.desiredColumn = newPos.character;\n    }\n\n    const numLinesDeleted = Math.abs(start.line - end.line) + 1;\n    reportLinesChanged(-numLinesDeleted, vimState);\n  }\n}\n\n@RegisterAction\nexport class DeleteOperatorVisual extends BaseOperator {\n  public keys = ['D'];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // ensures linewise deletion when in visual mode\n    // see special case in DeleteOperator.delete()\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await new DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nexport class YankOperator extends BaseOperator {\n  public keys = ['y'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  canBeRepeatedWithDot = false;\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // HACK: make Surround with y (which takes a motion) work.\n    if (vimState.surround) {\n      vimState.surround.range = new vscode.Range(start, end);\n      await vimState.setCurrentMode(Mode.SurroundInputMode);\n      vimState.cursorStopPosition = start;\n      vimState.cursorStartPosition = start;\n\n      return;\n    }\n\n    const originalMode = vimState.currentMode;\n\n    [start, end] = sorted(start, end);\n    let extendedEnd = new Position(end.line, end.character + 1);\n\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      start = start.getLineBegin();\n      extendedEnd = extendedEnd.getLineEnd();\n    }\n\n    const range = new vscode.Range(start, extendedEnd);\n    let text = vimState.document.getText(range);\n\n    // If we selected the newline character, add it as well.\n    if (\n      vimState.currentMode === Mode.Visual &&\n      extendedEnd.character === vimState.document.lineAt(extendedEnd).text.length + 1\n    ) {\n      text = text + '\\n';\n    }\n\n    this.highlightYankedRanges(vimState, [range]);\n\n    Register.put(text, vimState, this.multicursorIndex);\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStartPosition = start;\n\n    // Only change cursor position if we ran a text object movement\n    let moveCursor = false;\n    if (vimState.recordedState.actionsRun.length > 1) {\n      if (vimState.recordedState.actionsRun[1] instanceof TextObjectMovement) {\n        moveCursor = true;\n      }\n    }\n\n    if (originalMode === Mode.Normal && !moveCursor) {\n      // we dont want to move the cursor(s)\n      // our default for that is else, but this reset would destroy multicursor when run for the secondary cursors\n      // so for these, we have the following alternative\n      if (this.multicursorIndex !== undefined && this.multicursorIndex > 0) {\n        vimState.cursorStopPosition = vimState.cursors[this.multicursorIndex].stop;\n      } else {\n        vimState.cursors = vimState.cursorsInitialState;\n      }\n    } else {\n      vimState.cursorStopPosition = start;\n    }\n\n    const numLinesYanked = text.split('\\n').length;\n    reportLinesYanked(numLinesYanked, vimState);\n  }\n}\n\n@RegisterAction\nexport class FilterOperator extends BaseOperator {\n  public keys = ['!'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    [start, end] = sorted(start, end);\n\n    if (vimState.currentMode === Mode.Normal && start.line === end.line) {\n      vimState.currentCommandlineText = '.!';\n    } else if (vimState.currentMode === Mode.Normal && start.line !== end.line) {\n      vimState.currentCommandlineText = `.,.+${end.line - start.line}!`;\n    } else {\n      vimState.currentCommandlineText = \"'<,'>!\";\n    }\n\n    vimState.cursorStartPosition = start;\n    if (vimState.currentMode === Mode.Normal) {\n      vimState.cursorStopPosition = start;\n    } else {\n      vimState.cursors = vimState.cursorsInitialState;\n    }\n\n    // Initialize the cursor position\n    vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n    // Store the current mode for use in retaining selection\n    commandLine.previousMode = vimState.currentMode;\n    // Change to the new mode\n    await vimState.setCurrentMode(Mode.CommandlineInProgress);\n    // Reset history navigation index\n    commandLine.commandLineHistoryIndex = commandLine.historyEntries.length;\n  }\n}\n\n@RegisterAction\nexport class ShiftYankOperatorVisual extends BaseOperator {\n  public keys = ['Y'];\n  public modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await new YankOperator().run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nexport class DeleteOperatorXVisual extends BaseOperator {\n  public keys = [['x'], ['<Del>']];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    await new DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nexport class ChangeOperatorSVisual extends BaseOperator {\n  public keys = ['s'];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  // Don't clash with Sneak plugin\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && !configuration.sneak;\n  }\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    await new ChangeOperator().run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nexport class FormatOperator extends BaseOperator {\n  public keys = ['='];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // = operates on complete lines\n    vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n    await vscode.commands.executeCommand('editor.action.formatSelection');\n    let line = vimState.cursorStartPosition.line;\n\n    if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n      line = vimState.cursorStopPosition.line;\n    }\n\n    const newCursorPosition = TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n    vimState.cursorStopPosition = newCursorPosition;\n    vimState.cursorStartPosition = newCursorPosition;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class UpperCaseOperator extends BaseOperator {\n  public keys = [['g', 'U'], ['U']];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    const range = new vscode.Range(start, new Position(end.line, end.character + 1));\n    const text = vimState.document.getText(range);\n\n    await TextEditor.replace(vimState.editor, range, text.toUpperCase());\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = start;\n  }\n}\n\n@RegisterAction\nexport class UpperCaseWithMotion extends UpperCaseOperator {\n  public keys = [['g', 'U']];\n  public modes = [Mode.Normal];\n}\n\n@RegisterAction\nclass UpperCaseVisualBlockOperator extends BaseOperator {\n  public keys = [['g', 'U'], ['U']];\n  public modes = [Mode.VisualBlock];\n\n  public async run(vimState: VimState, startPos: Position, endPos: Position): Promise<void> {\n    for (const { start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      const range = new vscode.Range(start, end);\n      const text = vimState.document.getText(range);\n      await TextEditor.replace(vimState.editor, range, text.toUpperCase());\n    }\n\n    const cursorPosition = earlierOf(startPos, endPos);\n    vimState.cursorStopPosition = cursorPosition;\n    vimState.cursorStartPosition = cursorPosition;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class LowerCaseOperator extends BaseOperator {\n  public keys = [['g', 'u'], ['u']];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    const range = new vscode.Range(start, new Position(end.line, end.character + 1));\n    const text = vimState.document.getText(range);\n\n    await TextEditor.replace(vimState.editor, range, text.toLowerCase());\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = start;\n  }\n}\n\n@RegisterAction\nexport class LowerCaseWithMotion extends LowerCaseOperator {\n  public keys = [['g', 'u']];\n  public modes = [Mode.Normal];\n}\n\n@RegisterAction\nclass LowerCaseVisualBlockOperator extends BaseOperator {\n  public keys = [['g', 'u'], ['u']];\n  public modes = [Mode.VisualBlock];\n\n  public async run(vimState: VimState, startPos: Position, endPos: Position): Promise<void> {\n    for (const { start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      const range = new vscode.Range(start, end);\n      const text = vimState.document.getText(range);\n      await TextEditor.replace(vimState.editor, range, text.toLowerCase());\n    }\n\n    const cursorPosition = earlierOf(startPos, endPos);\n    vimState.cursorStopPosition = cursorPosition;\n    vimState.cursorStartPosition = cursorPosition;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass IndentOperator extends BaseOperator {\n  modes = [Mode.Normal];\n  keys = ['>'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n\n    await vscode.commands.executeCommand('editor.action.indentLines');\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = start.obeyStartOfLine(vimState.document);\n  }\n}\n\n/**\n * `3>` to indent a line 3 times in visual mode is actually a bit of a special case.\n *\n * > is an operator, and generally speaking, you don't run operators multiple times, you run motions multiple times.\n * e.g. `d3w` runs `w` 3 times, then runs d once.\n *\n * Same with literally every other operator motion combination... until `3>`in visual mode\n * walked into my life.\n */\n@RegisterAction\nclass IndentOperatorInVisualModesIsAWeirdSpecialCase extends BaseOperator {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['>'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // Repeating this command with dot should apply the indent to the previous selection\n    if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n      if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n        const shiftSelectionByNum =\n          vimState.dotCommandPreviousVisualSelection.end.line -\n          vimState.dotCommandPreviousVisualSelection.start.line;\n\n        start = vimState.cursorStartPosition;\n        const newEnd = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n\n        vimState.editor.selection = new vscode.Selection(start, newEnd);\n      }\n    }\n\n    for (let i = 0; i < (vimState.recordedState.count || 1); i++) {\n      await vscode.commands.executeCommand('editor.action.indentLines');\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = start.obeyStartOfLine(vimState.document);\n  }\n}\n\n@RegisterAction\nclass OutdentOperator extends BaseOperator {\n  modes = [Mode.Normal];\n  keys = ['<'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.editor.selection = new vscode.Selection(start, end.getLineEnd());\n\n    await vscode.commands.executeCommand('editor.action.outdentLines');\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      start.line\n    );\n  }\n}\n\n/**\n * See comment for IndentOperatorInVisualModesIsAWeirdSpecialCase\n */\n@RegisterAction\nclass OutdentOperatorInVisualModesIsAWeirdSpecialCase extends BaseOperator {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['<'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // Repeating this command with dot should apply the indent to the previous selection\n    if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n      if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n        const shiftSelectionByNum =\n          vimState.dotCommandPreviousVisualSelection.end.line -\n          vimState.dotCommandPreviousVisualSelection.start.line;\n\n        start = vimState.cursorStartPosition;\n        const newEnd = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n\n        vimState.editor.selection = new vscode.Selection(start, newEnd);\n      }\n    }\n\n    for (let i = 0; i < (vimState.recordedState.count || 1); i++) {\n      await vscode.commands.executeCommand('editor.action.outdentLines');\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      start.line\n    );\n  }\n}\n\n@RegisterAction\nexport class ChangeOperator extends BaseOperator {\n  public keys = ['c'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    const isEndOfLine = end.character === end.getLineEnd().character;\n    const isLineWise = vimState.currentRegisterMode === RegisterMode.LineWise;\n    await new YankOperator(this.multicursorIndex).run(vimState, start, end);\n    // which means the insert cursor would be one to the left of the end of\n    // the line. We do want to run delete if it is a multiline change though ex. c}\n    vimState.currentRegisterMode = RegisterMode.CharacterWise;\n    if (TextEditor.getLineLength(start.line) !== 0 || end.line !== start.line) {\n      if (isLineWise) {\n        await new DeleteOperator(this.multicursorIndex).run(\n          vimState,\n          start.getLineBegin(),\n          end.getLineEnd().getLeftThroughLineBreaks(),\n          false\n        );\n      } else if (isEndOfLine) {\n        await new DeleteOperator(this.multicursorIndex).run(\n          vimState,\n          start,\n          end.getLeftThroughLineBreaks(),\n          false\n        );\n      } else {\n        await new DeleteOperator(this.multicursorIndex).run(vimState, start, end, false);\n      }\n    }\n    vimState.currentRegisterMode = RegisterMode.AscertainFromCurrentMode;\n\n    await vimState.setCurrentMode(Mode.Insert);\n\n    if (isEndOfLine) {\n      vimState.cursorStopPosition = end.getRight();\n    }\n  }\n\n  public async runRepeat(vimState: VimState, position: Position, count: number): Promise<void> {\n    const thisLineIndent = vimState.document.getText(\n      new vscode.Range(\n        position.getLineBegin(),\n        position.getLineBeginRespectingIndent(vimState.document)\n      )\n    );\n\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await this.run(\n      vimState,\n      position.getLineBegin(),\n      position.getDown(Math.max(0, count - 1)).getLineEnd()\n    );\n\n    if (configuration.autoindent) {\n      if (vimState.document.languageId === 'plaintext') {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'insertText',\n          text: thisLineIndent,\n          position: position.getLineBegin(),\n          cursorIndex: this.multicursorIndex,\n        });\n      } else {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'reindent',\n          cursorIndex: this.multicursorIndex,\n          diff: new PositionDiff({ character: 1 }), // Handle transition from Normal to Insert modes\n        });\n      }\n    }\n  }\n}\n\n@RegisterAction\nexport class YankVisualBlockMode extends BaseOperator {\n  public keys = ['y'];\n  public modes = [Mode.VisualBlock];\n  canBeRepeatedWithDot = false;\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async run(vimState: VimState, startPos: Position, endPos: Position): Promise<void> {\n    let toCopy: string = '';\n    const ranges: vscode.Range[] = [];\n\n    const isMultiline = startPos.line !== endPos.line;\n\n    for (const { line, start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      ranges.push(new vscode.Range(start, end));\n      if (isMultiline) {\n        toCopy += line + '\\n';\n      } else {\n        toCopy = line;\n      }\n    }\n\n    vimState.currentRegisterMode = RegisterMode.BlockWise;\n\n    this.highlightYankedRanges(vimState, ranges);\n\n    Register.put(toCopy, vimState, this.multicursorIndex);\n\n    vimState.historyTracker.addMark(startPos, '<');\n    vimState.historyTracker.addMark(endPos, '>');\n\n    const numLinesYanked = toCopy.split('\\n').length;\n    reportLinesYanked(numLinesYanked, vimState);\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = startPos;\n  }\n}\n\n@RegisterAction\nexport class ToggleCaseOperator extends BaseOperator {\n  public keys = [['g', '~'], ['~']];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    const range = new vscode.Range(start, end.getRight());\n\n    await ToggleCaseOperator.toggleCase(vimState, range);\n\n    const cursorPosition = earlierOf(start, end);\n    vimState.cursorStopPosition = cursorPosition;\n    vimState.cursorStartPosition = cursorPosition;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n\n  static async toggleCase(vimState: VimState, range: vscode.Range) {\n    const text = vimState.document.getText(range);\n\n    let newText = '';\n    for (const char of text) {\n      // Try lower-case\n      let toggled = char.toLocaleLowerCase();\n      if (toggled === char) {\n        // Try upper-case\n        toggled = char.toLocaleUpperCase();\n      }\n      newText += toggled;\n    }\n    await TextEditor.replace(vimState.editor, range, newText);\n  }\n}\n\n@RegisterAction\nclass ToggleCaseVisualBlockOperator extends BaseOperator {\n  public keys = [['g', '~'], ['~']];\n  public modes = [Mode.VisualBlock];\n\n  public async run(vimState: VimState, startPos: Position, endPos: Position): Promise<void> {\n    for (const { start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      const range = new vscode.Range(start, end);\n      await ToggleCaseOperator.toggleCase(vimState, range);\n    }\n\n    const cursorPosition = earlierOf(startPos, endPos);\n    vimState.cursorStopPosition = cursorPosition;\n    vimState.cursorStartPosition = cursorPosition;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ToggleCaseWithMotion extends ToggleCaseOperator {\n  public keys = [['g', '~']];\n  public modes = [Mode.Normal];\n}\n\n@RegisterAction\nexport class CommentOperator extends BaseOperator {\n  public keys = ['g', 'c'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n    await vscode.commands.executeCommand('editor.action.commentLine');\n\n    vimState.cursorStopPosition = new Position(start.line, 0);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class ROT13Operator extends BaseOperator {\n  public keys = ['g', '?'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    let selections: vscode.Selection[];\n    if (isVisualMode(vimState.currentMode)) {\n      selections = vimState.editor.selections;\n    } else if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      selections = [new vscode.Selection(start.getLineBegin(), end.getLineEnd())];\n    } else {\n      selections = [new vscode.Selection(start, end.getRight())];\n    }\n\n    for (const range of selections) {\n      const original = vimState.document.getText(range);\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: ROT13Operator.rot13(original),\n        range: new Range(range.start, range.end),\n      });\n    }\n  }\n\n  /**\n   * https://en.wikipedia.org/wiki/ROT13\n   */\n  public static rot13(str: string) {\n    return str\n      .split('')\n      .map((char: string) => {\n        let charCode = char.charCodeAt(0);\n\n        if (char >= 'a' && char <= 'z') {\n          const a = 'a'.charCodeAt(0);\n          charCode = ((charCode - a + 13) % 26) + a;\n        }\n\n        if (char >= 'A' && char <= 'Z') {\n          const A = 'A'.charCodeAt(0);\n          charCode = ((charCode - A + 13) % 26) + A;\n        }\n\n        return String.fromCharCode(charCode);\n      })\n      .join('');\n  }\n}\n\n@RegisterAction\nexport class CommentBlockOperator extends BaseOperator {\n  public keys = ['g', 'C'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    if (vimState.currentMode === Mode.Normal) {\n      // If we're in normal mode, we need to construct a selection for the\n      // command to operate on. If we're not, we've already got it.\n      const endPosition = end.getRight();\n      vimState.editor.selection = new vscode.Selection(start, endPosition);\n    }\n    await vscode.commands.executeCommand('editor.action.blockComment');\n\n    vimState.cursorStopPosition = start;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\ninterface CommentTypeSingle {\n  singleLine: true;\n\n  start: string;\n}\n\ninterface CommentTypeMultiLine {\n  singleLine: false;\n\n  start: string;\n  inner: string;\n  final: string;\n}\n\ntype CommentType = CommentTypeSingle | CommentTypeMultiLine;\n\n@RegisterAction\nclass ActionVisualReflowParagraph extends BaseOperator {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['g', 'q'];\n\n  public static CommentTypes: CommentType[] = [\n    { singleLine: false, start: '/**', inner: '*', final: '*/' },\n    { singleLine: false, start: '/*', inner: '*', final: '*/' },\n    { singleLine: false, start: '{-', inner: '-', final: '-}' },\n    { singleLine: true, start: '///' },\n    { singleLine: true, start: '//!' },\n    { singleLine: true, start: '//' },\n    { singleLine: true, start: '--' },\n    { singleLine: true, start: '#' },\n    { singleLine: true, start: ';' },\n    { singleLine: true, start: '*' },\n    { singleLine: true, start: '%' },\n\n    // Needs to come last, since everything starts with the empty string!\n    { singleLine: true, start: '' },\n  ];\n\n  public getIndentation(s: string): string {\n    // Use the indentation of the first non-whitespace line, if any such line is\n    // selected.\n    for (const line of s.split('\\n')) {\n      const result = line.match(/^\\s+/g);\n      const indent = result ? result[0] : '';\n\n      if (indent !== line) {\n        return indent;\n      }\n    }\n\n    return '';\n  }\n\n  public reflowParagraph(s: string): string {\n    const indent = this.getIndentation(s);\n\n    let indentLevel = 0;\n    for (const char of indent) {\n      indentLevel += char === '\\t' ? configuration.tabstop : 1;\n    }\n    const maximumLineLength = configuration.textwidth - indentLevel - 2;\n\n    // Chunk the lines by commenting style.\n\n    interface Chunk {\n      commentType: CommentType;\n      content: string;\n      indentLevelAfterComment: number;\n      final: boolean;\n    }\n    const chunksToReflow: Chunk[] = [];\n\n    for (const line of s.split('\\n')) {\n      let lastChunk: Chunk | undefined = chunksToReflow[chunksToReflow.length - 1];\n      const trimmedLine = line.trim();\n\n      // See what comment type they are using.\n\n      let commentType: CommentType | undefined;\n\n      for (const type of ActionVisualReflowParagraph.CommentTypes) {\n        if (trimmedLine.startsWith(type.start)) {\n          commentType = type;\n\n          break;\n        }\n\n        // If they're currently in a multiline comment, see if they continued it.\n        if (\n          lastChunk &&\n          !lastChunk.final &&\n          type.start === lastChunk.commentType.start &&\n          !type.singleLine\n        ) {\n          if (trimmedLine.startsWith(type.inner)) {\n            commentType = type;\n\n            break;\n          }\n\n          if (trimmedLine.endsWith(type.final)) {\n            commentType = type;\n\n            break;\n          }\n        }\n      }\n\n      if (!commentType) {\n        break;\n      } // will never happen, just to satisfy typechecker.\n\n      // Did they start a new comment type?\n      if (!lastChunk || lastChunk.final || commentType.start !== lastChunk.commentType.start) {\n        const chunk = {\n          commentType,\n          content: `${trimmedLine.substr(commentType.start.length).trim()}`,\n          indentLevelAfterComment: 0,\n          final: false,\n        };\n        if (commentType.singleLine) {\n          chunk.indentLevelAfterComment =\n            trimmedLine.substr(commentType.start.length).length - chunk.content.length;\n        } else if (chunk.content.endsWith(commentType.final)) {\n          // Multiline comment started and ended on one line\n          chunk.content = chunk.content\n            .substr(0, chunk.content.length - commentType.final.length)\n            .trim();\n          chunk.final = true;\n        }\n        chunksToReflow.push(chunk);\n\n        continue;\n      }\n\n      // Parse out commenting style, gather words.\n\n      lastChunk = chunksToReflow[chunksToReflow.length - 1];\n\n      if (lastChunk.commentType.singleLine) {\n        // is it a continuation of a comment like \"//\"\n        lastChunk.content += `\\n${trimmedLine.substr(lastChunk.commentType.start.length).trim()}`;\n      } else if (!lastChunk.final) {\n        // are we in the middle of a multiline comment like \"/*\"\n        if (trimmedLine.endsWith(lastChunk.commentType.final)) {\n          lastChunk.final = true;\n          const prefix = trimmedLine.startsWith(lastChunk.commentType.inner)\n            ? lastChunk.commentType.inner.length\n            : 0;\n          lastChunk.content += `\\n${trimmedLine\n            .substr(prefix, trimmedLine.length - lastChunk.commentType.final.length - prefix)\n            .trim()}`;\n        } else if (trimmedLine.startsWith(lastChunk.commentType.inner)) {\n          lastChunk.content += `\\n${trimmedLine.substr(lastChunk.commentType.inner.length).trim()}`;\n        } else if (trimmedLine.startsWith(lastChunk.commentType.start)) {\n          lastChunk.content += `\\n${trimmedLine.substr(lastChunk.commentType.start.length).trim()}`;\n        }\n      }\n    }\n\n    // Reflow each chunk.\n    const result: string[] = [];\n\n    for (const { commentType, content, indentLevelAfterComment } of chunksToReflow) {\n      let lines: string[];\n      const indentAfterComment = Array(indentLevelAfterComment + 1).join(' ');\n\n      // Start with a single empty content line.\n      lines = [``];\n\n      // This tracks if we're pushing the first line of a chunk. If so, then we\n      // don't want to add an extra space. In addition, when there's a blank\n      // line, this needs to be reset.\n      let curIndex = 0;\n      for (const line of content.split('\\n')) {\n        // Preserve blank lines in output.\n        if (line.trim() === '') {\n          // Replace empty content line with blank line.\n          if (lines[lines.length - 1] === '') {\n            lines.pop();\n          }\n\n          lines.push(line);\n\n          // Add new empty content line for remaining content.\n          lines.push(``);\n\n          curIndex = 0;\n          continue;\n        }\n\n        // Add word by word, wrapping when necessary.\n        const words = line.split(/\\s+/);\n        for (let i = 0; i < words.length; i++) {\n          const word = words[i];\n          if (word === '') {\n            continue;\n          }\n\n          if (lines[lines.length - 1].length + word.length + 1 < maximumLineLength) {\n            if (curIndex === 0 && i === 0) {\n              lines[lines.length - 1] += `${word}`;\n            } else {\n              lines[lines.length - 1] += ` ${word}`;\n            }\n          } else {\n            lines.push(`${word}`);\n          }\n        }\n        curIndex++;\n      }\n\n      // Drop final empty content line.\n      if (lines[lines.length - 1] === '') {\n        lines.pop();\n      }\n\n      for (let i = 0; i < lines.length; i++) {\n        if (commentType.singleLine) {\n          lines[i] = `${indent}${commentType.start}${indentAfterComment}${lines[i]}`;\n        } else {\n          if (i === 0) {\n            if (lines[i] === '') {\n              lines[i] = `${indent}${commentType.start}`;\n            } else {\n              lines[i] = `${indent}${commentType.start} ${lines[i]}`;\n            }\n            if (i === lines.length - 1) {\n              lines[i] += ` ${commentType.final}`;\n            }\n          } else if (i === lines.length - 1) {\n            if (lines[i] === '') {\n              lines[i] = `${indent} ${commentType.final}`;\n            } else {\n              lines[i] = `${indent} ${commentType.inner} ${lines[i]} ${commentType.final}`;\n            }\n          } else {\n            if (lines[i] === '') {\n              lines[i] = `${indent} ${commentType.inner}`;\n            } else {\n              lines[i] = `${indent} ${commentType.inner} ${lines[i]}`;\n            }\n          }\n        }\n      }\n\n      result.push(...lines);\n    }\n\n    return result.join('\\n');\n  }\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    [start, end] = sorted(start, end);\n\n    start = start.getLineBegin();\n    end = end.getLineEnd();\n\n    let textToReflow = vimState.document.getText(new vscode.Range(start, end));\n    textToReflow = this.reflowParagraph(textToReflow);\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      text: textToReflow,\n      range: new Range(start, end),\n      // Move cursor to front of line to realign the view\n      diff: PositionDiff.newBOLDiff(),\n    });\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n","import { VimState } from '../../../state/vimState';\nimport { configuration } from './../../../configuration/configuration';\nimport { Mode, isVisualMode } from './../../../mode/mode';\nimport { RegisterAction, BaseCommand } from './../../base';\nimport { EasyMotion } from './easymotion';\nimport {\n  EasyMotionCharMoveOpions,\n  EasyMotionMoveOptionsBase,\n  EasyMotionWordMoveOpions,\n  EasyMotionSearchAction,\n  Match,\n  SearchOptions,\n} from './types';\nimport { globalState } from '../../../state/globalState';\nimport { TextEditor } from '../../../textEditor';\nimport { MarkerGenerator } from './markerGenerator';\nimport { Position } from 'vscode';\n\nexport interface EasymotionTrigger {\n  key: string;\n  leaderCount?: number;\n}\n\nexport function buildTriggerKeys(trigger: EasymotionTrigger) {\n  return [\n    ...Array.from({ length: trigger.leaderCount || 2 }, () => '<leader>'),\n    ...trigger.key.split(''),\n  ];\n}\n\nabstract class BaseEasyMotionCommand extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  private _baseOptions: EasyMotionMoveOptionsBase;\n\n  public abstract getMatches(position: Position, vimState: VimState): Match[];\n\n  constructor(baseOptions: EasyMotionMoveOptionsBase, trigger?: EasymotionTrigger) {\n    super();\n    this._baseOptions = baseOptions;\n    if (trigger) {\n      this.keys = buildTriggerKeys(trigger);\n    }\n  }\n\n  public abstract resolveMatchPosition(match: Match): Position;\n\n  public processMarkers(matches: Match[], cursorPosition: Position, vimState: VimState) {\n    // Clear existing markers, just in case\n    vimState.easyMotion.clearMarkers();\n\n    let index = 0;\n    const markerGenerator = new MarkerGenerator(matches.length);\n    for (const match of matches) {\n      const matchPosition = this.resolveMatchPosition(match);\n      // Skip if the match position equals to cursor position\n      if (!matchPosition.isEqual(cursorPosition)) {\n        const marker = markerGenerator.generateMarker(index++, matchPosition);\n        if (marker) {\n          vimState.easyMotion.addMarker(marker);\n        }\n      }\n    }\n  }\n\n  protected searchOptions(position: Position): SearchOptions {\n    switch (this._baseOptions.searchOptions) {\n      case 'min':\n        return { min: position };\n      case 'max':\n        return { max: position };\n      default:\n        return {};\n    }\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // Only execute the action if the configuration is set\n    if (configuration.easymotion) {\n      // Search all occurences of the character pressed\n      const matches = this.getMatches(position, vimState);\n\n      // If previous mode was visual, restore visual selection\n      if (isVisualMode(vimState.easyMotion.previousMode)) {\n        vimState.cursorStartPosition = vimState.lastVisualSelection!.start;\n        vimState.cursorStopPosition = vimState.lastVisualSelection!.end;\n      }\n\n      // Stop if there are no matches\n      if (matches.length > 0) {\n        vimState.easyMotion = new EasyMotion();\n        this.processMarkers(matches, position, vimState);\n\n        if (matches.length === 1) {\n          // Only one found, navigate to it\n          const marker = vimState.easyMotion.markers[0];\n          // Set cursor position based on marker entered\n          vimState.cursorStopPosition = marker.position;\n          vimState.easyMotion.clearDecorations(vimState.editor);\n        } else {\n          // Store mode to return to after performing easy motion\n          vimState.easyMotion.previousMode = vimState.currentMode;\n          // Enter the EasyMotion mode and await further keys\n          await vimState.setCurrentMode(Mode.EasyMotionMode);\n        }\n      }\n    }\n  }\n}\n\nfunction getMatchesForString(\n  position: Position,\n  vimState: VimState,\n  searchString: string,\n  options?: SearchOptions\n): Match[] {\n  switch (searchString) {\n    case '':\n      return [];\n    case ' ':\n      // Searching for space should only find the first space\n      return vimState.easyMotion.sortedSearch(\n        vimState.document,\n        position,\n        new RegExp(' {1,}', 'g'),\n        options\n      );\n    default:\n      // Search all occurences of the character pressed\n\n      // If the input is not a letter, treating it as regex can cause issues\n      if (!/[a-zA-Z]/.test(searchString)) {\n        return vimState.easyMotion.sortedSearch(vimState.document, position, searchString, options);\n      }\n\n      const ignorecase =\n        configuration.ignorecase && !(configuration.smartcase && /[A-Z]/.test(searchString));\n      const regexFlags = ignorecase ? 'gi' : 'g';\n      return vimState.easyMotion.sortedSearch(\n        vimState.document,\n        position,\n        new RegExp(searchString, regexFlags),\n        options\n      );\n  }\n}\n\nexport class SearchByCharCommand extends BaseEasyMotionCommand implements EasyMotionSearchAction {\n  public searchString: string = '';\n  private _options: EasyMotionCharMoveOpions;\n\n  get searchCharCount() {\n    return this._options.charCount;\n  }\n\n  constructor(options: EasyMotionCharMoveOpions) {\n    super(options);\n    this._options = options;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return getMatchesForString(position, vimState, this.searchString, this.searchOptions(position));\n  }\n\n  public shouldFire() {\n    const charCount = this._options.charCount;\n    return charCount ? this.searchString.length >= charCount : true;\n  }\n\n  public async fire(position: Position, vimState: VimState): Promise<void> {\n    await this.exec(position, vimState);\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    const { line, character } = match.position;\n    switch (this._options.labelPosition) {\n      case 'after':\n        return new Position(line, character + this._options.charCount);\n      case 'before':\n        return new Position(line, Math.max(0, character - 1));\n      default:\n        return match.position;\n    }\n  }\n}\n\nexport class SearchByNCharCommand extends BaseEasyMotionCommand implements EasyMotionSearchAction {\n  public searchString: string = '';\n\n  get searchCharCount() {\n    return -1;\n  }\n\n  constructor() {\n    super({});\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    return match.position;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return getMatchesForString(\n      position,\n      vimState,\n      this.removeTrailingLineBreak(this.searchString),\n      {}\n    );\n  }\n\n  private removeTrailingLineBreak(s: string) {\n    return s.replace(new RegExp('\\n+$', 'g'), '');\n  }\n\n  public shouldFire() {\n    // Fire when <CR> typed\n    return this.searchString.endsWith('\\n');\n  }\n\n  public async fire(position: Position, vimState: VimState): Promise<void> {\n    if (this.removeTrailingLineBreak(this.searchString) !== '') {\n      await this.exec(position, vimState);\n    }\n  }\n}\n\nexport class EasyMotionCharMoveCommandBase extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  private _action: EasyMotionSearchAction;\n\n  constructor(trigger: EasymotionTrigger, action: EasyMotionSearchAction) {\n    super();\n    this._action = action;\n    this.keys = buildTriggerKeys(trigger);\n  }\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    // Only execute the action if easymotion is enabled\n    if (configuration.easymotion) {\n      vimState.easyMotion = new EasyMotion();\n      vimState.easyMotion.previousMode = vimState.currentMode;\n      vimState.easyMotion.searchAction = this._action;\n      globalState.hl = true;\n\n      await vimState.setCurrentMode(Mode.EasyMotionInputMode);\n    }\n  }\n}\n\nexport class EasyMotionWordMoveCommandBase extends BaseEasyMotionCommand {\n  private _options: EasyMotionWordMoveOpions;\n\n  constructor(trigger: EasymotionTrigger, options: EasyMotionWordMoveOpions = {}) {\n    super(options, trigger);\n    this._options = options;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return this.getMatchesForWord(position, vimState, this.searchOptions(position));\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    const { line, character } = match.position;\n    switch (this._options.labelPosition) {\n      case 'after':\n        return new Position(line, character + match.text.length - 1);\n      default:\n        return match.position;\n    }\n  }\n\n  private getMatchesForWord(\n    position: Position,\n    vimState: VimState,\n    options?: SearchOptions\n  ): Match[] {\n    const regex = this._options.jumpToAnywhere\n      ? new RegExp(configuration.easymotionJumpToAnywhereRegex, 'g')\n      : new RegExp('\\\\w{1,}', 'g');\n    return vimState.easyMotion.sortedSearch(vimState.document, position, regex, options);\n  }\n}\n\nexport class EasyMotionLineMoveCommandBase extends BaseEasyMotionCommand {\n  private _options: EasyMotionMoveOptionsBase;\n\n  constructor(trigger: EasymotionTrigger, options: EasyMotionMoveOptionsBase = {}) {\n    super(options, trigger);\n    this._options = options;\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    return match.position;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return this.getMatchesForLineStart(position, vimState, this.searchOptions(position));\n  }\n\n  private getMatchesForLineStart(\n    position: Position,\n    vimState: VimState,\n    options?: SearchOptions\n  ): Match[] {\n    // Search for the beginning of all non whitespace chars on each line before the cursor\n    const matches = vimState.easyMotion.sortedSearch(\n      vimState.document,\n      position,\n      new RegExp('^.', 'gm'),\n      options\n    );\n    for (const match of matches) {\n      match.position = TextEditor.getFirstNonWhitespaceCharOnLine(\n        vimState.document,\n        match.position.line\n      );\n    }\n    return matches;\n  }\n}\n\n@RegisterAction\nclass EasyMotionCharInputMode extends BaseCommand {\n  modes = [Mode.EasyMotionInputMode];\n  keys = ['<character>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const action = vimState.easyMotion.searchAction;\n    action.searchString =\n      key === '<BS>' || key === '<S-BS>'\n        ? action.searchString.slice(0, -1)\n        : action.searchString + key;\n    if (action.shouldFire()) {\n      // Skip Easymotion input mode to make sure not to back to it\n      await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n      await action.fire(vimState.cursorStopPosition, vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandEscEasyMotionCharInputMode extends BaseCommand {\n  modes = [Mode.EasyMotionInputMode];\n  keys = ['<Esc>'];\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass MoveEasyMotion extends BaseCommand {\n  modes = [Mode.EasyMotionMode];\n  keys = ['<character>'];\n  isJump = true;\n\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    if (key) {\n      // \"nail\" refers to the accumulated depth keys\n      const nail = vimState.easyMotion.accumulation + key;\n      vimState.easyMotion.accumulation = nail;\n\n      // Find markers starting with \"nail\"\n      const markers = vimState.easyMotion.findMarkers(nail, true);\n\n      // If previous mode was visual, restore visual selection\n      if (isVisualMode(vimState.easyMotion.previousMode)) {\n        vimState.cursorStartPosition = vimState.lastVisualSelection!.start;\n        vimState.cursorStopPosition = vimState.lastVisualSelection!.end;\n      }\n\n      if (markers.length === 1) {\n        // Only one found, navigate to it\n        const marker = markers[0];\n\n        vimState.easyMotion.clearDecorations(vimState.editor);\n        // Restore the mode from before easy motion\n        await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n\n        // Set cursor position based on marker entered\n        vimState.cursorStopPosition = marker.position;\n      } else if (markers.length === 0) {\n        // None found, exit mode\n        vimState.easyMotion.clearDecorations(vimState.editor);\n        await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n      }\n    }\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from './../../../configuration/configuration';\nimport { TextEditor } from './../../../textEditor';\nimport { IEasyMotion, EasyMotionSearchAction, Marker, Match, SearchOptions } from './types';\nimport { Mode } from '../../../mode/mode';\nimport { Position } from 'vscode';\n\nexport class EasyMotion implements IEasyMotion {\n  /**\n   * Refers to the accumulated keys for depth navigation\n   */\n  public accumulation = '';\n\n  public searchAction: EasyMotionSearchAction;\n\n  /**\n   * Array of all markers and decorations\n   */\n  public readonly markers: Marker[];\n\n  private visibleMarkers: Marker[]; // Array of currently showing markers\n  private decorations: vscode.DecorationOptions[][];\n\n  private static readonly fade = vscode.window.createTextEditorDecorationType({\n    color: configuration.easymotionDimColor,\n  });\n  private static readonly hide = vscode.window.createTextEditorDecorationType({\n    color: 'transparent',\n  });\n\n  /**\n   * TODO: For future motions\n   */\n  private static specialCharactersRegex: RegExp = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n\n  /**\n   * Caches for decorations\n   */\n  private static decorationTypeCache: vscode.TextEditorDecorationType[] = [];\n\n  /**\n   * Mode to return to after attempting easymotion\n   */\n  public previousMode: Mode;\n\n  constructor() {\n    this.markers = [];\n    this.visibleMarkers = [];\n    this.decorations = [];\n  }\n\n  /**\n   * Create and cache decoration types for different marker lengths\n   */\n  public static getDecorationType(\n    length: number,\n    decorations?: vscode.DecorationRenderOptions\n  ): vscode.TextEditorDecorationType {\n    const cache = this.decorationTypeCache[length];\n    if (cache) {\n      return cache;\n    } else {\n      const type = vscode.window.createTextEditorDecorationType(decorations || {});\n\n      this.decorationTypeCache[length] = type;\n\n      return type;\n    }\n  }\n\n  /**\n   * Clear all decorations\n   */\n  public clearDecorations(editor: vscode.TextEditor) {\n    for (let i = 1; i <= this.decorations.length; i++) {\n      editor.setDecorations(EasyMotion.getDecorationType(i), []);\n    }\n\n    editor.setDecorations(EasyMotion.fade, []);\n    editor.setDecorations(EasyMotion.hide, []);\n  }\n\n  /**\n   * Clear all markers\n   */\n  public clearMarkers() {\n    while (this.markers.length) {\n      this.markers.pop();\n    }\n    this.visibleMarkers = [];\n  }\n\n  public addMarker(marker: Marker) {\n    this.markers.push(marker);\n  }\n\n  /**\n   * Find markers beginning with a string\n   */\n  public findMarkers(nail: string, onlyVisible: boolean): Marker[] {\n    const markers = onlyVisible ? this.visibleMarkers : this.markers;\n    return markers.filter((marker) => marker.name.startsWith(nail));\n  }\n\n  /**\n   * Search and sort using the index of a match compared to the index of position (usually the cursor)\n   */\n  public sortedSearch(\n    document: vscode.TextDocument,\n    position: Position,\n    search: string | RegExp = '',\n    options: SearchOptions = {}\n  ): Match[] {\n    const regex =\n      typeof search === 'string'\n        ? new RegExp(search.replace(EasyMotion.specialCharactersRegex, '\\\\$&'), 'g')\n        : search;\n\n    const matches: Match[] = [];\n\n    // Cursor index refers to the index of the marker that is on or to the right of the cursor\n    let cursorIndex = position.character;\n    let prevMatch: Match | undefined;\n\n    // Calculate the min/max bounds for the search\n    const lineCount = document.lineCount;\n    const lineMin = options.min ? Math.max(options.min.line, 0) : 0;\n    const lineMax = options.max ? Math.min(options.max.line + 1, lineCount) : lineCount;\n\n    outer: for (let lineIdx = lineMin; lineIdx < lineMax; lineIdx++) {\n      const line = document.lineAt(lineIdx).text;\n      let result = regex.exec(line);\n\n      while (result) {\n        if (matches.length >= 1000) {\n          break outer;\n        } else {\n          const pos = new Position(lineIdx, result.index);\n\n          // Check if match is within bounds\n          if (\n            (options.min && pos.isBefore(options.min)) ||\n            (options.max && pos.isAfter(options.max)) ||\n            Math.abs(pos.line - position.line) > 100\n          ) {\n            // Stop searching after 100 lines in both directions\n            result = regex.exec(line);\n          } else {\n            // Update cursor index to the marker on the right side of the cursor\n            if (!prevMatch || prevMatch.position.isBefore(position)) {\n              cursorIndex = matches.length;\n            }\n            // Matches on the cursor position should be ignored\n            if (pos.isEqual(position)) {\n              result = regex.exec(line);\n            } else {\n              prevMatch = new Match(pos, result[0], matches.length);\n              matches.push(prevMatch);\n              result = regex.exec(line);\n            }\n          }\n        }\n      }\n    }\n\n    // Sort by the index distance from the cursor index\n    matches.sort((a: Match, b: Match): number => {\n      const absDiffA = computeAboluteDiff(a.index);\n      const absDiffB = computeAboluteDiff(b.index);\n      return absDiffA - absDiffB;\n\n      function computeAboluteDiff(matchIndex: number) {\n        const absDiff = Math.abs(cursorIndex - matchIndex);\n        // Prioritize the matches on the right side of the cursor index\n        return matchIndex < cursorIndex ? absDiff - 0.5 : absDiff;\n      }\n    });\n\n    return matches;\n  }\n\n  private getMarkerColor(\n    customizedValue: string,\n    themeColorId: string\n  ): string | vscode.ThemeColor {\n    if (customizedValue) {\n      return customizedValue;\n    } else if (!themeColorId.startsWith('#')) {\n      return new vscode.ThemeColor(themeColorId);\n    } else {\n      return themeColorId;\n    }\n  }\n\n  private getEasymotionMarkerBackgroundColor() {\n    return this.getMarkerColor(configuration.easymotionMarkerBackgroundColor, '#0000');\n  }\n\n  private getEasymotionMarkerForegroundColorOneChar() {\n    return this.getMarkerColor(configuration.easymotionMarkerForegroundColorOneChar, '#ff0000');\n  }\n\n  private getEasymotionMarkerForegroundColorTwoCharFirst() {\n    return this.getMarkerColor(\n      configuration.easymotionMarkerForegroundColorTwoCharFirst,\n      '#ffb400'\n    );\n  }\n\n  private getEasymotionMarkerForegroundColorTwoCharSecond() {\n    return this.getMarkerColor(\n      configuration.easymotionMarkerForegroundColorTwoCharSecond,\n      '#b98300'\n    );\n  }\n\n  private getEasymotionDimColor() {\n    return this.getMarkerColor(configuration.easymotionDimColor, '#777777');\n  }\n\n  public updateDecorations(editor: vscode.TextEditor) {\n    this.clearDecorations(editor);\n\n    this.visibleMarkers = [];\n    this.decorations = [];\n\n    // Set the decorations for all the different marker lengths\n    const dimmingZones: vscode.DecorationOptions[] = [];\n    const dimmingRenderOptions: vscode.ThemableDecorationRenderOptions = {\n      // we update the color here again in case the configuration has changed\n      color: this.getEasymotionDimColor(),\n    };\n    // Why this instead of `background-color` on the marker?\n    // The easy fix would've been to let the user set the marker background to the same\n    // color as the editor so it would hide the character behind, However this would require\n    // the user to do more work, with this solution we temporarily hide the marked character\n    // so no user specific setting is needed\n    const hiddenChars: vscode.Range[] = [];\n    const markers = this.markers\n      .filter((m) => m.name.startsWith(this.accumulation))\n      .sort((a, b) => (a.position.isBefore(b.position) ? -1 : 1));\n\n    // Ignore markers that do not start with the accumulated depth level\n    for (const marker of markers) {\n      const pos = marker.position;\n      // Get keys after the depth we're at\n      const keystroke = marker.name.substr(this.accumulation.length);\n\n      if (!this.decorations[keystroke.length]) {\n        this.decorations[keystroke.length] = [];\n      }\n\n      //#region Hack (remove once backend handles this)\n\n      /*\n        This hack is here because the backend for easy motion reports two adjacent\n        2 char markers resulting in a 4 char wide markers, this isn't what happens in\n        original easymotion for instance: for doom\n            - original reports d[m][m2]m where [m] is a marker and [m2] is secondary\n            - here it reports d[m][m][m][m]m\n        The reason this won't work with current impl is that it overflows resulting in\n        one extra hidden character, hence the check below (until backend truely mimics original)\n\n        if two consecutive 2 char markers, we only use the first char from the current marker\n        and reduce the char substitution by 1. Once backend properly reports adjacent markers\n        all instances of `trim` can be removed\n      */\n      let trim = 0;\n      const next = markers[markers.indexOf(marker) + 1];\n\n      if (\n        next &&\n        next.position.character - pos.character === 1 &&\n        next.position.line === pos.line\n      ) {\n        const nextKeystroke = next.name.substr(this.accumulation.length);\n\n        if (keystroke.length > 1 && nextKeystroke.length > 1) {\n          trim = -1;\n        }\n      }\n\n      //#endregion\n\n      // First Char/One Char decoration\n      const firstCharFontColor =\n        keystroke.length > 1\n          ? this.getEasymotionMarkerForegroundColorTwoCharFirst()\n          : this.getEasymotionMarkerForegroundColorOneChar();\n      const backgroundColor = this.getEasymotionMarkerBackgroundColor();\n      const firstCharRange = new vscode.Range(pos.line, pos.character, pos.line, pos.character);\n      const firstCharRenderOptions: vscode.ThemableDecorationInstanceRenderOptions = {\n        before: {\n          contentText: keystroke.substring(0, 1),\n          backgroundColor,\n          color: firstCharFontColor,\n          margin: `0 -1ch 0 0;\n          position: absolute;\n          font-weight: ${configuration.easymotionMarkerFontWeight};`,\n          height: '100%',\n        },\n      };\n\n      this.decorations[keystroke.length].push({\n        range: firstCharRange,\n        renderOptions: {\n          dark: firstCharRenderOptions,\n          light: firstCharRenderOptions,\n        },\n      });\n\n      // Second Char decoration\n      if (keystroke.length + trim > 1) {\n        const secondCharFontColor = this.getEasymotionMarkerForegroundColorTwoCharSecond();\n        const secondCharRange = new vscode.Range(\n          pos.line,\n          pos.character + 1,\n          pos.line,\n          pos.character + 1\n        );\n\n        const secondCharRenderOptions: vscode.ThemableDecorationInstanceRenderOptions = {\n          before: {\n            contentText: keystroke.slice(1),\n            backgroundColor,\n            color: secondCharFontColor,\n            margin: `0 -1ch 0 0;\n            position: absolute;\n            font-weight: ${configuration.easymotionMarkerFontWeight};`,\n            height: '100%',\n          },\n        };\n        this.decorations[keystroke.length].push({\n          range: secondCharRange,\n          renderOptions: {\n            dark: secondCharRenderOptions,\n            light: secondCharRenderOptions,\n          },\n        });\n      }\n\n      hiddenChars.push(\n        new vscode.Range(pos.line, pos.character, pos.line, pos.character + keystroke.length + trim)\n      );\n\n      if (configuration.easymotionDimBackground) {\n        // This excludes markers from the dimming ranges by using them as anchors\n        // each marker adds the range between it and previous marker to the dimming zone\n        // except last marker after which the rest of document is dimmed\n        //\n        // example [m1] text that has multiple [m2] marks\n        // |<------    |<----------------------     ---->|\n        if (dimmingZones.length === 0) {\n          dimmingZones.push({\n            range: new vscode.Range(0, 0, pos.line, pos.character),\n            renderOptions: dimmingRenderOptions,\n          });\n        } else {\n          const prevMarker = markers[markers.indexOf(marker) - 1];\n          const prevKeystroke = prevMarker.name.substr(this.accumulation.length);\n          const prevDimPos = prevMarker.position;\n          const offsetPrevDimPos = prevDimPos.withColumn(\n            prevDimPos.character + prevKeystroke.length\n          );\n\n          // Don't create dimming ranges in between consecutive markers (the 'after' is in the cases\n          // where you have 2 char consecutive markers where the first one only shows the first char.\n          // since we don't take that into account when creating 'offsetPrevDimPos' it will be after\n          // the current marker position which means we are in the middle of two consecutive markers.\n          // See the hack region above.)\n          if (!offsetPrevDimPos.isAfterOrEqual(pos)) {\n            dimmingZones.push({\n              range: new vscode.Range(\n                offsetPrevDimPos.line,\n                offsetPrevDimPos.character,\n                pos.line,\n                pos.character\n              ),\n              renderOptions: dimmingRenderOptions,\n            });\n          }\n        }\n      }\n\n      this.visibleMarkers.push(marker);\n    }\n\n    // for the last marker dim till document end\n    if (configuration.easymotionDimBackground) {\n      const prevMarker = markers[markers.length - 1];\n      const prevKeystroke = prevMarker.name.substr(this.accumulation.length);\n      const prevDimPos = dimmingZones[dimmingZones.length - 1].range.end;\n      const offsetPrevDimPos = prevDimPos.withColumn(prevDimPos.character + prevKeystroke.length);\n\n      // Don't create any more dimming ranges when the last marker is at document end\n      if (!offsetPrevDimPos.isEqual(TextEditor.getDocumentEnd(editor.document))) {\n        dimmingZones.push({\n          range: new vscode.Range(\n            offsetPrevDimPos,\n            new Position(editor.document.lineCount, Number.MAX_VALUE)\n          ),\n          renderOptions: dimmingRenderOptions,\n        });\n      }\n    }\n\n    for (let j = 1; j < this.decorations.length; j++) {\n      if (this.decorations[j]) {\n        editor.setDecorations(EasyMotion.getDecorationType(j), this.decorations[j]);\n      }\n    }\n\n    editor.setDecorations(EasyMotion.hide, hiddenChars);\n\n    if (configuration.easymotionDimBackground) {\n      editor.setDecorations(EasyMotion.fade, dimmingZones);\n    }\n  }\n}\n","import { Position } from 'vscode';\nimport { configuration } from './../../../configuration/configuration';\nimport { Marker } from './types';\n\nexport class MarkerGenerator {\n  private matchesCount: number;\n  private keyTable: string[];\n  private prefixKeyTable: string[];\n\n  constructor(matchesCount: number) {\n    this.matchesCount = matchesCount;\n    this.keyTable = this.getKeyTable();\n    this.prefixKeyTable = this.createPrefixKeyTable();\n  }\n\n  public generateMarker(index: number, markerPosition: Position): Marker | null {\n    const { keyTable, prefixKeyTable } = this;\n\n    if (index >= keyTable.length - prefixKeyTable.length) {\n      const remainder = index - (keyTable.length - prefixKeyTable.length);\n      const currentStep = Math.floor(remainder / keyTable.length) + 1;\n      if (currentStep > prefixKeyTable.length) {\n        return null;\n      } else {\n        const prefix = prefixKeyTable[currentStep - 1];\n        const label = keyTable[remainder % keyTable.length];\n        return {\n          name: prefix + label,\n          position: markerPosition,\n        };\n      }\n    } else {\n      return {\n        name: keyTable[index],\n        position: markerPosition,\n      };\n    }\n  }\n\n  private createPrefixKeyTable(): string[] {\n    const totalRemainder = Math.max(this.matchesCount - this.keyTable.length, 0);\n    const totalSteps = Math.ceil(totalRemainder / this.keyTable.length);\n    const reversed = this.keyTable.slice().reverse();\n    const count = Math.min(totalSteps, reversed.length);\n    return reversed.slice(0, count);\n  }\n\n  /**\n   * The key sequence for marker name generation\n   */\n  private getKeyTable(): string[] {\n    if (configuration.easymotionKeys) {\n      return configuration.easymotionKeys.split('');\n    } else {\n      return 'hklyuiopnm,qwertzxcvbasdgjf;'.split('');\n    }\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\nimport { Mode } from '../../../mode/mode';\nimport type { VimState } from '../../../state/vimState';\n\nexport type LabelPosition = 'after' | 'before';\nexport type JumpToAnywhere = true | false;\n\nexport interface EasyMotionMoveOptionsBase {\n  searchOptions?: 'min' | 'max';\n}\n\nexport interface EasyMotionCharMoveOpions extends EasyMotionMoveOptionsBase {\n  charCount: number;\n  labelPosition?: LabelPosition;\n}\n\nexport interface EasyMotionWordMoveOpions extends EasyMotionMoveOptionsBase {\n  labelPosition?: LabelPosition;\n  jumpToAnywhere?: JumpToAnywhere;\n}\n\nexport interface Marker {\n  name: string;\n  position: Position;\n}\n\nexport class Match {\n  public position: Position;\n  public readonly text: string;\n  public readonly index: number;\n\n  constructor(position: Position, text: string, index: number) {\n    this.position = position;\n    this.text = text;\n    this.index = index;\n  }\n\n  public toRange(): vscode.Range {\n    return new vscode.Range(this.position, this.position.translate(0, this.text.length));\n  }\n}\n\nexport interface SearchOptions {\n  /**\n   * The minimum bound of the search\n   */\n  min?: Position;\n\n  /**\n   * The maximum bound of the search\n   */\n  max?: Position;\n}\n\nexport interface EasyMotionSearchAction {\n  searchString: string;\n\n  /**\n   * True if it should go to Easymotion mode\n   */\n  shouldFire(): boolean;\n\n  /**\n   * Command to execute when it should fire\n   */\n  fire(position: Position, vimState: VimState): Promise<void>;\n  getMatches(position: Position, vimState: VimState): Match[];\n  readonly searchCharCount: number;\n}\n\nexport interface IEasyMotion {\n  accumulation: string;\n  previousMode: Mode;\n  markers: Marker[];\n  searchAction: EasyMotionSearchAction;\n\n  addMarker(marker: Marker): void;\n  findMarkers(nail: string, onlyVisible: boolean): Marker[];\n  sortedSearch(\n    document: vscode.TextDocument,\n    position: Position,\n    search?: string | RegExp,\n    options?: SearchOptions\n  ): Match[];\n  updateDecorations(editor: vscode.TextEditor): void;\n  clearMarkers(): void;\n  clearDecorations(editor: vscode.TextEditor): void;\n}\n","import { VimState } from '../../state/vimState';\nimport { configuration } from './../../configuration/configuration';\nimport { RegisterAction } from './../base';\nimport { BaseMovement, IMovement } from '../baseMotion';\nimport { Position } from 'vscode';\n\n@RegisterAction\nexport class SneakForward extends BaseMovement {\n  keys = [\n    ['s', '<character>', '<character>'],\n    ['z', '<character>', '<character>'],\n  ];\n  isJump = true;\n\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const startingLetter = vimState.recordedState.operator === undefined ? 's' : 'z';\n\n    return (\n      configuration.sneak &&\n      super.couldActionApply(vimState, keysPressed) &&\n      keysPressed[0] === startingLetter\n    );\n  }\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    if (!this.isRepeat) {\n      vimState.lastSemicolonRepeatableMovement = new SneakForward(this.keysPressed, true);\n      vimState.lastCommaRepeatableMovement = new SneakBackward(this.keysPressed, true);\n    }\n\n    if (this.keysPressed[2] === '\\n') {\n      // Single key sneak\n      this.keysPressed[2] = '';\n    }\n\n    const searchString = this.keysPressed[1] + this.keysPressed[2];\n\n    const document = vimState.document;\n    const lineCount = document.lineCount;\n    for (let i = position.line; i < lineCount; ++i) {\n      const lineText = document.lineAt(i).text;\n\n      // Start searching after the current character so we don't find the same match twice\n      const fromIndex = i === position.line ? position.character + 1 : 0;\n\n      let matchIndex = -1;\n\n      const ignorecase =\n        configuration.sneakUseIgnorecaseAndSmartcase &&\n        configuration.ignorecase &&\n        !(configuration.smartcase && /[A-Z]/.test(searchString));\n\n      // Check for matches\n      if (ignorecase) {\n        matchIndex = lineText\n          .toLocaleLowerCase()\n          .indexOf(searchString.toLocaleLowerCase(), fromIndex);\n      } else {\n        matchIndex = lineText.indexOf(searchString, fromIndex);\n      }\n\n      if (matchIndex >= 0) {\n        return new Position(i, matchIndex);\n      }\n    }\n\n    return position;\n  }\n}\n\n@RegisterAction\nexport class SneakBackward extends BaseMovement {\n  keys = [\n    ['S', '<character>', '<character>'],\n    ['Z', '<character>', '<character>'],\n  ];\n  isJump = true;\n\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const startingLetter = vimState.recordedState.operator === undefined ? 'S' : 'Z';\n\n    return (\n      configuration.sneak &&\n      super.couldActionApply(vimState, keysPressed) &&\n      keysPressed[0] === startingLetter\n    );\n  }\n\n  public async execAction(position: Position, vimState: VimState): Promise<Position | IMovement> {\n    if (!this.isRepeat) {\n      vimState.lastSemicolonRepeatableMovement = new SneakBackward(this.keysPressed, true);\n      vimState.lastCommaRepeatableMovement = new SneakForward(this.keysPressed, true);\n    }\n\n    if (this.keysPressed[2] === '\\n') {\n      // Single key sneak\n      this.keysPressed[2] = '';\n    }\n\n    const searchString = this.keysPressed[1] + this.keysPressed[2];\n\n    const document = vimState.document;\n    for (let i = position.line; i >= 0; --i) {\n      const lineText = document.lineAt(i).text;\n\n      // Start searching before the current character so we don't find the same match twice\n      const fromIndex = i === position.line ? position.character - 1 : +Infinity;\n\n      let matchIndex = -1;\n\n      const ignorecase =\n        configuration.sneakUseIgnorecaseAndSmartcase &&\n        configuration.ignorecase &&\n        !(configuration.smartcase && /[A-Z]/.test(searchString));\n\n      // Check for matches\n      if (ignorecase) {\n        matchIndex = lineText\n          .toLocaleLowerCase()\n          .lastIndexOf(searchString.toLocaleLowerCase(), fromIndex);\n      } else {\n        matchIndex = lineText.lastIndexOf(searchString, fromIndex);\n      }\n\n      if (matchIndex >= 0) {\n        return new Position(i, matchIndex);\n      }\n    }\n\n    return position;\n  }\n}\n","import { configuration } from './../configuration/configuration';\nimport { Mode } from './../mode/mode';\n\n/**\n * See https://vimhelp.org/options.txt.html#%27whichwrap%27\n *\n * @returns true if the given key should cause the cursor to wrap around line boundary\n */\nexport const shouldWrapKey = (mode: Mode, key: string): boolean => {\n  let k: string;\n  if (key === '<left>') {\n    k = [Mode.Insert, Mode.Replace].includes(mode) ? '[' : '<';\n  } else if (key === '<right>') {\n    k = [Mode.Insert, Mode.Replace].includes(mode) ? ']' : '>';\n  } else if (['<BS>', '<C-BS>', '<S-BS>'].includes(key)) {\n    k = 'b';\n  } else if (key === ' ') {\n    k = 's';\n  } else if (['h', 'l', '~'].includes(key)) {\n    k = key;\n  } else {\n    throw new Error(`shouldWrapKey called with unexpected key='${key}'`);\n  }\n  return configuration.whichwrap.split(',').includes(k);\n};\n","import * as parser from './parser';\nimport * as vscode from 'vscode';\nimport { CommandLineHistory } from '../history/historyFile';\nimport { Mode } from './../mode/mode';\nimport { Logger } from '../util/logger';\nimport { StatusBar } from '../statusBar';\nimport { VimError, ErrorCode } from '../error';\nimport { VimState } from '../state/vimState';\nimport { configuration } from '../configuration/configuration';\nimport { Register } from '../register/register';\nimport { RecordedState } from '../state/recordedState';\n\nclass CommandLine {\n  private _history: CommandLineHistory;\n  private readonly _logger = Logger.get('CommandLine');\n\n  /**\n   *  Index used for navigating commandline history with <up> and <down>\n   */\n  public commandLineHistoryIndex: number = 0;\n\n  /**\n   * for checking the last pressed key in command mode\n   */\n  public lastKeyPressed = '';\n\n  public autoCompleteIndex = 0;\n  public autoCompleteItems: string[] = [];\n  public preCompleteCharacterPos = 0;\n  public preCompleteCommand = '';\n\n  public get historyEntries() {\n    return this._history?.get() || [];\n  }\n\n  public previousMode = Mode.Normal;\n\n  public async load(context: vscode.ExtensionContext): Promise<void> {\n    this._history = new CommandLineHistory(context);\n    return this._history.load();\n  }\n\n  public async Run(command: string, vimState: VimState): Promise<void> {\n    if (!command || command.length === 0) {\n      return;\n    }\n\n    if (command.startsWith(':')) {\n      command = command.slice(1);\n    }\n\n    this._history.add(command);\n    this.commandLineHistoryIndex = this._history.get().length;\n\n    if (!command.startsWith('reg')) {\n      const recState = new RecordedState();\n      recState.registerName = ':';\n      recState.commandList = command.split('');\n      Register.putByKey(recState, ':', undefined, true);\n    }\n\n    try {\n      const cmd = parser.parse(command);\n      const useNeovim = configuration.enableNeovim && cmd.command && cmd.command.neovimCapable();\n\n      if (useNeovim && vimState.nvim) {\n        const { statusBarText, error } = await vimState.nvim.run(vimState, command);\n        StatusBar.setText(vimState, statusBarText, error);\n      } else {\n        await cmd.execute(vimState);\n      }\n    } catch (e) {\n      if (e instanceof VimError) {\n        if (\n          e.code === ErrorCode.NotAnEditorCommand &&\n          configuration.enableNeovim &&\n          vimState.nvim\n        ) {\n          const { statusBarText } = await vimState.nvim.run(vimState, command);\n          StatusBar.setText(vimState, statusBarText, true);\n        } else {\n          StatusBar.setText(vimState, e.toString(), true);\n        }\n      } else {\n        this._logger.error(`Error executing cmd=${command}. err=${e}.`);\n      }\n    }\n  }\n\n  /**\n   * Prompts the user for a command using an InputBox, and runs the provided command\n   */\n  public async PromptAndRun(initialText: string, vimState: VimState): Promise<void> {\n    const cmd = await vscode.window.showInputBox(this.getInputBoxOptions(initialText));\n    await this.Run(cmd!, vimState);\n  }\n\n  private getInputBoxOptions(text: string): vscode.InputBoxOptions {\n    return {\n      prompt: 'Vim command line',\n      value: text,\n      ignoreFocusOut: false,\n      valueSelection: [text.length, text.length],\n    };\n  }\n\n  public async showHistory(initialText: string): Promise<string | undefined> {\n    this._history.add(initialText);\n\n    return vscode.window.showQuickPick(this._history.get().slice().reverse(), {\n      placeHolder: 'Vim command history',\n      ignoreFocusOut: false,\n    });\n  }\n}\n\nexport const commandLine = new CommandLine();\n","import * as vscode from 'vscode';\n\nimport * as node from '../node';\nimport { VimState } from '../../state/vimState';\nimport { PositionDiff, PositionDiffType } from '../../common/motion/position';\nimport { externalCommand } from '../../util/externalCommand';\nimport { Range } from '../../common/motion/range';\nimport { Position } from 'vscode';\n\nexport interface IBangCommandArguments extends node.ICommandArgs {\n  command: string;\n}\n\nexport class BangCommand extends node.CommandBase {\n  protected _arguments: IBangCommandArguments;\n\n  constructor(args: IBangCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  public neovimCapable(): boolean {\n    return true;\n  }\n\n  private getReplaceDiff(text: string): PositionDiff {\n    const lines = text.split('\\n');\n    const numNewlines = lines.length - 1;\n    const check = lines[0].match(/^\\s*/);\n    const numWhitespace = check ? check[0].length : 0;\n\n    return new PositionDiff({\n      line: -numNewlines,\n      character: numWhitespace,\n      type: PositionDiffType.ExactCharacter,\n    });\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await externalCommand.run(this._arguments.command);\n  }\n\n  async executeWithRange(vimState: VimState, range: node.LineRange): Promise<void> {\n    const [startLine, endLine] = range.resolve(vimState);\n    const start = new Position(startLine, 0);\n    const end = new Position(endLine, 0).getLineEnd();\n\n    // pipe in stdin from lines in range\n    const input = vimState.document.getText(new vscode.Range(start, end));\n    const output = await externalCommand.run(this._arguments.command, input);\n\n    // place cursor at the start of the replaced text and first non-whitespace character\n    const diff = this.getReplaceDiff(output);\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      text: output,\n      range: new Range(start, end),\n      diff,\n    });\n  }\n}\n","import * as vscode from 'vscode';\n\nimport * as error from '../../error';\nimport { VimState } from '../../state/vimState';\nimport * as node from '../node';\n\nexport interface IBufferDeleteCommandArguments extends node.ICommandArgs {\n  bang?: boolean;\n  tabPosition?: string;\n}\n\n//\n//  Implements :bd\n// http://vimdoc.sourceforge.net/htmldoc/windows.html#buffers\n//\nexport class BufferDeleteCommand extends node.CommandBase {\n  protected _arguments: IBufferDeleteCommandArguments;\n\n  constructor(args: IBufferDeleteCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IBufferDeleteCommandArguments {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (vimState.document.isDirty && !this.arguments.bang) {\n      throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n    }\n\n    if (this.arguments.tabPosition !== undefined) {\n      try {\n        await vscode.commands.executeCommand(\n          `workbench.action.openEditorAtIndex${this.arguments.tabPosition}`\n        );\n      } catch (e) {\n        throw error.VimError.fromCode(error.ErrorCode.NoBuffersDeleted);\n      }\n    }\n\n    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n  }\n}\n","import * as vscode from 'vscode';\n\nimport * as error from '../../error';\nimport { VimState } from '../../state/vimState';\nimport * as node from '../node';\n\nexport interface ICloseCommandArguments extends node.ICommandArgs {\n  bang?: boolean;\n  range?: node.LineRange;\n  quitAll?: boolean;\n}\n\n//\n//  Implements :close\n//  http://vimdoc.sourceforge.net/htmldoc/windows.html#:close\n//\nexport class CloseCommand extends node.CommandBase {\n  protected _arguments: ICloseCommandArguments;\n\n  constructor(args: ICloseCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): ICloseCommandArguments {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (vimState.document.isDirty && !this.arguments.bang) {\n      throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n    }\n\n    if (vscode.window.visibleTextEditors.length === 1) {\n      throw error.VimError.fromCode(error.ErrorCode.CannotCloseLastWindow);\n    }\n\n    const oldViewColumn = vimState.editor.viewColumn;\n    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n\n    if (\n      vscode.window.activeTextEditor !== undefined &&\n      vscode.window.activeTextEditor.viewColumn === oldViewColumn\n    ) {\n      await vscode.commands.executeCommand('workbench.action.previousEditor');\n    }\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { Register, RegisterMode } from '../../register/register';\nimport { TextEditor } from '../../textEditor';\nimport * as node from '../node';\nimport { configuration } from '../../configuration/configuration';\nimport { Position } from 'vscode';\n\nexport interface IDeleteRangeCommandArguments extends node.ICommandArgs {\n  register?: string;\n}\n\nexport class DeleteRangeCommand extends node.CommandBase {\n  protected _arguments: IDeleteRangeCommandArguments;\n\n  constructor(args: IDeleteRangeCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IDeleteRangeCommandArguments {\n    return this._arguments;\n  }\n\n  public neovimCapable(): boolean {\n    return true;\n  }\n\n  /**\n   * Deletes text between `startLine` and `endLine`, inclusive.\n   * Puts the cursor at the start of the line where the deleted range was.\n   *\n   * @returns The deleted text, excluding leading/trailing newline\n   */\n  async deleteRange(startLine: number, endLine: number, vimState: VimState): Promise<string> {\n    let start = new Position(startLine, 0);\n    let end = new Position(endLine, 0).getLineEndIncludingEOL();\n\n    if (endLine < vimState.document.lineCount - 1) {\n      end = end.getRightThroughLineBreaks();\n    } else if (startLine > 0) {\n      start = start.getLeftThroughLineBreaks();\n    }\n\n    const range = new vscode.Range(start, end);\n    const text = vimState.document\n      .getText(range)\n      // Remove leading or trailing newline\n      .replace(/^\\r?\\n/, '')\n      .replace(/\\r?\\n$/, '');\n    await TextEditor.delete(vimState.editor, range);\n\n    vimState.cursorStopPosition = start.getLineBegin();\n    return text;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (!vimState.editor) {\n      return;\n    }\n\n    const line = vimState.cursorStopPosition.line;\n    const text = await this.deleteRange(line, line, vimState);\n    const register = this._arguments.register ?? (configuration.useSystemClipboard ? '*' : '\"');\n    Register.putByKey(text, register, RegisterMode.LineWise);\n  }\n\n  async executeWithRange(vimState: VimState, range: node.LineRange): Promise<void> {\n    const [start, end] = range.resolve(vimState);\n\n    const text = await this.deleteRange(start, end, vimState);\n    const register = this._arguments.register ?? (configuration.useSystemClipboard ? '*' : '\"');\n    Register.putByKey(text, register, RegisterMode.LineWise);\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from './../../configuration/configuration';\nimport { VimState } from '../../state/vimState';\nimport { DefaultDigraphs } from '../../actions/commands/digraphs';\nimport * as node from '../node';\nimport { TextEditor } from '../../textEditor';\n\nexport interface IDigraphsCommandArguments extends node.ICommandArgs {\n  arg?: string;\n}\n\ninterface DigraphQuickPickItem extends vscode.QuickPickItem {\n  charCodes: number[];\n}\n\nexport class DigraphsCommand extends node.CommandBase {\n  protected _arguments: IDigraphsCommandArguments;\n\n  constructor(args: IDigraphsCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IDigraphsCommandArguments {\n    return this._arguments;\n  }\n\n  // TODO: replace 'any' with sensible index signature\n  private makeQuickPicks(digraphs: any): DigraphQuickPickItem[] {\n    const quickPicks = new Array<DigraphQuickPickItem>();\n    for (const digraphKey of Object.keys(digraphs)) {\n      const [charDesc, charCodes] = digraphs[digraphKey];\n      quickPicks.push({\n        label: digraphKey,\n        description: `${charDesc} (user)`,\n        charCodes,\n      });\n    }\n    return quickPicks;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.arguments.arg !== undefined && this.arguments.arg.length > 2) {\n      // TODO: Register digraphs in args in state\n    }\n    const digraphKeyAndContent = this.makeQuickPicks(configuration.digraphs).concat(\n      this.makeQuickPicks(DefaultDigraphs)\n    );\n\n    vscode.window.showQuickPick(digraphKeyAndContent).then(async (val) => {\n      if (val) {\n        const char = String.fromCharCode(...val.charCodes);\n        await TextEditor.insert(vimState.editor, char);\n      }\n    });\n  }\n}\n","import * as vscode from 'vscode';\nimport { Logger } from '../../util/logger';\nimport { getPathDetails, resolveUri } from '../../util/path';\nimport * as node from '../node';\nimport { doesFileExist } from 'platform/fs';\nimport untildify = require('untildify');\nimport { VimState } from '../../state/vimState';\n\nexport enum FilePosition {\n  NewWindowVerticalSplit,\n  NewWindowHorizontalSplit,\n}\n\nexport interface IFileCommandArguments extends node.ICommandArgs {\n  name: string | undefined;\n  bang?: boolean;\n  position?: FilePosition;\n  lineNumber?: number;\n  createFileIfNotExists?: boolean;\n}\n\nexport class FileCommand extends node.CommandBase {\n  protected _arguments: IFileCommandArguments;\n  private readonly _logger = Logger.get('File');\n\n  constructor(args: IFileCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IFileCommandArguments {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.arguments.bang) {\n      await vscode.commands.executeCommand('workbench.action.files.revert');\n      return;\n    }\n\n    // Need to do this before the split since it loses the activeTextEditor\n    const editorFileUri = vscode.window.activeTextEditor!.document.uri;\n    const editorFilePath = editorFileUri.fsPath;\n\n    // Do the split if requested\n    let split = false;\n    if (this.arguments.position === FilePosition.NewWindowVerticalSplit) {\n      await vscode.commands.executeCommand('workbench.action.splitEditorRight');\n      split = true;\n    }\n    if (this.arguments.position === FilePosition.NewWindowHorizontalSplit) {\n      await vscode.commands.executeCommand('workbench.action.splitEditorDown');\n      split = true;\n    }\n\n    const hidePreviousEditor = async () => {\n      if (split === true) {\n        await vscode.commands.executeCommand('workbench.action.previousEditor');\n        await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n      }\n    };\n\n    // No name was specified\n    if (this.arguments.name === undefined) {\n      if (this.arguments.createFileIfNotExists === true) {\n        await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n        await hidePreviousEditor();\n      }\n      return;\n    }\n\n    // Only untidify when the currently open page and file completion is local\n    if (this.arguments.name && editorFileUri.scheme === 'file') {\n      this._arguments.name = untildify(this.arguments.name);\n    }\n\n    let fileUri = editorFileUri;\n    // Using the empty string will request to open a file\n    if (this.arguments.name === '') {\n      // No name on split is fine and just return\n      if (split === true) {\n        return;\n      }\n\n      const fileList = await vscode.window.showOpenDialog({});\n      if (fileList && fileList.length > 0) {\n        fileUri = fileList[0];\n      }\n    } else {\n      // remove file://\n      this._arguments.name = this.arguments.name.replace(/^file:\\/\\//, '');\n\n      // Using a filename, open or create the file\n      const isRemote = !!vscode.env.remoteName;\n      const { fullPath, path: p } = getPathDetails(this.arguments.name, editorFileUri, isRemote);\n      // Only if the expanded path of the full path is different than\n      // the currently opened window path\n      if (fullPath !== editorFilePath) {\n        const uriPath = resolveUri(fullPath, p.sep, editorFileUri, isRemote);\n        if (uriPath === null) {\n          // return if the path is invalid\n          return;\n        }\n\n        let fileExists = await doesFileExist(uriPath);\n        if (fileExists) {\n          // If the file without the added ext exists\n          fileUri = uriPath;\n        } else {\n          // if file does not exist\n          // try to find it with the same extension as the current file\n          const pathWithExt = fullPath + p.extname(editorFilePath);\n          const uriPathWithExt = resolveUri(pathWithExt, p.sep, editorFileUri, isRemote);\n          if (uriPathWithExt !== null) {\n            fileExists = await doesFileExist(uriPathWithExt);\n            if (fileExists) {\n              // if the file with the added ext exists\n              fileUri = uriPathWithExt;\n            }\n          }\n        }\n\n        // If both with and without ext path do not exist\n        if (!fileExists) {\n          if (this.arguments.createFileIfNotExists) {\n            // Change the scheme to untitled to open an\n            // untitled tab\n            fileUri = uriPath.with({ scheme: 'untitled' });\n          } else {\n            this._logger.error(`${this.arguments.name} does not exist.`);\n            return;\n          }\n        }\n      }\n    }\n\n    const doc = await vscode.workspace.openTextDocument(fileUri);\n    vscode.window.showTextDocument(doc);\n\n    if (this.arguments.lineNumber) {\n      vscode.window.activeTextEditor!.revealRange(\n        new vscode.Range(\n          new vscode.Position(this.arguments.lineNumber, 0),\n          new vscode.Position(this.arguments.lineNumber, 0)\n        )\n      );\n    }\n    await hidePreviousEditor();\n  }\n}\n","import { CommandBase } from '../node';\nimport { VimState } from '../../state/vimState';\nimport { reportFileInfo } from '../../util/statusBarTextUtils';\n\nexport class FileInfoCommand extends CommandBase {\n  async execute(vimState: VimState): Promise<void> {\n    reportFileInfo(vimState.cursors[0].start, vimState);\n  }\n}\n","import { ErrorCode, VimError } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport * as node from '../node';\nimport { Scanner } from '../scanner';\n\nexport class GotoCommand extends node.CommandBase {\n  public static parse(args: string): GotoCommand {\n    if (args.trim() === '') {\n      return new GotoCommand();\n    }\n\n    const scanner = new Scanner(args);\n    const offset = parseInt(scanner.nextWord(), 10);\n    if (isNaN(offset)) {\n      throw VimError.fromCode(ErrorCode.TrailingCharacters);\n    }\n    return new GotoCommand(offset);\n  }\n\n  private offset?: number;\n  private constructor(offset?: number) {\n    super();\n    this.offset = offset;\n  }\n\n  private gotoOffset(vimState: VimState, offset: number) {\n    vimState.cursorStopPosition = vimState.document.positionAt(offset);\n  }\n\n  public async execute(vimState: VimState): Promise<void> {\n    this.gotoOffset(vimState, this.offset ?? 0);\n  }\n\n  public async executeWithRange(vimState: VimState, range: node.LineRange): Promise<void> {\n    if (this.offset === undefined) {\n      // TODO: this isn't perfect (% for instance), but does anyone care?\n      this.offset = range.resolve(vimState, false)[1];\n    }\n    this.gotoOffset(vimState, this.offset);\n  }\n}\n","import { CommandBase, ICommandArgs } from '../node';\nimport { VimState } from '../../state/vimState';\nimport {\n  CommandShowSearchHistory,\n  CommandShowCommandHistory,\n} from '../../actions/commands/actions';\nimport { SearchDirection } from '../../state/searchState';\n\nexport enum HistoryCommandType {\n  Cmd,\n  Search,\n  Expr,\n  Input,\n  Debug,\n  All,\n}\n\nexport interface IHistoryCommandArguments extends ICommandArgs {\n  type: HistoryCommandType;\n  // TODO: :history can accept multiple types\n  // TODO: :history can also accept a range\n}\n\n// http://vimdoc.sourceforge.net/htmldoc/cmdline.html#:history\nexport class HistoryCommand extends CommandBase {\n  protected _arguments: IHistoryCommandArguments;\n\n  constructor(args: IHistoryCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IHistoryCommandArguments {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    switch (this._arguments.type) {\n      case HistoryCommandType.Cmd:\n        await new CommandShowCommandHistory().exec(vimState.cursorStopPosition, vimState);\n        break;\n      case HistoryCommandType.Search:\n        await new CommandShowSearchHistory(SearchDirection.Forward).exec(\n          vimState.cursorStopPosition,\n          vimState\n        );\n        break;\n      // TODO: Implement these\n      case HistoryCommandType.Expr:\n        throw new Error('Not implemented');\n      case HistoryCommandType.Input:\n        throw new Error('Not implemented');\n      case HistoryCommandType.Debug:\n        throw new Error('Not implemented');\n      case HistoryCommandType.All:\n        throw new Error('Not implemented');\n    }\n  }\n}\n","import { window, QuickPickItem } from 'vscode';\n\nimport * as node from '../node';\nimport { VimState } from '../../state/vimState';\nimport { globalState } from '../../state/globalState';\nimport { Jump } from '../../jumps/jump';\nimport { Range } from '../../common/motion/range';\n\nclass JumpPickItem implements QuickPickItem {\n  jump: Jump;\n\n  label: string;\n  description?: string;\n  detail?: string;\n  picked?: boolean;\n  alwaysShow?: boolean;\n\n  constructor(jump: Jump, idx: number) {\n    this.jump = jump;\n    this.label = jump.fileName;\n    this.detail = `jump ${idx} line ${jump.position.line + 1} col ${jump.position.character}`;\n    try {\n      this.description = jump.editor?.document.lineAt(jump.position)?.text;\n    } catch (e) {\n      this.description = undefined;\n    }\n  }\n}\n\nexport class JumpsCommand extends node.CommandBase {\n  async execute(vimState: VimState): Promise<void> {\n    const jumpTracker = globalState.jumpTracker;\n    if (jumpTracker.hasJumps) {\n      const quickPickItems = jumpTracker.jumps.map((jump, idx) => new JumpPickItem(jump, idx));\n      const item = await window.showQuickPick(quickPickItems, {\n        canPickMany: false,\n      });\n      if (item && item.jump.editor != null) {\n        window.showTextDocument(item.jump.editor.document);\n        vimState.cursors = [new Range(item.jump.position, item.jump.position)];\n      }\n    } else {\n      window.showInformationMessage('No jumps available');\n    }\n  }\n}\n\nexport class ClearJumpsCommand extends node.CommandBase {\n  async execute(vimState: VimState): Promise<void> {\n    const jumpTracker = globalState.jumpTracker;\n    jumpTracker.clearJumps();\n  }\n}\n","import { window, QuickPickItem } from 'vscode';\n\nimport * as node from '../node';\nimport { VimState } from '../../state/vimState';\nimport { IMark } from '../../history/historyTracker';\nimport { Range } from '../../common/motion/range';\nimport { StatusBar } from '../../statusBar';\nimport { ErrorCode, VimError } from '../../error';\n\nclass MarkQuickPickItem implements QuickPickItem {\n  mark: IMark;\n\n  label: string;\n  description: string;\n  detail: string;\n  picked = false;\n  alwaysShow = false;\n\n  constructor(vimState: VimState, mark: IMark) {\n    this.mark = mark;\n    this.label = mark.name;\n    this.description = vimState.document.lineAt(mark.position).text.trim();\n    this.detail = `line ${mark.position.line} col ${mark.position.character}`;\n  }\n}\n\nexport class MarksCommand extends node.CommandBase {\n  private marksFilter?: string[];\n\n  constructor(marksFilter?: string[]) {\n    super();\n    this.marksFilter = marksFilter;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const quickPickItems: MarkQuickPickItem[] = vimState.historyTracker\n      .getMarks()\n      .filter((mark) => {\n        return !this.marksFilter || this.marksFilter.includes(mark.name);\n      })\n      .map((mark) => new MarkQuickPickItem(vimState, mark));\n\n    if (quickPickItems.length > 0) {\n      const item = await window.showQuickPick(quickPickItems, {\n        canPickMany: false,\n      });\n      if (item) {\n        vimState.cursors = [new Range(item.mark.position, item.mark.position)];\n      }\n    } else {\n      window.showInformationMessage('No marks set');\n    }\n  }\n}\n\nexport class DeleteMarksCommand extends node.CommandBase {\n  private numbers = '0123456789';\n  private numberRange = /([0-9])-([0-9])/;\n  private letterRange = /([a-zA-Z])-([a-zA-Z])/;\n  private args?: string;\n\n  constructor(args?: string) {\n    super();\n    this.args = args;\n  }\n\n  range(start: number, end: number): number[] {\n    const range: number[] = [];\n    for (let i = start; i <= end; i++) {\n      range.push(i);\n    }\n    return range;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (!this.args) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.ArgumentRequired));\n      return;\n    }\n\n    if (this.args === '!') {\n      vimState.historyTracker.removeLocalMarks();\n      return;\n    }\n\n    if (!this.args.includes('-')) {\n      vimState.historyTracker.removeMarks(this.args.split(''));\n      return;\n    }\n\n    const numberArgs: any = this.numberRange.exec(this.args);\n    let letterArgs: any = this.letterRange.exec(this.args);\n\n    if (!numberArgs && !letterArgs && this.args.includes('-')) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidArgument));\n      return;\n    }\n\n    if (numberArgs && numberArgs.length > 2) {\n      if (parseInt(numberArgs[1], 10) > parseInt(numberArgs[2], 10)) {\n        StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidArgument));\n        return;\n      }\n\n      const start = this.numbers.indexOf(numberArgs[1]);\n      const end = this.numbers.indexOf(numberArgs[2]);\n      vimState.historyTracker.removeMarks(this.numbers.substring(start, end + 1).split(''));\n    }\n\n    while (letterArgs && letterArgs.length > 2) {\n      if (this.caseMismatch(letterArgs[1], letterArgs[2])) {\n        StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidArgument));\n        return;\n      }\n\n      const lowerCase = letterArgs[1] === letterArgs[1].toLowerCase();\n\n      const letters = lowerCase ? 'abcdefghijklmnopqrstuvwxyz' : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n      const start = letters.indexOf(letterArgs[1]);\n      const end = letters.indexOf(letterArgs[2]);\n\n      if (start > end) {\n        StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidArgument));\n        return;\n      }\n\n      vimState.historyTracker.removeMarks(letters.substring(start, end + 1).split(''));\n\n      this.args = this.args.replace(letterArgs[0], '');\n      letterArgs = this.letterRange.exec(this.args);\n    }\n  }\n\n  caseMismatch(a: string, b: string): boolean {\n    return (\n      (a.toLowerCase() === a && b !== b.toLowerCase()) ||\n      (b.toLowerCase() === b && a !== a.toLowerCase())\n    );\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport * as node from '../node';\nimport { globalState } from '../../state/globalState';\nimport { StatusBar } from '../../statusBar';\n\nexport class NohlCommand extends node.CommandBase {\n  protected _arguments: {};\n\n  constructor(args: {}) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): {} {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    globalState.hl = false;\n\n    // Clear the `match x of y` message from status bar\n    StatusBar.clear(vimState);\n  }\n}\n","import * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\n\nimport * as node from '../node';\n\nexport class OnlyCommand extends node.CommandBase {\n  protected _arguments: {};\n\n  constructor(args: {}) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): {} {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await Promise.all([\n      vscode.commands.executeCommand('workbench.action.closeEditorsInOtherGroups'),\n      vscode.commands.executeCommand('workbench.action.maximizeEditor'),\n      vscode.commands.executeCommand('workbench.action.closePanel'),\n    ]);\n  }\n}\n","import * as node from '../node';\nimport { VimState } from '../../state/vimState';\nimport { configuration } from '../../configuration/configuration';\n\nimport { PutCommand, IPutCommandOptions } from '../../actions/commands/put';\nimport { Register } from '../../register/register';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { Position } from 'vscode';\n\nexport interface IPutCommandArguments extends node.ICommandArgs {\n  bang?: boolean;\n  register?: string;\n}\n\n//\n// Implements :put\n// http://vimdoc.sourceforge.net/htmldoc/change.html#:put\n//\n\nexport class PutExCommand extends node.CommandBase {\n  protected _arguments: IPutCommandArguments;\n\n  constructor(args: IPutCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IPutCommandArguments {\n    return this._arguments;\n  }\n\n  public neovimCapable(): boolean {\n    return true;\n  }\n\n  async doPut(vimState: VimState, position: Position): Promise<void> {\n    const registerName = this.arguments.register || (configuration.useSystemClipboard ? '*' : '\"');\n    if (!Register.isValidRegister(registerName)) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.TrailingCharacters));\n      return;\n    }\n\n    vimState.recordedState.registerName = registerName;\n\n    const options: IPutCommandOptions = {\n      forceLinewise: true,\n      forceCursorLastLine: true,\n      pasteBeforeCursor: this.arguments.bang,\n    };\n\n    await new PutCommand().exec(position, vimState, options);\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await this.doPut(vimState, vimState.cursorStopPosition);\n  }\n\n  async executeWithRange(vimState: VimState, range: node.LineRange): Promise<void> {\n    const [_, end] = range.resolve(vimState);\n    await this.doPut(vimState, new Position(end, 0).getLineEnd());\n  }\n}\n","import * as vscode from 'vscode';\n\nimport * as error from '../../error';\nimport { VimState } from '../../state/vimState';\nimport * as node from '../node';\n\nexport interface IQuitCommandArguments extends node.ICommandArgs {\n  bang?: boolean;\n  range?: node.LineRange;\n  quitAll?: boolean;\n}\n\n//\n//  Implements :quit\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:quit\n//\nexport class QuitCommand extends node.CommandBase {\n  protected _arguments: IQuitCommandArguments;\n\n  constructor(args: IQuitCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IQuitCommandArguments {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // NOTE: We can't currently get all open text editors, so this isn't perfect. See #3809\n    const duplicatedInSplit =\n      vscode.window.visibleTextEditors.filter((editor) => editor.document === vimState.document)\n        .length > 1;\n    if (\n      vimState.document.isDirty &&\n      !this.arguments.bang &&\n      (!duplicatedInSplit || this._arguments.quitAll)\n    ) {\n      throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n    }\n\n    if (this._arguments.quitAll) {\n      await vscode.commands.executeCommand('workbench.action.closeAllEditors');\n    } else {\n      if (!this.arguments.bang) {\n        await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n      } else {\n        await vscode.commands.executeCommand('workbench.action.revertAndCloseActiveEditor');\n      }\n    }\n  }\n}\n","import { TextEditor } from '../../textEditor';\nimport * as node from '../node';\nimport { readFileAsync } from 'platform/fs';\nimport { SUPPORT_READ_COMMAND } from 'platform/constants';\nimport { VimState } from '../../state/vimState';\n\nexport interface IReadCommandArguments extends node.ICommandArgs {\n  file?: string;\n  cmd?: string;\n}\n\n//\n//  Implements :read and :read!\n//  http://vimdoc.sourceforge.net/htmldoc/insert.html#:read\n//  http://vimdoc.sourceforge.net/htmldoc/insert.html#:read!\n//\nexport class ReadCommand extends node.CommandBase {\n  protected _arguments: IReadCommandArguments;\n\n  constructor(args: IReadCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IReadCommandArguments {\n    return this._arguments;\n  }\n\n  public neovimCapable(): boolean {\n    return true;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const textToInsert = await this.getTextToInsert();\n    if (textToInsert) {\n      await TextEditor.insert(vimState.editor, textToInsert);\n    }\n  }\n\n  async getTextToInsert(): Promise<string> {\n    if (this.arguments.file && this.arguments.file.length > 0) {\n      return this.getTextToInsertFromFile();\n    } else if (this.arguments.cmd && this.arguments.cmd.length > 0) {\n      return this.getTextToInsertFromCmd();\n    } else {\n      throw Error('Invalid arguments');\n    }\n  }\n\n  async getTextToInsertFromFile(): Promise<string> {\n    // TODO: Read encoding from ++opt argument.\n    try {\n      const data = await readFileAsync(this.arguments.file as string, 'utf8');\n      return data;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async getTextToInsertFromCmd(): Promise<string> {\n    if (SUPPORT_READ_COMMAND) {\n      return new Promise<string>((resolve, reject) => {\n        try {\n          import('child_process').then((cp) => {\n            return cp.exec(this.arguments.cmd as string, (err, stdout, stderr) => {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(stdout);\n              }\n            });\n          });\n        } catch (e) {\n          reject(e);\n        }\n      });\n    } else {\n      return '';\n    }\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { Register } from '../../register/register';\nimport { RecordedState } from '../../state/recordedState';\nimport * as node from '../node';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\n\nexport interface IRegisterCommandArguments extends node.ICommandArgs {\n  registers: string[];\n}\nexport class RegisterCommand extends node.CommandBase {\n  protected _arguments: IRegisterCommandArguments;\n\n  constructor(args: IRegisterCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IRegisterCommandArguments {\n    return this._arguments;\n  }\n\n  private async getRegisterDisplayValue(\n    vimState: VimState,\n    register: string\n  ): Promise<string | undefined> {\n    let result = (await Register.get(vimState, register))?.text;\n    if (result instanceof Array) {\n      result = result.join('\\n').substr(0, 100);\n    } else if (result instanceof RecordedState) {\n      result = result.actionsRun.map((x) => x.keysPressed.join('')).join('');\n    }\n\n    return result;\n  }\n\n  async displayRegisterValue(vimState: VimState, register: string): Promise<void> {\n    let result = await this.getRegisterDisplayValue(vimState, register);\n    if (result === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister));\n    } else {\n      result = result.replace(/\\n/g, '\\\\n');\n      vscode.window.showInformationMessage(`${register} ${result}`);\n    }\n  }\n\n  private regSortOrder(register: string): number {\n    const specials = ['-', '*', '+', '.', ':', '%', '#', '/', '='];\n    if (register === '\"') {\n      return 0;\n    } else if (register >= '0' && register <= '9') {\n      return 10 + parseInt(register, 10);\n    } else if (register >= 'a' && register <= 'z') {\n      return 100 + (register.charCodeAt(0) - 'a'.charCodeAt(0));\n    } else if (specials.includes(register)) {\n      return 1000 + specials.indexOf(register);\n    } else {\n      throw new Error(`Unexpected register ${register}`);\n    }\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.arguments.registers.length === 1) {\n      await this.displayRegisterValue(vimState, this.arguments.registers[0]);\n    } else {\n      const currentRegisterKeys = Register.getKeys()\n        .filter(\n          (reg) =>\n            reg !== '_' &&\n            (this.arguments.registers.length === 0 || this.arguments.registers.includes(reg))\n        )\n        .sort((reg1: string, reg2: string) => this.regSortOrder(reg1) - this.regSortOrder(reg2));\n      const registerKeyAndContent = new Array<vscode.QuickPickItem>();\n\n      for (const registerKey of currentRegisterKeys) {\n        registerKeyAndContent.push({\n          label: registerKey,\n          description: await this.getRegisterDisplayValue(vimState, registerKey),\n        });\n      }\n\n      vscode.window.showQuickPick(registerKeyAndContent).then(async (val) => {\n        if (val) {\n          const result = val.description;\n          vscode.window.showInformationMessage(`${val.label} ${result}`);\n        }\n      });\n    }\n  }\n}\n","import * as node from '../node';\nimport { configuration, optionAliases } from '../../configuration/configuration';\nimport { VimError, ErrorCode } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\n\nexport enum SetOptionOperator {\n  /*\n   * Set string or number option to {value}.\n   * White space between {option} and '=' is allowed and will be ignored.  White space between '=' and {value} is not allowed.\n   */\n  Equal,\n  /*\n   * Toggle option: set, switch it on.\n   * Number option: show value.\n   * String option: show value.\n   */\n  Set,\n  /*\n   * Toggle option: Reset, switch it off.\n   */\n  Reset,\n  /**\n   * Toggle option: Insert value.\n   */\n  Invert,\n  /*\n   * Add the {value} to a number option, or append the {value} to a string option.\n   * When the option is a comma separated list, a comma is added, unless the value was empty.\n   */\n  Append,\n  /*\n   * Subtract the {value} from a number option, or remove the {value} from a string option, if it is there.\n   */\n  Subtract,\n  /**\n   * Multiply the {value} to a number option, or prepend the {value} to a string option.\n   */\n  Multiply,\n  /**\n   * Show value of {option}.\n   */\n  Info,\n}\n\nexport interface IOptionArgs extends node.ICommandArgs {\n  name?: string;\n  operator?: SetOptionOperator;\n  value?: string | number | boolean;\n}\n\nexport class SetOptionsCommand extends node.CommandBase {\n  protected _arguments: IOptionArgs;\n\n  constructor(args: IOptionArgs) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IOptionArgs {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (!this._arguments.name) {\n      throw new Error('Missing argument.');\n    }\n\n    const optionName = optionAliases.get(this._arguments.name) ?? this._arguments.name;\n\n    if (configuration[optionName] == null) {\n      throw VimError.fromCode(ErrorCode.UnknownOption);\n    }\n\n    switch (this._arguments.operator) {\n      case SetOptionOperator.Set:\n        configuration[optionName] = true;\n        break;\n      case SetOptionOperator.Reset:\n        configuration[optionName] = false;\n        break;\n      case SetOptionOperator.Equal:\n        configuration[optionName] = this._arguments.value!;\n        break;\n      case SetOptionOperator.Invert:\n        configuration[optionName] = !configuration[optionName];\n        break;\n      case SetOptionOperator.Append:\n        configuration[optionName] += this._arguments.value!;\n        break;\n      case SetOptionOperator.Subtract:\n        if (typeof this._arguments.value! === 'number') {\n          configuration[optionName] -= this._arguments.value;\n        } else {\n          const initialValue = configuration[optionName];\n          configuration[optionName] = initialValue.split(this._arguments.value! as string).join('');\n        }\n        break;\n      case SetOptionOperator.Info:\n        const value = configuration[optionName];\n        if (value === undefined) {\n          throw VimError.fromCode(ErrorCode.UnknownOption);\n        } else {\n          StatusBar.setText(vimState, `${optionName}=${value}`);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n}\n","import * as node from '../node';\nimport { window } from 'vscode';\nimport { VimState } from '../../state/vimState';\n\nexport class ShCommand extends node.CommandBase {\n  async execute(vimState: VimState): Promise<void> {\n    window.createTerminal().show();\n  }\n}\n","import * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { TextEditor } from '../../textEditor';\nimport * as node from '../node';\n\nexport class SmileCommand extends node.CommandBase {\n  static readonly smileText: string = `\n                               oooo$$$$$$$$$$$$oooo\n                          oo$$$$$$$$$$$$$$$$$$$$$$$$o\n                       oo$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o         o$   $$ o$\n     o $ oo          o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o       $$ $$ $$o$\n    oo $ $ \"$      o$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$o       $$$o$$o$\n    \"$$$$$$o$     o$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$o    $$$$$$$$\n      $$$$$$$    $$$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$$$$$$$$$$$$$$\n      $$$$$$$$$$$$$$$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$$$$$$  \"\"\"$$$\n       \"$$$\"\"\"\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     \"$$$\n        $$$   o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     \"$$$o\n       o$$\"   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$       $$$o\n       $$$    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\" \"$$$$$$ooooo$$$$o\n      o$$$oooo$$$$$  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$   o$$$$$$$$$$$$$$$$$\n      $$$$$$$$\"$$$$   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     $$$$\"\"\"\"\"\"\"\"\n     \"\"\"\"       $$$$    \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$\"      o$$$\n                \"$$$o     \"\"\"$$$$$$$$$$$$$$$$$$\"$$\"         $$$\n                  $$$o          \"$$\"\"$$$$$$\"\"\"\"           o$$$\n                   $$$$o                                o$$$\"\n                    \"$$$$o      o$$$$$$o\"$$$$o        o$$$$\n                      \"$$$$$oo     \"\"$$$$o$$$$$o   o$$$$\"\"\n                         \"\"$$$$$oooo  \"$$$o$$$$$$$$$\"\"\"\n                            \"\"$$$$$$$oo $$$$$$$$$$\n                                    \"\"\"\"$$$$$$$$$$$\n                                        $$$$$$$$$$$$\n                                         $$$$$$$$$$\"\n                                          \"$$$\"\"\"\"`;\n\n  constructor() {\n    super();\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n    await TextEditor.insert(vscode.window.activeTextEditor!, SmileCommand.smileText);\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { isVisualMode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { TextEditor } from '../../textEditor';\nimport * as node from '../node';\n\nexport interface ISortCommandArguments extends node.ICommandArgs {\n  reverse: boolean;\n  ignoreCase: boolean;\n  unique: boolean;\n}\n\nexport class SortCommand extends node.CommandBase {\n  protected _arguments: ISortCommandArguments;\n\n  constructor(args: ISortCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): ISortCommandArguments {\n    return this._arguments;\n  }\n\n  public neovimCapable(): boolean {\n    return true;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (isVisualMode(vimState.currentMode)) {\n      const { start, end } = vimState.editor.selection;\n      await this.sortLines(vimState, start.line, end.line);\n    } else {\n      await this.sortLines(vimState, 0, vimState.document.lineCount - 1);\n    }\n  }\n\n  async sortLines(vimState: VimState, startLine: number, endLine: number) {\n    let originalLines: string[] = [];\n\n    for (\n      let currentLine = startLine;\n      currentLine <= endLine && currentLine < vimState.document.lineCount;\n      currentLine++\n    ) {\n      originalLines.push(vimState.document.lineAt(currentLine).text);\n    }\n    if (this._arguments.unique) {\n      originalLines = [...new Set(originalLines)];\n    }\n\n    const lastLineLength = originalLines[originalLines.length - 1].length;\n\n    const sortedLines = this._arguments.ignoreCase\n      ? originalLines.sort((a: string, b: string) => a.localeCompare(b))\n      : originalLines.sort();\n\n    if (this._arguments.reverse) {\n      sortedLines.reverse();\n    }\n\n    const sortedContent = sortedLines.join('\\n');\n\n    await TextEditor.replace(\n      vimState.editor,\n      new vscode.Range(startLine, 0, endLine, lastLineLength),\n      sortedContent\n    );\n  }\n\n  async executeWithRange(vimState: VimState, range: node.LineRange): Promise<void> {\n    const [start, end] = range.resolve(vimState);\n\n    await this.sortLines(vimState, start, end);\n  }\n}\n","/* tslint:disable:no-bitwise */\n\nimport * as vscode from 'vscode';\nimport * as node from '../node';\nimport { Jump } from '../../jumps/jump';\nimport { SearchState, SearchDirection } from '../../state/searchState';\nimport { SubstituteState } from '../../state/substituteState';\nimport { TextEditor } from '../../textEditor';\nimport { VimError, ErrorCode } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { configuration } from '../../configuration/configuration';\nimport { decoration } from '../../configuration/decoration';\nimport { globalState } from '../../state/globalState';\nimport { Position } from 'vscode';\n\n/**\n * NOTE: for \"pattern\", undefined is different from an empty string.\n * when it's undefined, it means to repeat the previous REPLACEMENT and ignore \"replace\".\n * when it's an empty string, it means to use the previous SEARCH (not replacement) state,\n * and replace with whatever's set by \"replace\" (even an empty string).\n */\nexport interface ISubstituteCommandArguments extends node.ICommandArgs {\n  pattern: string | undefined;\n  replace: string;\n  flags: number;\n  count?: number;\n}\n\n/**\n * The flags that you can use for the substitute commands:\n * [&] Must be the first one: Keep the flags from the previous substitute command.\n * [c] Confirm each substitution.\n * [e] When the search pattern fails, do not issue an error message and, in\n *     particular, continue in maps as if no error occurred.\n * [g] Replace all occurrences in the line.  Without this argument, replacement\n *     occurs only for the first occurrence in each line.\n * [i] Ignore case for the pattern.\n * [I] Don't ignore case for the pattern.\n * [n] Report the number of matches, do not actually substitute.\n * [p] Print the line containing the last substitute.\n * [#] Like [p] and prepend the line number.\n * [l] Like [p] but print the text like |:list|.\n * [r] When the search pattern is empty, use the previously used search pattern\n *     instead of the search pattern from the last substitute or \":global\".\n */\nexport enum SubstituteFlags {\n  None = 0,\n  KeepPreviousFlags = 0x1,\n  ConfirmEach = 0x2,\n  SuppressError = 0x4,\n  ReplaceAll = 0x8,\n  IgnoreCase = 0x10,\n  NoIgnoreCase = 0x20,\n  PrintCount = 0x40,\n  PrintLastMatchedLine = 0x80,\n  PrintLastMatchedLineWithNumber = 0x100,\n  PrintLastMatchedLineWithList = 0x200,\n  UsePreviousPattern = 0x400,\n}\n\n/**\n * vim has a distinctly different state for previous search and for previous substitute.  However, in SOME\n * cases a substitution will also update the search state along with the substitute state.\n *\n * Also, the substitute command itself will sometimes use the search state, and other times it will use the\n * substitute state.\n *\n * These are the following cases and how vim handles them:\n * 1. :s/this/that\n *   - standard search/replace\n *   - update substitution state\n *   - update search state too!\n * 2. :s or :s [flags]\n *   - use previous SUBSTITUTION state, and repeat previous substitution pattern and replace.\n *   - do not touch search state!\n *   - changing substitution state is dont-care cause we're repeating it ;)\n * 3. :s/ or :s// or :s///\n *   - use previous SEARCH state (not substitution), and DELETE the string matching the pattern (replace with nothing)\n *   - update substitution state\n *   - updating search state is dont-care cause we're repeating it ;)\n * 4. :s/this or :s/this/ or :s/this//\n *   - input is pattern - replacement is empty (delete)\n *   - update replacement state\n *   - update search state too!\n */\nexport class SubstituteCommand extends node.CommandBase {\n  protected _arguments: ISubstituteCommandArguments;\n  protected _abort: boolean;\n  constructor(args: ISubstituteCommandArguments) {\n    super();\n    this._arguments = args;\n    this._abort = false;\n  }\n\n  get arguments(): ISubstituteCommandArguments {\n    return this._arguments;\n  }\n\n  public neovimCapable(): boolean {\n    // We need to use VSCode's quickpick capabilities to do confirmation\n    return (this._arguments.flags & SubstituteFlags.ConfirmEach) === 0;\n  }\n\n  getRegex(args: ISubstituteCommandArguments, vimState: VimState) {\n    let jsRegexFlags = '';\n\n    if (configuration.gdefault || configuration.substituteGlobalFlag) {\n      // the gdefault flag is on, then /g if on by default and /g negates that\n      if (!(args.flags & SubstituteFlags.ReplaceAll)) {\n        jsRegexFlags += 'g';\n      }\n    } else {\n      // the gdefault flag is off, then /g means replace all\n      if (args.flags & SubstituteFlags.ReplaceAll) {\n        jsRegexFlags += 'g';\n      }\n    }\n\n    if (args.flags & SubstituteFlags.IgnoreCase) {\n      jsRegexFlags += 'i';\n    }\n\n    if (args.pattern === undefined) {\n      // If no pattern is entered, use previous SUBSTITUTION state and don't update search state\n      // i.e. :s\n      const prevSubstituteState = globalState.substituteState;\n      if (prevSubstituteState === undefined || prevSubstituteState.searchPattern === '') {\n        throw VimError.fromCode(ErrorCode.NoPreviousRegularExpression);\n      } else {\n        args.pattern = prevSubstituteState.searchPattern;\n        args.replace = prevSubstituteState.replaceString;\n      }\n    } else {\n      if (args.pattern === '') {\n        // If an explicitly empty pattern is entered, use previous search state (including search with * and #) and update both states\n        // e.g :s/ or :s///\n        const prevSearchState = globalState.searchState;\n        if (prevSearchState === undefined || prevSearchState.searchString === '') {\n          throw VimError.fromCode(ErrorCode.NoPreviousRegularExpression);\n        } else {\n          args.pattern = prevSearchState.searchString;\n        }\n      }\n      globalState.substituteState = new SubstituteState(args.pattern, args.replace);\n      globalState.searchState = new SearchState(\n        SearchDirection.Forward,\n        vimState.cursorStopPosition,\n        args.pattern,\n        { isRegex: true },\n        vimState.currentMode\n      );\n    }\n    return new RegExp(args.pattern, jsRegexFlags);\n  }\n\n  /**\n   * @returns whether the search pattern existed on the line\n   */\n  async replaceTextAtLine(line: number, regex: RegExp, vimState: VimState): Promise<boolean> {\n    const originalContent = vimState.document.lineAt(line).text;\n\n    if (!regex.test(originalContent)) {\n      return false;\n    }\n\n    if (this._arguments.flags & SubstituteFlags.ConfirmEach) {\n      // Loop through each match on this line and get confirmation before replacing\n      let newContent = originalContent;\n      const matches = newContent.match(regex)!;\n\n      const nonGlobalRegex = new RegExp(regex.source, regex.flags.replace('g', ''));\n      let matchPos = 0;\n\n      for (const match of matches) {\n        if (this._abort) {\n          break;\n        }\n\n        matchPos = newContent.indexOf(match, matchPos);\n\n        if (\n          !(this._arguments.flags & SubstituteFlags.ConfirmEach) ||\n          (await this.confirmReplacement(this._arguments.replace, line, vimState, match, matchPos))\n        ) {\n          const rangeEnd = newContent.length;\n          newContent =\n            newContent.slice(0, matchPos) +\n            newContent.slice(matchPos).replace(nonGlobalRegex, this._arguments.replace);\n          await TextEditor.replace(\n            vimState.editor,\n            new vscode.Range(line, 0, line, rangeEnd),\n            newContent\n          );\n\n          globalState.jumpTracker.recordJump(\n            new Jump({\n              editor: vimState.editor,\n              fileName: vimState.document.fileName,\n              position: new Position(line, 0),\n            }),\n            Jump.fromStateNow(vimState)\n          );\n        }\n        matchPos += this._arguments.replace.length;\n      }\n    } else {\n      await TextEditor.replace(\n        vimState.editor,\n        new vscode.Range(line, 0, line, originalContent.length),\n        originalContent.replace(regex, this._arguments.replace)\n      );\n\n      globalState.jumpTracker.recordJump(\n        new Jump({\n          editor: vimState.editor,\n          fileName: vimState.document.fileName,\n          position: new Position(line, 0),\n        }),\n        Jump.fromStateNow(vimState)\n      );\n    }\n\n    return true;\n  }\n\n  async confirmReplacement(\n    replacement: string,\n    line: number,\n    vimState: VimState,\n    match: string,\n    matchIndex: number\n  ): Promise<boolean> {\n    const cancellationToken = new vscode.CancellationTokenSource();\n    const validSelections: string[] = ['y', 'n', 'a', 'q', 'l'];\n    let selection: string = '';\n\n    const searchRanges: vscode.Range[] = [\n      new vscode.Range(line, matchIndex, line, matchIndex + match.length),\n    ];\n\n    vimState.editor.revealRange(new vscode.Range(line, 0, line, 0));\n    vimState.editor.setDecorations(decoration.searchHighlight, searchRanges);\n\n    const prompt = `Replace with ${replacement} (${validSelections.join('/')})?`;\n    await vscode.window.showInputBox(\n      {\n        ignoreFocusOut: true,\n        prompt,\n        placeHolder: validSelections.join('/'),\n        validateInput: (input: string): string => {\n          if (validSelections.includes(input)) {\n            selection = input;\n            cancellationToken.cancel();\n          }\n          return prompt;\n        },\n      },\n      cancellationToken.token\n    );\n\n    if (selection === 'q' || selection === 'l' || !selection) {\n      this._abort = true;\n    } else if (selection === 'a') {\n      this._arguments.flags = this._arguments.flags & ~SubstituteFlags.ConfirmEach;\n    }\n\n    return selection === 'y' || selection === 'a' || selection === 'l';\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const regex = this.getRegex(this._arguments, vimState);\n    const selection = vimState.editor.selection;\n    const line = selection.start.isBefore(selection.end)\n      ? selection.start.line\n      : selection.end.line;\n\n    if (!this._abort) {\n      const foundPattern = await this.replaceTextAtLine(line, regex, vimState);\n      if (!foundPattern) {\n        throw VimError.fromCode(ErrorCode.PatternNotFound);\n      }\n    }\n  }\n\n  async executeWithRange(vimState: VimState, range: node.LineRange): Promise<void> {\n    let [startLine, endLine] = range.resolve(vimState);\n\n    if (this._arguments.count && this._arguments.count >= 0) {\n      startLine = endLine;\n      endLine = endLine + this._arguments.count - 1;\n    }\n\n    // TODO: Global Setting.\n    // TODO: There are differencies between Vim Regex and JS Regex.\n    const regex = this.getRegex(this._arguments, vimState);\n    let foundPattern = false;\n    for (\n      let currentLine = startLine;\n      currentLine <= endLine && currentLine < vimState.document.lineCount;\n      currentLine++\n    ) {\n      if (this._abort) {\n        break;\n      }\n      foundPattern = (await this.replaceTextAtLine(currentLine, regex, vimState)) || foundPattern;\n    }\n    if (!foundPattern) {\n      throw VimError.fromCode(ErrorCode.PatternNotFound);\n    }\n  }\n}\n","import * as path from 'path';\nimport * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\n\nimport * as node from '../node';\n\nexport enum Tab {\n  Next,\n  Previous,\n  First,\n  Last,\n  Absolute,\n  New,\n  Close,\n  Only,\n  Move,\n}\n\nexport interface ITabCommandArguments extends node.ICommandArgs {\n  tab: Tab;\n  count?: number;\n  direction?: 'left' | 'right';\n  file?: string;\n}\n\n//\n//  Implements tab\n//  http://vimdoc.sourceforge.net/htmldoc/tabpage.html\n//\nexport class TabCommand extends node.CommandBase {\n  protected _arguments: ITabCommandArguments;\n\n  constructor(args: ITabCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): ITabCommandArguments {\n    return this._arguments;\n  }\n\n  private async executeCommandWithCount(count: number, command: string): Promise<void> {\n    for (let i = 0; i < count; i++) {\n      await vscode.commands.executeCommand(command);\n    }\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    switch (this._arguments.tab) {\n      case Tab.Absolute:\n        if (this._arguments.count !== undefined && this._arguments.count >= 0) {\n          await vscode.commands.executeCommand(\n            'workbench.action.openEditorAtIndex',\n            this._arguments.count\n          );\n        }\n        break;\n      case Tab.Next:\n        if (this._arguments.count !== undefined && this._arguments.count <= 0) {\n          break;\n        }\n\n        await this.executeCommandWithCount(\n          this._arguments.count || 1,\n          'workbench.action.nextEditorInGroup'\n        );\n        break;\n      case Tab.Previous:\n        if (this._arguments.count !== undefined && this._arguments.count <= 0) {\n          break;\n        }\n\n        await this.executeCommandWithCount(\n          this._arguments.count || 1,\n          'workbench.action.previousEditorInGroup'\n        );\n        break;\n      case Tab.First:\n        await vscode.commands.executeCommand('workbench.action.openEditorAtIndex1');\n        break;\n      case Tab.Last:\n        await vscode.commands.executeCommand('workbench.action.lastEditorInGroup');\n        break;\n      case Tab.New: {\n        const hasFile = !(this.arguments.file === undefined || this.arguments.file === '');\n        if (hasFile) {\n          const isAbsolute = path.isAbsolute(this.arguments.file!);\n          const isInWorkspace =\n            vscode.workspace.workspaceFolders !== undefined &&\n            vscode.workspace.workspaceFolders.length > 0;\n          const currentFilePath = vscode.window.activeTextEditor!.document.uri.fsPath;\n\n          let toOpenPath: string;\n          if (isAbsolute) {\n            toOpenPath = this.arguments.file!;\n          } else if (isInWorkspace) {\n            const workspacePath = vscode.workspace.workspaceFolders![0].uri.path;\n            toOpenPath = path.join(workspacePath, this.arguments.file!);\n          } else {\n            toOpenPath = path.join(path.dirname(currentFilePath), this.arguments.file!);\n          }\n\n          if (toOpenPath !== currentFilePath) {\n            await vscode.commands.executeCommand('vscode.open', vscode.Uri.file(toOpenPath));\n          }\n        } else {\n          await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n        }\n        break;\n      }\n      case Tab.Close:\n        // Navigate the correct position\n        if (this._arguments.count === undefined) {\n          await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n          break;\n        }\n\n        if (this._arguments.count === 0) {\n          // Wrong paramter\n          break;\n        }\n\n        // TODO: Close Page {count}. Page count is one-based.\n        break;\n      case Tab.Only:\n        await vscode.commands.executeCommand('workbench.action.closeOtherEditors');\n        break;\n      case Tab.Move: {\n        const { count, direction } = this.arguments;\n        let args;\n        if (direction !== undefined) {\n          args = { to: direction, by: 'tab', value: count };\n        } else if (count === 0) {\n          args = { to: 'first' };\n        } else if (count === undefined) {\n          args = { to: 'last' };\n        } else {\n          args = { to: 'position', by: 'tab', value: count + 1 };\n        }\n        await vscode.commands.executeCommand('moveActiveEditor', args);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n}\n","import * as node from '../node';\nimport { Logger } from '../../util/logger';\nimport { VimState } from '../../state/vimState';\nimport { CommandUndo } from '../../actions/commands/actions';\nimport { Position } from 'vscode';\n\n//\n//  Implements :u[ndo]\n//  http://vimdoc.sourceforge.net/htmldoc/undo.html\n//\nexport class UndoCommand extends node.CommandBase {\n  protected _arguments: {};\n  private readonly _logger = Logger.get('Undo');\n\n  constructor(args: {}) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): {} {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await new CommandUndo().exec(new Position(0, 0), vimState);\n    return;\n  }\n}\n","import * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\n\nimport * as node from '../node';\n\nexport interface IWallCommandArguments extends node.ICommandArgs {\n  bang?: boolean;\n  range?: node.LineRange;\n}\n\n//\n//  Implements :wall (write all)\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:wall\n//\nexport class WallCommand extends node.CommandBase {\n  protected _arguments: IWallCommandArguments;\n\n  constructor(args: IWallCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IWallCommandArguments {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // TODO : overwrite readonly files when bang? == true\n    await vscode.workspace.saveAll(false);\n  }\n}\n","import * as fs from 'platform/fs';\nimport * as node from '../node';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\nimport { Logger } from '../../util/logger';\nimport { StatusBar } from '../../statusBar';\nimport { VimState } from '../../state/vimState';\n\nexport interface IWriteCommandArguments extends node.ICommandArgs {\n  opt?: string;\n  optValue?: string;\n  bang?: boolean;\n  range?: node.LineRange;\n  file?: string;\n  append?: boolean;\n  cmd?: string;\n  bgWrite?: boolean;\n}\n\n//\n//  Implements :write\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:write\n//\nexport class WriteCommand extends node.CommandBase {\n  protected _arguments: IWriteCommandArguments;\n  private readonly _logger = Logger.get('Write');\n\n  constructor(args: IWriteCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IWriteCommandArguments {\n    return this._arguments;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.arguments.opt) {\n      this._logger.warn('not implemented');\n      return;\n    } else if (this.arguments.file) {\n      this._logger.warn('not implemented');\n      return;\n    } else if (this.arguments.append) {\n      this._logger.warn('not implemented');\n      return;\n    } else if (this.arguments.cmd) {\n      this._logger.warn('not implemented');\n      return;\n    }\n\n    // defer saving the file to vscode if file is new (to present file explorer) or if file is a remote file\n    if (vimState.document.isUntitled || vimState.document.uri.scheme !== 'file') {\n      await this.background(vscode.commands.executeCommand('workbench.action.files.save'));\n      return;\n    }\n\n    try {\n      await fs.accessAsync(vimState.document.fileName, fs.constants.W_OK);\n      return this.save(vimState);\n    } catch (accessErr) {\n      if (this.arguments.bang) {\n        try {\n          await fs.chmodAsync(vimState.document.fileName, 666);\n          return this.save(vimState);\n        } catch (e) {\n          StatusBar.setText(vimState, e.message);\n        }\n      } else {\n        StatusBar.setText(vimState, accessErr.message);\n      }\n    }\n  }\n\n  private async save(vimState: VimState): Promise<void> {\n    await this.background(\n      vimState.document.save().then(\n        () => {\n          const text =\n            '\"' +\n            path.basename(vimState.document.fileName) +\n            '\" ' +\n            vimState.document.lineCount +\n            'L ' +\n            vimState.document.getText().length +\n            'C written';\n          StatusBar.setText(vimState, text);\n        },\n        (e) => StatusBar.setText(vimState, e)\n      )\n    );\n  }\n\n  private async background(fn: Thenable<void>): Promise<void> {\n    if (!this._arguments.bgWrite) {\n      await fn;\n    }\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport * as node from '../node';\nimport * as quit from './quit';\nimport * as write from './write';\n\n//\n// Implements :writequit\n// http://vimdoc.sourceforge.net/htmldoc/editing.html#write-quit\n//\nexport interface IWriteQuitCommandArguments extends node.ICommandArgs {\n  // arguments\n  // [++opt]\n  opt?: string;\n  optValue?: string;\n  // wq! [++opt]\n  bang?: boolean;\n  // wq [++opt] {file}\n  file?: string;\n  // wq! [++opt] {file}\n  // [range]wq[!] [++opt] [file]\n  range?: node.LineRange;\n}\n\nexport class WriteQuitCommand extends node.CommandBase {\n  protected _arguments: IWriteQuitCommandArguments;\n\n  constructor(args: IWriteQuitCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IWriteQuitCommandArguments {\n    return this._arguments;\n  }\n\n  // Writing command. Taken as a basis from the \"write.ts\" file.\n  async execute(vimState: VimState): Promise<void> {\n    const writeArgs: write.IWriteCommandArguments = {\n      opt: this.arguments.opt,\n      optValue: this.arguments.optValue,\n      bang: this.arguments.bang,\n      file: this.arguments.file,\n      range: this.arguments.range,\n    };\n\n    const writeCmd = new write.WriteCommand(writeArgs);\n    await writeCmd.execute(vimState);\n    const quitArgs: quit.IQuitCommandArguments = {\n      // wq! fails when no file name is provided\n      bang: false,\n      range: this.arguments.range,\n    };\n\n    const quitCmd = new quit.QuitCommand(quitArgs);\n    await quitCmd.execute(vimState);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport * as wall from '../commands/wall';\nimport * as node from '../node';\nimport * as quit from './quit';\n\n//\n// Implements :writequitall\n// http://vimdoc.sourceforge.net/htmldoc/editing.html#:wqall\n//\nexport interface IWriteQuitAllCommandArguments extends node.ICommandArgs {\n  // arguments\n  // [++opt]\n  opt?: string;\n  optValue?: string;\n  // wqa! [++opt]\n  bang?: boolean;\n}\n\nexport class WriteQuitAllCommand extends node.CommandBase {\n  protected _arguments: IWriteQuitAllCommandArguments;\n\n  constructor(args: IWriteQuitAllCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  get arguments(): IWriteQuitAllCommandArguments {\n    return this._arguments;\n  }\n\n  // Writing command. Taken as a basis from the \"write.ts\" file.\n  async execute(vimState: VimState): Promise<void> {\n    const writeArgs: wall.IWallCommandArguments = {\n      bang: this.arguments.bang,\n    };\n\n    const quitArgs: quit.IQuitCommandArguments = {\n      // wq! fails when no file name is provided\n      bang: false,\n    };\n\n    const wallCmd = new wall.WallCommand(writeArgs);\n    await wallCmd.execute(vimState);\n\n    quitArgs.quitAll = true;\n    const quitCmd = new quit.QuitCommand(quitArgs);\n    await quitCmd.execute(vimState);\n  }\n}\n","import { Scanner } from './scanner';\nimport { Token, TokenType } from './token';\n\n// Describes a function that can lex part of a Vim command line.\ntype ILexFunction = (state: Scanner, tokens: Token[]) => ILexFunction | null;\n\nexport function lex(input: string): Token[] {\n  // We use a character scanner as state for the lexer.\n  const state = new Scanner(input);\n  const tokens: Token[] = [];\n  let f: ILexFunction | null = LexerFunctions.lexRange;\n  while (f) {\n    // Each lexing function returns the next lexing function or null.\n    f = f(state, tokens);\n  }\n  return tokens;\n}\n\nfunction emitToken(type: TokenType, state: Scanner): Token | null {\n  const content = state.emit();\n\n  return content.length > 0 ? new Token(type, content) : null;\n}\n\nnamespace LexerFunctions {\n  // Starts lexing a Vim command line and delegates on other lexer functions as needed.\n  export function lexRange(state: Scanner, tokens: Token[]): ILexFunction | null {\n    while (true) {\n      if (state.isAtEof) {\n        break;\n      }\n      const c = state.next();\n      switch (c) {\n        case ',':\n        case ';':\n          tokens.push(emitToken(TokenType.Comma, state)!);\n          continue;\n        case '%':\n          tokens.push(emitToken(TokenType.Percent, state)!);\n          continue;\n        case '$':\n          tokens.push(emitToken(TokenType.Dollar, state)!);\n          continue;\n        case '.':\n          tokens.push(emitToken(TokenType.Dot, state)!);\n          continue;\n        case '/':\n          return lexForwardSearch;\n        case '?':\n          return lexReverseSearch;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (tokens.length < 1) {\n            // special case - first digitey token is always a line number\n            return lexDigits(TokenType.LineNumber);\n          } else {\n            // otherwise, use previous token to determine which flavor of digit lexer should be used\n            const previousTokenType = tokens[tokens.length - 1].type;\n            if (previousTokenType === TokenType.Plus || previousTokenType === TokenType.Minus) {\n              return lexDigits(TokenType.Offset);\n            } else {\n              return lexDigits(TokenType.LineNumber);\n            }\n          }\n        case '+':\n          tokens.push(emitToken(TokenType.Plus, state)!);\n          continue;\n        case '-':\n          tokens.push(emitToken(TokenType.Minus, state)!);\n          continue;\n        case '*':\n          state.ignore();\n          tokens.push(new Token(TokenType.SelectionFirstLine, '<'));\n          tokens.push(new Token(TokenType.Comma, ','));\n          tokens.push(new Token(TokenType.SelectionLastLine, '>'));\n          continue;\n        case \"'\":\n          return lexMark;\n        case '!':\n          tokens.push(emitToken(TokenType.CommandName, state)!);\n          return lexCommandArgs;\n        case ' ':\n          state.ignore();\n          continue;\n        default:\n          return lexCommand;\n      }\n    }\n\n    return null;\n  }\n\n  function lexMark(state: Scanner, tokens: Token[]): ILexFunction | null {\n    // The first token has already been lexed.\n    if (state.isAtEof) {\n      return null;\n    }\n\n    const c = state.next();\n    switch (c) {\n      case '<':\n        tokens.push(emitToken(TokenType.SelectionFirstLine, state)!);\n        break;\n      case '>':\n        tokens.push(emitToken(TokenType.SelectionLastLine, state)!);\n        break;\n      default:\n        if (/[a-zA-Z]/.test(c)) {\n          state.emit();\n          tokens.push(new Token(TokenType.Mark, c));\n        } else {\n          state.backup();\n        }\n        break;\n    }\n\n    return lexRange;\n  }\n\n  /**\n   * when we're lexing digits, it could either be a line number or an offset, depending on whether\n   * our previous token was a + or a -\n   *\n   * so it's lexRange's job to specify which token to emit.\n   */\n  function lexDigits(tokenType: TokenType) {\n    return (state: Scanner, tokens: Token[]): ILexFunction | null => {\n      // The first digit has already been lexed.\n      while (true) {\n        if (state.isAtEof) {\n          tokens.push(emitToken(tokenType, state)!);\n          return null;\n        }\n\n        if (!/[0-9]/.test(state.next())) {\n          state.backup();\n          tokens.push(emitToken(tokenType, state)!);\n          return lexRange;\n        }\n      }\n    };\n  }\n\n  function lexCommand(state: Scanner, tokens: Token[]): ILexFunction | null {\n    // The first character of the command's name has already been lexed.\n    while (true) {\n      if (state.isAtEof) {\n        tokens.push(emitToken(TokenType.CommandName, state)!);\n        break;\n      }\n      const c = state.next().toLowerCase();\n      if (c >= 'a' && c <= 'z') {\n        continue;\n      } else {\n        state.backup();\n        tokens.push(emitToken(TokenType.CommandName, state)!);\n        return lexCommandArgs;\n      }\n    }\n    return null;\n  }\n\n  function lexCommandArgs(state: Scanner, tokens: Token[]): ILexFunction | null {\n    while (!state.isAtEof) {\n      state.next();\n    }\n    // TODO(guillermooo): We need to parse multiple commands.\n    const args = emitToken(TokenType.CommandArgs, state);\n    if (args) {\n      tokens.push(args);\n    }\n    return null;\n  }\n\n  function lexForwardSearch(state: Scanner, tokens: Token[]): ILexFunction {\n    // The first slash has already been lexed.\n    state.skip('/'); // XXX: really?\n    let escaping = false;\n    let searchTerm = '';\n    while (!state.isAtEof) {\n      const c = state.next();\n      if (c === '/' && !escaping) {\n        break;\n      }\n      if (c === '\\\\') {\n        escaping = true;\n        continue;\n      } else {\n        escaping = false;\n      }\n      searchTerm += c !== '\\\\' ? c : '\\\\\\\\';\n    }\n    tokens.push(new Token(TokenType.ForwardSearch, searchTerm));\n    state.ignore();\n    if (!state.isAtEof) {\n      state.skip('/');\n    }\n    return lexRange;\n  }\n\n  function lexReverseSearch(state: Scanner, tokens: Token[]): ILexFunction {\n    // The first question mark has already been lexed.\n    state.skip('?'); // XXX: really?\n    let escaping = false;\n    let searchTerm = '';\n    while (!state.isAtEof) {\n      const c = state.next();\n      if (c === '?' && !escaping) {\n        break;\n      }\n      if (c === '\\\\') {\n        escaping = true;\n        continue;\n      } else {\n        escaping = false;\n      }\n      searchTerm += c !== '\\\\' ? c : '\\\\\\\\';\n    }\n    tokens.push(new Token(TokenType.ReverseSearch, searchTerm));\n    state.ignore();\n    if (!state.isAtEof) {\n      state.skip('?');\n    }\n    return lexRange;\n  }\n}\n","import * as vscode from 'vscode';\nimport { VimState } from '../state/vimState';\nimport { TokenType, Token } from './token';\n\ntype LineRefOperation = TokenType.Plus | TokenType.Minus;\n\n/**\n * Represents a range of lines, as expressed on the command line.\n *\n * http://vimdoc.sourceforge.net/htmldoc/cmdline.html#cmdline-ranges\n */\nexport class LineRange {\n  left: Token[];\n  separator: Token | undefined;\n  right: Token[];\n\n  constructor() {\n    this.left = [];\n    this.right = [];\n  }\n\n  public addToken(tok: Token): void {\n    if (tok.type === TokenType.Comma) {\n      this.separator = tok;\n      return;\n    }\n\n    if (!this.separator) {\n      if (this.left.length > 0) {\n        switch (tok.type) {\n          case TokenType.Offset:\n          case TokenType.Plus:\n          case TokenType.Minus:\n            break;\n          default:\n            throw Error('Trailing characters');\n        }\n      }\n      this.left.push(tok);\n    } else {\n      if (this.right.length > 0) {\n        switch (tok.type) {\n          case TokenType.Offset:\n          case TokenType.Plus:\n          case TokenType.Minus:\n            break;\n          default:\n            throw Error('Trailing characters');\n        }\n      }\n      this.right.push(tok);\n    }\n  }\n\n  get isEmpty(): boolean {\n    return this.left.length === 0 && this.right.length === 0 && !this.separator;\n  }\n\n  public toString(): string {\n    return this.left.toString() + (this.separator?.content ?? '') + this.right.toString();\n  }\n\n  /**\n   * Resolves the line range to concrete line numbers\n   *\n   * @param vimState\n   * @returns Inclusive line number range [start, end]. Will always be in order.\n   */\n  public resolve(vimState: VimState, boundsCheck: boolean = true): [number, number] {\n    if (this.left.length > 0 && this.left[0].type === TokenType.Percent) {\n      return [0, vimState.document.lineCount - 1];\n    }\n\n    const start =\n      LineRange.resolveLineRef(this.left, vimState, boundsCheck) ??\n      vimState.cursorStopPosition.line;\n    const end = LineRange.resolveLineRef(this.right, vimState, boundsCheck) ?? start;\n    return end < start ? [end, start] : [start, end];\n  }\n\n  private static resolveLineRef(\n    toks: Token[],\n    vimState: VimState,\n    boundsCheck: boolean\n  ): number | undefined {\n    if (toks.length === 0) {\n      return undefined;\n    }\n\n    let currentLineNum: number;\n    let currentOperation: LineRefOperation | undefined;\n\n    const firstToken = toks[0];\n    // handle first-token special cases (e.g. %, inital line number is \".\" by default)\n    switch (firstToken.type) {\n      case TokenType.Percent:\n        return vimState.document.lineCount - 1;\n      case TokenType.Dollar:\n        currentLineNum = vimState.document.lineCount - 1;\n        break;\n      case TokenType.Plus:\n      case TokenType.Minus:\n      case TokenType.Dot:\n        currentLineNum = vimState.editor.selection.active.line;\n        // undocumented: if the first token is plus or minus, vim seems to behave as though there was a \".\"\n        currentOperation = firstToken.type === TokenType.Dot ? undefined : firstToken.type;\n        break;\n      case TokenType.LineNumber:\n        currentLineNum = Number.parseInt(firstToken.content, 10) - 1; // user sees 1-based - everything else is 0-based\n        break;\n      case TokenType.SelectionFirstLine:\n        currentLineNum = Math.min.apply(\n          null,\n          vimState.editor.selections.map((selection) =>\n            selection.start.isBeforeOrEqual(selection.end)\n              ? selection.start.line\n              : selection.end.line\n          )\n        );\n        break;\n      case TokenType.SelectionLastLine:\n        currentLineNum = Math.max.apply(\n          null,\n          vimState.editor.selections.map((selection) =>\n            selection.start.isAfter(selection.end) ? selection.start.line : selection.end.line\n          )\n        );\n        break;\n      case TokenType.Mark:\n        currentLineNum = vimState.historyTracker.getMark(firstToken.content)!.position.line;\n        break;\n      default:\n        throw new Error('Not Implemented');\n    }\n\n    // now handle subsequent tokens, offsetting the current candidate line number\n    for (let tokenIndex = 1; tokenIndex < toks.length; ++tokenIndex) {\n      const currentToken = toks[tokenIndex];\n\n      switch (currentOperation) {\n        case TokenType.Plus:\n          switch (currentToken.type) {\n            case TokenType.Minus:\n            case TokenType.Plus:\n              // undocumented: when there's two operators in a row, vim behaves as though there's a \"1\" between them\n              currentLineNum += 1;\n              currentOperation = currentToken.type;\n              break;\n            case TokenType.Offset:\n              currentLineNum += Number.parseInt(currentToken.content, 10);\n              currentOperation = undefined;\n              break;\n            default:\n              throw Error('Trailing characters');\n          }\n          break;\n        case TokenType.Minus:\n          switch (currentToken.type) {\n            case TokenType.Minus:\n            case TokenType.Plus:\n              // undocumented: when there's two operators in a row, vim behaves as though there's a \"1\" between them\n              currentLineNum -= 1;\n              currentOperation = currentToken.type;\n              break;\n            case TokenType.Offset:\n              currentLineNum -= Number.parseInt(currentToken.content, 10);\n              currentOperation = undefined;\n              break;\n            default:\n              throw Error('Trailing characters');\n          }\n          break;\n        case undefined:\n          switch (currentToken.type) {\n            case TokenType.Minus:\n            case TokenType.Plus:\n              currentOperation = currentToken.type;\n              break;\n            default:\n              throw Error('Trailing characters');\n          }\n          break;\n      }\n    }\n\n    // undocumented: when there's a trailing operation in the tank without an RHS, vim uses \"1\"\n    switch (currentOperation) {\n      case TokenType.Plus:\n        currentLineNum += 1;\n        break;\n      case TokenType.Minus:\n        currentLineNum -= 1;\n        break;\n    }\n\n    if (boundsCheck) {\n      currentLineNum = Math.max(0, currentLineNum);\n      currentLineNum = Math.min(vimState.document.lineCount - 1, currentLineNum);\n    }\n\n    return currentLineNum;\n  }\n}\n\nexport class CommandLine {\n  range: LineRange;\n  command: CommandBase | undefined;\n\n  constructor() {\n    this.range = new LineRange();\n  }\n\n  get isEmpty(): boolean {\n    return this.range.isEmpty && !this.command;\n  }\n\n  toString(): string {\n    return ':' + this.range.toString() + ' ' + (this.command?.toString() ?? '');\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.command) {\n      if (this.range.isEmpty) {\n        await this.command.execute(vimState);\n      } else {\n        await this.command.executeWithRange(vimState, this.range);\n      }\n    } else {\n      const [_, end] = this.range.resolve(vimState);\n      vimState.cursorStartPosition = vimState.cursorStopPosition = vimState.cursorStopPosition\n        .withLine(end)\n        .obeyStartOfLine(vimState.document);\n    }\n  }\n}\n\nexport interface ICommandArgs {\n  bang?: boolean;\n  range?: LineRange;\n}\n\nexport abstract class CommandBase {\n  get arguments(): ICommandArgs {\n    return this._arguments;\n  }\n  protected _arguments: ICommandArgs;\n\n  public neovimCapable(): boolean {\n    return false;\n  }\n\n  abstract execute(vimState: VimState): Promise<void>;\n\n  async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    // By default, ignore the given range.\n    await this.execute(vimState);\n  }\n}\n","import { lex } from './lexer';\nimport { CommandLine } from './node';\nimport { Token, TokenType } from './token';\nimport { Logger } from '../util/logger';\nimport { VimError, ErrorCode } from '../error';\nimport { getParser } from './subparser';\n\nconst logger = Logger.get('Parser');\n\ntype IParseFunction = (state: ParserState, command: CommandLine) => IParseFunction | undefined;\n\nexport function parse(input: string): CommandLine {\n  const cmd = new CommandLine();\n  let f: IParseFunction | undefined = parseLineRange;\n  const state: ParserState = new ParserState(input);\n  while (f) {\n    f = f(state, cmd);\n  }\n  return cmd;\n}\n\nfunction parseLineRange(state: ParserState, commandLine: CommandLine): IParseFunction | undefined {\n  while (true) {\n    const tok = state.next();\n    switch (tok.type) {\n      case TokenType.Eof:\n        return undefined;\n      case TokenType.Dot:\n      case TokenType.Dollar:\n      case TokenType.Percent:\n      case TokenType.Comma:\n      case TokenType.LineNumber:\n      case TokenType.SelectionFirstLine:\n      case TokenType.SelectionLastLine:\n      case TokenType.Mark:\n      case TokenType.Offset:\n      case TokenType.Plus:\n      case TokenType.Minus:\n        commandLine.range.addToken(tok);\n        continue;\n      case TokenType.CommandName:\n        state.backup();\n        return parseCommand;\n      default:\n        logger.warn(`Parser: skipping token Token(${tok.type},{${tok.content}})`);\n        return undefined;\n    }\n  }\n}\n\nfunction parseCommand(state: ParserState, commandLine: CommandLine): IParseFunction | undefined {\n  while (!state.isAtEof) {\n    const tok = state.next();\n    switch (tok.type) {\n      case TokenType.CommandName:\n        const commandParser = getParser(tok.content);\n        if (!commandParser) {\n          throw VimError.fromCode(ErrorCode.NotAnEditorCommand, state.input);\n        }\n        // TODO: Pass the args, but keep in mind there could be multiple commands, not just one.\n        const argsTok = state.next();\n        const args = argsTok.type === TokenType.CommandArgs ? argsTok.content : '';\n        commandLine.command = commandParser(args);\n        return undefined;\n      default:\n        throw new Error('Not implemented');\n    }\n  }\n\n  if (!state.isAtEof) {\n    state.backup();\n    return parseCommand;\n  } else {\n    return undefined;\n  }\n}\n\n// Keeps track of parsing state.\nclass ParserState {\n  input: string;\n  tokens: Token[] = [];\n  pos: number = 0;\n\n  constructor(input: string) {\n    this.input = input;\n    this.tokens = lex(input);\n  }\n\n  next(): Token {\n    if (this.pos >= this.tokens.length) {\n      this.pos = this.tokens.length;\n      return new Token(TokenType.Eof, '__EOF__');\n    }\n    const tok = this.tokens[this.pos];\n    this.pos++;\n    return tok;\n  }\n\n  backup(): void {\n    this.pos--;\n  }\n\n  get isAtEof() {\n    return this.pos >= this.tokens.length;\n  }\n}\n","// Provides state and behavior to scan an input string character by character.\nexport class Scanner {\n  static EOF: string = '__EOF__';\n  start: number = 0;\n  pos: number = 0;\n  input: string;\n\n  constructor(input: string) {\n    this.input = input;\n  }\n\n  // Returns the next character in the input, or EOF.\n  next(): string {\n    if (this.isAtEof) {\n      this.pos = this.input.length;\n      return Scanner.EOF;\n    }\n    const c = this.input[this.pos];\n    this.pos++;\n    return c;\n  }\n\n  nextWhile(fn: (c: string) => boolean): string {\n    if (this.isAtEof) {\n      return '';\n    }\n\n    while (true) {\n      const c = this.next();\n\n      if (c === Scanner.EOF) {\n        break;\n      } else if (!fn(c)) {\n        this.backup();\n        break;\n      }\n    }\n\n    return this.emit();\n  }\n\n  // Returns the next word in the input, or EOF.\n  nextWord(wordSeparators: string[] = [' ', '\\t']): string {\n    this.skipRun(wordSeparators);\n\n    if (this.isAtEof) {\n      this.pos = this.input.length;\n      return Scanner.EOF;\n    }\n\n    let result = '';\n    let c: string | undefined;\n\n    while (!this.isAtEof) {\n      c = this.next();\n\n      if (c === Scanner.EOF || wordSeparators.includes(c)) {\n        break;\n      }\n\n      result += c;\n    }\n\n    if (c && wordSeparators.includes(c)) {\n      this.backup();\n    }\n\n    this.ignore();\n    return result;\n  }\n\n  // Returns whether we've reached EOF.\n  get isAtEof(): boolean {\n    return this.pos >= this.input.length;\n  }\n\n  // Ignores the span of text between the current start and the current position.\n  ignore(): void {\n    this.start = this.pos;\n  }\n\n  // Returns the span of text between the current start and the current position.\n  emit(): string {\n    const s = this.input.substring(this.start, this.pos);\n    this.ignore();\n    return s;\n  }\n\n  // Returns the text from the current position to the end.\n  remaining(): string {\n    while (!this.isAtEof) {\n      this.next();\n    }\n    return this.emit();\n  }\n\n  backup(): void {\n    this.pos--;\n  }\n\n  // skips over c and ignores the text span\n  skip(c: string): void {\n    if (this.isAtEof) {\n      return;\n    }\n    let s = this.next();\n    while (!this.isAtEof) {\n      if (s !== c) {\n        break;\n      }\n      s = this.next();\n    }\n    this.backup();\n    this.ignore();\n  }\n\n  // skips text while any of chars matches and ignores the text span\n  skipRun(chars: string[]): void {\n    if (this.isAtEof) {\n      return;\n    }\n    while (!this.isAtEof) {\n      const c = this.next();\n      if (!chars.includes(c)) {\n        break;\n      }\n    }\n    this.backup();\n    this.ignore();\n  }\n\n  // skips over whitespace (tab, space) and ignores the text span\n  skipWhiteSpace(): void {\n    if (this.isAtEof) {\n      return;\n    }\n    let c: string | null = null;\n\n    while (!this.isAtEof) {\n      c = this.next();\n      if (c === ' ' || c === '\\t') {\n        continue;\n      }\n      break;\n    }\n\n    if (c !== Scanner.EOF && c !== ' ' && c !== '\\t') {\n      this.backup();\n    }\n    this.ignore();\n  }\n\n  expect(value: string): void {\n    if (!this.input.substring(this.pos).startsWith(value)) {\n      throw new Error('Unexpected character.');\n    }\n    this.pos += value.length;\n  }\n\n  expectOneOf(values: string[]): void {\n    const match = values.filter((s) => this.input.substr(this.pos).startsWith(s));\n    if (match.length !== 1) {\n      if (match.length > 1) {\n        throw new Error('Too many matches.');\n      }\n      throw new Error('Unexpected character.');\n    }\n    this.pos += match[0].length;\n  }\n}\n","import { parseCloseCommandArgs } from './subparsers/close';\nimport { parseDeleteRangeLinesCommandArgs } from './subparsers/deleteRange';\nimport { parseDigraphCommandArgs } from './subparsers/digraph';\nimport * as fileCmd from './subparsers/file';\nimport { parseQuitAllCommandArgs, parseQuitCommandArgs } from './subparsers/quit';\nimport { parseReadCommandArgs } from './subparsers/read';\nimport { parseRegisterCommandArgs } from './subparsers/register';\nimport { parseOptionsCommandArgs } from './subparsers/setoptions';\nimport { parseSortCommandArgs } from './subparsers/sort';\nimport { parseSubstituteCommandArgs } from './subparsers/substitute';\nimport * as tabCmd from './subparsers/tab';\nimport { parseWallCommandArgs } from './subparsers/wall';\nimport { parseWriteCommandArgs } from './subparsers/write';\nimport { parseWriteQuitCommandArgs } from './subparsers/writequit';\nimport { parseWriteQuitAllCommandArgs } from './subparsers/writequitall';\nimport { parseFileInfoCommandArgs } from './subparsers/fileInfo';\nimport { parseMarksCommandArgs, parseMarksRemoveCommandArgs } from './subparsers/marks';\nimport { parsePutExCommandArgs } from './subparsers/put';\nimport { CommandBase } from './node';\nimport { parseHistoryCommandArgs } from './subparsers/history';\nimport { parseBufferDeleteCommandArgs } from './subparsers/bufferDelete';\nimport { NohlCommand } from './commands/nohl';\nimport { OnlyCommand } from './commands/only';\nimport { SmileCommand } from './commands/smile';\nimport { UndoCommand } from './commands/undo';\nimport { parseBangCommand } from './subparsers/bang';\nimport { ClearJumpsCommand, JumpsCommand } from './commands/jumps';\nimport { VimState } from '../state/vimState';\nimport { StatusBar } from '../statusBar';\nimport { ShCommand } from './commands/sh';\nimport { GotoCommand } from './commands/goto';\n\n// Associates a name and an abbreviation with a command parser\nexport type CommandParserMapping = {\n  /** The shortest abbreviation that will work, such as `:q` */\n  abbrev?: string;\n\n  /** The parser for this command. Undefined if no implementation exists yet. */\n  parser?: (args: string) => CommandBase;\n};\n\n// Keep this sorted, please :)\nexport const commandParsers = {\n  '!': {\n    parser: parseBangCommand,\n  },\n\n  bdelete: {\n    abbrev: 'bd',\n    parser: parseBufferDeleteCommandArgs,\n  },\n\n  bfirst: {\n    abbrev: 'bf',\n    parser: undefined,\n  },\n\n  blast: {\n    abbrev: 'bl',\n    parser: undefined,\n  },\n\n  bmodified: {\n    abbrev: 'bm',\n    parser: undefined,\n  },\n\n  bnext: {\n    abbrev: 'bn',\n    parser: tabCmd.parseTabNCommandArgs,\n  },\n\n  bNext: {\n    abbrev: 'bN',\n    parser: tabCmd.parseTabPCommandArgs,\n  },\n\n  bprevious: {\n    abbrev: 'bp',\n    parser: tabCmd.parseTabPCommandArgs,\n  },\n\n  brewind: {\n    abbrev: 'br',\n    parser: undefined,\n  },\n\n  buffers: {\n    parser: undefined,\n  },\n\n  center: {\n    abbrev: 'ce',\n    parser: undefined,\n  },\n\n  clearjumps: {\n    abbrev: 'cle',\n    parser: () => new ClearJumpsCommand(),\n  },\n\n  close: {\n    abbrev: 'clo',\n    parser: parseCloseCommandArgs,\n  },\n\n  copy: {\n    abbrev: 'co',\n    parser: undefined,\n  },\n\n  delete: {\n    abbrev: 'd',\n    parser: parseDeleteRangeLinesCommandArgs,\n  },\n\n  delmarks: {\n    abbrev: 'delm',\n    parser: parseMarksRemoveCommandArgs,\n  },\n\n  digraphs: {\n    abbrev: 'dig',\n    parser: parseDigraphCommandArgs,\n  },\n\n  display: {\n    abbrev: 'di',\n    parser: parseRegisterCommandArgs,\n  },\n\n  edit: {\n    abbrev: 'e',\n    parser: fileCmd.parseEditFileCommandArgs,\n  },\n\n  enew: {\n    abbrev: 'ene',\n    parser: fileCmd.parseEditNewFileCommandArgs,\n  },\n\n  file: {\n    abbrev: 'f',\n    parser: parseFileInfoCommandArgs,\n  },\n\n  files: {\n    parser: undefined,\n  },\n\n  global: {\n    abbrev: 'g',\n    parser: undefined,\n  },\n\n  goto: {\n    abbrev: 'go',\n    parser: GotoCommand.parse,\n  },\n\n  help: {\n    abbrev: 'h',\n    parser: undefined,\n  },\n\n  history: {\n    abbrev: 'his',\n    parser: parseHistoryCommandArgs,\n  },\n\n  jumps: {\n    abbrev: 'ju',\n    parser: () => new JumpsCommand(),\n  },\n\n  left: {\n    abbrev: 'le',\n    parser: undefined,\n  },\n\n  ls: {\n    parser: undefined,\n  },\n\n  marks: {\n    parser: parseMarksCommandArgs,\n  },\n\n  move: {\n    abbrev: 'm',\n    parser: undefined,\n  },\n\n  new: {\n    parser: fileCmd.parseEditNewFileInNewHorizontalWindowCommandArgs,\n  },\n\n  nohlsearch: {\n    abbrev: 'noh',\n    parser: () => new NohlCommand({}),\n  },\n\n  normal: {\n    abbrev: 'norm',\n    parser: undefined,\n  },\n\n  only: {\n    abbrev: 'on',\n    parser: () => new OnlyCommand({}),\n  },\n\n  put: {\n    abbrev: 'pu',\n    parser: parsePutExCommandArgs,\n  },\n\n  qall: {\n    abbrev: 'qa',\n    parser: parseQuitAllCommandArgs,\n  },\n\n  quit: {\n    abbrev: 'q',\n    parser: parseQuitCommandArgs,\n  },\n\n  quitall: {\n    abbrev: 'quita',\n    parser: parseQuitAllCommandArgs,\n  },\n\n  read: {\n    abbrev: 'r',\n    parser: parseReadCommandArgs,\n  },\n\n  registers: {\n    abbrev: 'reg',\n    parser: parseRegisterCommandArgs,\n  },\n\n  right: {\n    abbrev: 'ri',\n    parser: undefined,\n  },\n\n  set: {\n    abbrev: 'se',\n    parser: parseOptionsCommandArgs,\n  },\n\n  shell: {\n    abbrev: 'sh',\n    parser: () => new ShCommand(),\n  },\n\n  smile: {\n    parser: () => new SmileCommand(),\n  },\n\n  sort: {\n    abbrev: 'sor',\n    parser: parseSortCommandArgs,\n  },\n\n  source: {\n    abbrev: 'so',\n    parser: undefined,\n  },\n\n  split: {\n    abbrev: 'sp',\n    parser: fileCmd.parseEditFileInNewHorizontalWindowCommandArgs,\n  },\n\n  substitute: {\n    abbrev: 's',\n    parser: parseSubstituteCommandArgs,\n  },\n\n  t: {\n    parser: undefined,\n  },\n\n  tabclose: {\n    abbrev: 'tabc',\n    parser: tabCmd.parseTabCloseCommandArgs,\n  },\n\n  tabedit: {\n    abbrev: 'tabe',\n    parser: tabCmd.parseTabNewCommandArgs,\n  },\n\n  tabfirst: {\n    abbrev: 'tabfir',\n    parser: tabCmd.parseTabFirstCommandArgs,\n  },\n\n  tablast: {\n    abbrev: 'tabl',\n    parser: tabCmd.parseTabLastCommandArgs,\n  },\n\n  tabmove: {\n    abbrev: 'tabm',\n    parser: tabCmd.parseTabMovementCommandArgs,\n  },\n\n  tabnew: {\n    parser: tabCmd.parseTabNewCommandArgs,\n  },\n\n  tabnext: {\n    abbrev: 'tabn',\n    parser: tabCmd.parseTabNCommandArgs,\n  },\n\n  tabNext: {\n    abbrev: 'tabN',\n    parser: tabCmd.parseTabPCommandArgs,\n  },\n\n  tabonly: {\n    abbrev: 'tabo',\n    parser: tabCmd.parseTabOnlyCommandArgs,\n  },\n\n  tabprevious: {\n    abbrev: 'tabp',\n    parser: tabCmd.parseTabPCommandArgs,\n  },\n\n  undo: {\n    abbrev: 'u',\n    parser: () => new UndoCommand({}),\n  },\n\n  vglobal: {\n    abbrev: 'v',\n    parser: undefined,\n  },\n\n  vnew: {\n    abbrev: 'vne',\n    parser: fileCmd.parseEditNewFileInNewVerticalWindowCommandArgs,\n  },\n\n  vsplit: {\n    abbrev: 'vs',\n    parser: fileCmd.parseEditFileInNewVerticalWindowCommandArgs,\n  },\n\n  wall: {\n    abbrev: 'wa',\n    parser: parseWallCommandArgs,\n  },\n\n  wq: {\n    parser: parseWriteQuitCommandArgs,\n  },\n\n  wqall: {\n    abbrev: 'wqa',\n    parser: parseWriteQuitAllCommandArgs,\n  },\n\n  write: {\n    abbrev: 'w',\n    parser: parseWriteCommandArgs,\n  },\n\n  x: {\n    parser: parseWriteQuitCommandArgs,\n  },\n\n  xall: {\n    abbrev: 'xa',\n    parser: parseWriteQuitAllCommandArgs,\n  },\n\n  yank: {\n    abbrev: 'y',\n    parser: undefined,\n  },\n};\n\n/**\n * Returns a command parser for the given `input`, if one exists.\n * Resolves `q`, `qu`, `qui`, and `quit` the same.\n */\nexport function getParser(input: string): ((args: string) => CommandBase) | undefined {\n  if (input === '') {\n    return undefined;\n  }\n\n  for (const fullName of Object.keys(commandParsers)) {\n    const parserMapping: CommandParserMapping = commandParsers[fullName];\n\n    const parser =\n      parserMapping.parser ??\n      ((args: string) => {\n        return new UnimplementedCommand(fullName, parserMapping);\n      });\n\n    if (parserMapping.abbrev !== undefined) {\n      if (input.startsWith(parserMapping.abbrev) && fullName.startsWith(input)) {\n        return parser;\n      }\n    } else {\n      if (input === fullName) {\n        return parser;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nclass UnimplementedCommand extends CommandBase {\n  fullName: string;\n  parserMapping: CommandParserMapping;\n\n  public neovimCapable(): boolean {\n    // If the user has neovim integration enabled, don't stop them from using these commands\n    return true;\n  }\n\n  constructor(fullName: string, parserMapping: CommandParserMapping) {\n    super();\n    this.fullName = fullName;\n    this.parserMapping = parserMapping;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const commandText = this.parserMapping.abbrev\n      ? `${this.parserMapping.abbrev}[${this.fullName.substr(this.parserMapping.abbrev.length)}]`\n      : this.fullName;\n    StatusBar.setText(vimState, `Command :${commandText} is not yet implemented`, true);\n  }\n}\n","import { BangCommand } from '../commands/bang';\n\nexport function parseBangCommand(args: string): BangCommand {\n  return new BangCommand({\n    command: args,\n  });\n}\n","import * as node from '../commands/bufferDelete';\nimport { Scanner } from '../scanner';\n\nexport function parseBufferDeleteCommandArgs(args: string): node.BufferDeleteCommand {\n  if (!args) {\n    return new node.BufferDeleteCommand({});\n  }\n  const scannedArgs: node.IBufferDeleteCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  }\n  const tabPosition = scanner.remaining();\n  scannedArgs.tabPosition = tabPosition.trim();\n  return new node.BufferDeleteCommand(scannedArgs);\n}\n","import { ErrorCode, VimError } from '../../error';\nimport * as node from '../commands/close';\nimport { Scanner } from '../scanner';\n\nexport function parseCloseCommandArgs(args: string): node.CloseCommand {\n  if (!args) {\n    return new node.CloseCommand({});\n  }\n  const scannedArgs: node.ICloseCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else if (c !== ' ') {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  scanner.skipWhiteSpace();\n  if (!scanner.isAtEof) {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  return new node.CloseCommand(scannedArgs);\n}\n","import * as node from '../commands/deleteRange';\nimport { Scanner } from '../scanner';\n\nexport function parseDeleteRangeLinesCommandArgs(args: string): node.DeleteRangeCommand {\n  if (!args || !args.trim()) {\n    return new node.DeleteRangeCommand({});\n  }\n\n  return new node.DeleteRangeCommand({\n    register: new Scanner(args).nextWord(),\n  });\n}\n","import * as node from '../commands/digraph';\nimport { Scanner } from '../scanner';\n\nexport function parseDigraphCommandArgs(args: string): node.DigraphsCommand {\n  if (!args || !args.trim()) {\n    return new node.DigraphsCommand({});\n  }\n\n  return new node.DigraphsCommand({\n    arg: new Scanner(args).nextWord(),\n  });\n}\n","import * as node from '../commands/file';\nimport { Scanner } from '../scanner';\n\nexport function parseEditFileCommandArgs(args: string): node.FileCommand {\n  if (!args || !args.trim()) {\n    return new node.FileCommand({ name: '', createFileIfNotExists: true });\n  }\n\n  const scanner = new Scanner(args);\n  const bang = scanner.next() === '!';\n  if (scanner.isAtEof) {\n    return new node.FileCommand({ name: '', bang, createFileIfNotExists: true });\n  }\n\n  const name = scanner.remaining();\n  return new node.FileCommand({\n    name: name.trim(),\n    bang,\n    createFileIfNotExists: true,\n  });\n}\n\nexport function parseEditNewFileCommandArgs(): node.FileCommand {\n  return new node.FileCommand({\n    name: undefined,\n    createFileIfNotExists: true,\n  });\n}\n\nexport function parseEditFileInNewVerticalWindowCommandArgs(args: string): node.FileCommand {\n  let name = '';\n\n  if (args) {\n    const scanner = new Scanner(args);\n    name = scanner.nextWord();\n  }\n\n  return new node.FileCommand({\n    name,\n    position: node.FilePosition.NewWindowVerticalSplit,\n  });\n}\n\nexport function parseEditFileInNewHorizontalWindowCommandArgs(args: string): node.FileCommand {\n  let name = '';\n\n  if (args) {\n    const scanner = new Scanner(args);\n    name = scanner.nextWord();\n  }\n\n  return new node.FileCommand({\n    name,\n    position: node.FilePosition.NewWindowHorizontalSplit,\n  });\n}\n\nexport function parseEditNewFileInNewVerticalWindowCommandArgs(): node.FileCommand {\n  return new node.FileCommand({\n    name: undefined,\n    createFileIfNotExists: true,\n    position: node.FilePosition.NewWindowVerticalSplit,\n  });\n}\n\nexport function parseEditNewFileInNewHorizontalWindowCommandArgs(): node.FileCommand {\n  return new node.FileCommand({\n    name: undefined,\n    createFileIfNotExists: true,\n    position: node.FilePosition.NewWindowHorizontalSplit,\n  });\n}\n","import { FileInfoCommand } from '../commands/fileInfo';\n\nexport function parseFileInfoCommandArgs(args: string): FileInfoCommand {\n  // TODO: implement bang, file name parameters. http://vimdoc.sourceforge.net/htmldoc/editing.html#CTRL-G\n  return new FileInfoCommand();\n}\n","import { HistoryCommand, HistoryCommandType, IHistoryCommandArguments } from '../commands/history';\nimport { Scanner } from '../scanner';\n\nexport function parseHistoryCommandArgs(input?: string): HistoryCommand {\n  const args: IHistoryCommandArguments = { type: HistoryCommandType.Cmd };\n\n  if (input) {\n    const scanner = new Scanner(input);\n    scanner.skipWhiteSpace();\n    const type = scanner.nextWord();\n\n    if (type === '/' || (type.startsWith('s') && 'search'.startsWith(type))) {\n      args.type = HistoryCommandType.Search;\n    }\n  }\n\n  return new HistoryCommand(args);\n}\n","import { MarksCommand, DeleteMarksCommand } from '../commands/marks';\n\nexport function parseMarksCommandArgs(args: string): MarksCommand {\n  if (!args || !args.trim()) {\n    return new MarksCommand();\n  }\n  return new MarksCommand(args.split(''));\n}\n\nexport function parseMarksRemoveCommandArgs(args: string): DeleteMarksCommand {\n  if (!args) {\n    return new DeleteMarksCommand();\n  }\n  return new DeleteMarksCommand(args.trimStart());\n}\n","import { PutExCommand, IPutCommandArguments } from '../commands/put';\nimport { Scanner } from '../scanner';\n\nexport function parsePutExCommandArgs(args: string): PutExCommand {\n  if (!args) {\n    return new PutExCommand({});\n  }\n\n  const scannedArgs: IPutCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else {\n    scanner.backup();\n  }\n  scanner.skipWhiteSpace();\n\n  if (!scanner.isAtEof) {\n    scannedArgs.register = scanner.nextWord();\n  }\n  return new PutExCommand(scannedArgs);\n}\n","import { ErrorCode, VimError } from '../../error';\nimport * as node from '../commands/quit';\nimport { Scanner } from '../scanner';\n\nexport function parseQuitCommandArgs(args: string): node.QuitCommand {\n  if (!args) {\n    return new node.QuitCommand({});\n  }\n  const scannedArgs: node.IQuitCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else if (c !== ' ') {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  scanner.skipWhiteSpace();\n  if (!scanner.isAtEof) {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  return new node.QuitCommand(scannedArgs);\n}\n\nexport function parseQuitAllCommandArgs(args: string): node.QuitCommand {\n  const command = parseQuitCommandArgs(args);\n  command.arguments.quitAll = true;\n  return command;\n}\n","import { IReadCommandArguments, ReadCommand } from '../commands/read';\nimport { Scanner } from '../scanner';\n\nexport function parseReadCommandArgs(args: string): ReadCommand {\n  if (!args || !args.trim()) {\n    throw Error('Expected arguments.');\n  }\n\n  const scannedArgs: IReadCommandArguments = {};\n  const scanner = new Scanner(args);\n\n  scanner.skipWhiteSpace();\n  const c = scanner.next();\n  // read command has 2 forms - 'read <file-path>' and 'read! <shell-command>'\n  if (c === '!') {\n    scanner.ignore();\n    scanner.skipWhiteSpace();\n    scannedArgs.cmd = scanner.remaining();\n    if (!scannedArgs.cmd || scannedArgs.cmd.length === 0) {\n      throw Error('Expected shell command.');\n    }\n  } else {\n    scannedArgs.file = scanner.remaining();\n    if (!scannedArgs.file || scannedArgs.file.length === 0) {\n      throw Error('Expected file path.');\n    }\n  }\n\n  return new ReadCommand(scannedArgs);\n}\n","import { RegisterCommand } from '../commands/register';\nimport { Scanner } from '../scanner';\n\nexport function parseRegisterCommandArgs(args: string): RegisterCommand {\n  if (!args || !args.trim()) {\n    return new RegisterCommand({\n      registers: [],\n    });\n  }\n\n  const scanner = new Scanner(args);\n  const regs: string[] = [];\n  let reg = scanner.nextWord();\n  while (reg !== Scanner.EOF) {\n    regs.push(reg);\n    reg = scanner.nextWord();\n  }\n\n  return new RegisterCommand({\n    registers: regs,\n  });\n}\n","import * as node from '../commands/setoptions';\nimport { Scanner } from '../scanner';\n\nexport function parseOption(args?: string): node.IOptionArgs {\n  const scanner = new Scanner(args ?? '');\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    return {};\n  }\n\n  const optionName = scanner.nextWord('?!&=:^+-'.split(''));\n\n  if (optionName.startsWith('no')) {\n    return {\n      name: optionName.substring(2, optionName.length),\n      operator: node.SetOptionOperator.Reset,\n    };\n  }\n\n  if (optionName.startsWith('inv')) {\n    return {\n      name: optionName.substring(3, optionName.length),\n      operator: node.SetOptionOperator.Invert,\n    };\n  }\n\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    return {\n      name: optionName,\n      operator: node.SetOptionOperator.Set,\n    };\n  }\n\n  const operator = scanner.next();\n  const optionArgs: node.IOptionArgs = {\n    name: optionName,\n    value: scanner.nextWord([]),\n  };\n\n  switch (operator) {\n    case '=':\n    case ':':\n      optionArgs.operator = node.SetOptionOperator.Equal;\n      break;\n    case '!':\n      optionArgs.operator = node.SetOptionOperator.Invert;\n      break;\n    case '^':\n      optionArgs.operator = node.SetOptionOperator.Multiply;\n      break;\n    case '+':\n      optionArgs.operator = node.SetOptionOperator.Append;\n      break;\n    case '-':\n      optionArgs.operator = node.SetOptionOperator.Subtract;\n      break;\n    case '?':\n      optionArgs.operator = node.SetOptionOperator.Info;\n      break;\n    case '&':\n      optionArgs.operator = node.SetOptionOperator.Reset;\n      break;\n    default:\n      throw new Error(`Unsupported operator (${operator}).`);\n  }\n\n  return optionArgs;\n}\n\nexport function parseOptionsCommandArgs(args: string): node.SetOptionsCommand {\n  return new node.SetOptionsCommand(parseOption(args));\n}\n","import * as node from '../commands/sort';\nimport { Scanner } from '../scanner';\n\nexport function parseSortCommandArgs(args: string): node.SortCommand {\n  if (!args || !args.trim()) {\n    return new node.SortCommand({ reverse: false, ignoreCase: false, unique: false });\n  }\n\n  const scannedArgs: node.ISortCommandArguments = {\n    reverse: false,\n    ignoreCase: false,\n    unique: false,\n  };\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  scannedArgs.reverse = c === '!';\n\n  const nextWord = scanner.nextWord();\n  // NOTE: vim supports `:sort ui` to do both insensitive and unique\n  // at the same time. We felt this would be very uncommon usage so\n  // chose to keep it simple and leave that functionality out.\n  // See https://github.com/VSCodeVim/Vim/pull/4148\n  scannedArgs.ignoreCase = nextWord === 'i';\n  scannedArgs.unique = nextWord === 'u';\n\n  return new node.SortCommand(scannedArgs);\n}\n","/* tslint:disable:no-bitwise */\n\nimport * as node from '../commands/substitute';\nimport { Scanner } from '../scanner';\nimport * as error from '../../error';\n\nfunction isValidDelimiter(char: string): boolean {\n  return !!/^[^\\w\\s\\\\|\"]{1}$/g.exec(char);\n}\n\nfunction parsePattern(pattern: string, scanner: Scanner, delimiter: string): [string, boolean] {\n  if (scanner.isAtEof) {\n    return [pattern, false];\n  } else {\n    let currentChar = scanner.next();\n\n    if (currentChar === delimiter) {\n      // TODO skip delimiter\n      return [pattern, true];\n    } else if (currentChar === '\\\\') {\n      if (!scanner.isAtEof) {\n        currentChar = scanner.next();\n\n        if (currentChar !== delimiter) {\n          switch (currentChar) {\n            case 'r':\n              pattern += '\\r';\n              break;\n            case 'n':\n              pattern += '\\n';\n              break;\n            case 't':\n              pattern += '\\t';\n              break;\n            default:\n              pattern += '\\\\';\n              pattern += currentChar;\n              break;\n          }\n        } else {\n          pattern += currentChar;\n        }\n      }\n\n      return parsePattern(pattern, scanner, delimiter);\n    } else {\n      pattern += currentChar;\n      return parsePattern(pattern, scanner, delimiter);\n    }\n  }\n}\n\nfunction parseSubstituteFlags(scanner: Scanner): number {\n  let flags: number = 0;\n  let index = 0;\n  while (true) {\n    if (scanner.isAtEof) {\n      break;\n    }\n\n    const c = scanner.next();\n    switch (c) {\n      case '&':\n        if (index === 0) {\n          flags |= node.SubstituteFlags.KeepPreviousFlags;\n        } else {\n          // Raise Error\n          return node.SubstituteFlags.None;\n        }\n        break;\n      case 'c':\n        flags |= node.SubstituteFlags.ConfirmEach;\n        break;\n      case 'e':\n        flags |= node.SubstituteFlags.SuppressError;\n        break;\n      case 'g':\n        flags |= node.SubstituteFlags.ReplaceAll;\n        break;\n      case 'i':\n        flags |= node.SubstituteFlags.IgnoreCase;\n        break;\n      case 'I':\n        flags |= node.SubstituteFlags.NoIgnoreCase;\n        break;\n      case 'n':\n        flags |= node.SubstituteFlags.PrintCount;\n        break;\n      case 'p':\n        flags |= node.SubstituteFlags.PrintLastMatchedLine;\n        break;\n      case '#':\n        flags |= node.SubstituteFlags.PrintLastMatchedLineWithNumber;\n        break;\n      case 'l':\n        flags |= node.SubstituteFlags.PrintLastMatchedLineWithList;\n        break;\n      case 'r':\n        flags |= node.SubstituteFlags.UsePreviousPattern;\n        break;\n      default:\n        scanner.backup();\n        return flags;\n    }\n\n    index++;\n  }\n\n  return flags;\n}\n\nfunction parseCount(scanner: Scanner): number {\n  let countStr = '';\n\n  while (true) {\n    if (scanner.isAtEof) {\n      break;\n    }\n    countStr += scanner.next();\n  }\n\n  const count = Number.parseInt(countStr, 10);\n\n  // TODO: If count is not valid number, raise error\n  return Number.isInteger(count) ? count : -1;\n}\n/**\n * Substitute\n * :[range]s[ubstitute]/{pattern}/{string}/[flags] [count]\n * For each line in [range] replace a match of {pattern} with {string}.\n * {string} can be a literal string, or something special; see |sub-replace-special|.\n */\nexport function parseSubstituteCommandArgs(args: string): node.SubstituteCommand {\n  try {\n    let searchPattern: string | undefined;\n    let replaceString: string;\n    let flags: number;\n    let count: number;\n\n    if (!args || !args.trim()) {\n      // special case for :s\n      return new node.SubstituteCommand({\n        pattern: undefined,\n        replace: '', // ignored in this context\n        flags: node.SubstituteFlags.None,\n      });\n    }\n    let scanner: Scanner;\n\n    const delimiter = args[0];\n\n    if (isValidDelimiter(delimiter)) {\n      if (args.length === 1) {\n        // special case for :s/ or other delimiters\n        return new node.SubstituteCommand({\n          pattern: '',\n          replace: '',\n          flags: node.SubstituteFlags.None,\n        });\n      }\n\n      let secondDelimiterFound: boolean;\n\n      scanner = new Scanner(args.substr(1, args.length - 1));\n      [searchPattern, secondDelimiterFound] = parsePattern('', scanner, delimiter);\n\n      if (!secondDelimiterFound) {\n        // special case for :s/search\n        return new node.SubstituteCommand({\n          pattern: searchPattern,\n          replace: '',\n          flags: node.SubstituteFlags.None,\n        });\n      }\n      replaceString = parsePattern('', scanner, delimiter)[0];\n    } else {\n      // if it's not a valid delimiter, it must be flags, so start parsing from here\n      searchPattern = undefined;\n      replaceString = '';\n      scanner = new Scanner(args);\n    }\n\n    scanner.skipWhiteSpace();\n    flags = parseSubstituteFlags(scanner);\n    scanner.skipWhiteSpace();\n    count = parseCount(scanner);\n\n    return new node.SubstituteCommand({\n      pattern: searchPattern,\n      replace: replaceString,\n      flags,\n      count,\n    });\n  } catch (e) {\n    throw error.VimError.fromCode(error.ErrorCode.PatternNotFound);\n  }\n}\n","import * as node from '../commands/tab';\nimport { Scanner } from '../scanner';\nimport { ErrorCode, VimError } from '../../error';\n\nconst isDigit = (c: string) => '0' <= c && c <= '9';\n\nfunction parseCount(args: string): number | undefined {\n  if (!args) {\n    return undefined;\n  }\n\n  const scanner = new Scanner(args);\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    return undefined;\n  }\n\n  const input = scanner.nextWhile(isDigit);\n  scanner.skipWhiteSpace();\n\n  const count = Number.parseInt(input, 10);\n\n  if (scanner.isAtEof && Number.isInteger(count) && count >= 0) {\n    return count;\n  } else {\n    throw VimError.fromCode(ErrorCode.InvalidArgument);\n  }\n}\n\nfunction parseCountOrOffset(\n  args: string\n): { count: number | undefined; direction?: 'left' | 'right' } {\n  if (!args) {\n    return { count: undefined };\n  }\n\n  const scanner = new Scanner(args);\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    return { count: undefined };\n  }\n\n  const c = scanner.next();\n\n  const direction = (() => {\n    if (c === '-') {\n      return 'left';\n    } else if (c === '+') {\n      return 'right';\n    } else {\n      return undefined;\n    }\n  })();\n\n  if (direction === undefined) {\n    scanner.backup();\n  } else {\n    scanner.ignore();\n  }\n\n  const input = scanner.nextWhile(isDigit);\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    const count = input.length === 0 ? 1 : Number.parseInt(input, 10);\n\n    if (Number.isInteger(count) && (count > 0 || (direction === undefined && count === 0))) {\n      return { count, direction };\n    }\n  }\n\n  throw VimError.fromCode(ErrorCode.InvalidArgument);\n}\n\n/**\n * :tabn[ext] Go to the next tab page.\n * :tabn[ext] {count} Go to tab page {count}.\n */\nexport function parseTabNCommandArgs(args: string): node.TabCommand {\n  return new node.TabCommand({\n    tab: node.Tab.Next,\n    count: parseCount(args),\n  });\n}\n\n/**\n * :tabp[revious] Go to the previous tab page.  Wraps around from the first one  to the last one.\n * :tabp[revious] {count} Go {count} tab pages back.\n */\nexport function parseTabPCommandArgs(args: string): node.TabCommand {\n  return new node.TabCommand({\n    tab: node.Tab.Previous,\n    count: parseCount(args),\n  });\n}\n\n/**\n * :tabfir[st]  Go to the first tab page.\n */\nexport function parseTabFirstCommandArgs(args: string): node.TabCommand {\n  return new node.TabCommand({\n    tab: node.Tab.First,\n  });\n}\n\n/**\n * :tabl[ast]  Go to the last tab page.\n */\nexport function parseTabLastCommandArgs(args: string): node.TabCommand {\n  return new node.TabCommand({\n    tab: node.Tab.Last,\n  });\n}\n\n/**\n * :tabe[dit]\n * :tabnew Open a new tab page with an empty window, after the current tab page.\n */\nexport function parseTabNewCommandArgs(args: string): node.TabCommand {\n  let name = '';\n\n  if (args) {\n    const scanner = new Scanner(args);\n    name = scanner.nextWord();\n  }\n\n  return new node.TabCommand({\n    tab: node.Tab.New,\n    file: name,\n  });\n}\n\n/**\n * :tabc[lose][!]  Close current tab page.\n * :tabc[lose][!] {count}. Close tab page {count}.\n */\nexport function parseTabCloseCommandArgs(args: string): node.TabCommand {\n  return new node.TabCommand({\n    tab: node.Tab.Close,\n    count: parseCount(args),\n  });\n}\n\nexport function parseTabOnlyCommandArgs(args: string): node.TabCommand {\n  return new node.TabCommand({\n    tab: node.Tab.Only,\n  });\n}\n\n/**\n * :tabm[ove] [N]\n * :tabm[ove] +[N]\n * :tabm[ove] -[N]\n */\nexport function parseTabMovementCommandArgs(args: string): node.TabCommand {\n  const { count, direction } = parseCountOrOffset(args);\n  return new node.TabCommand({\n    tab: node.Tab.Move,\n    count,\n    direction,\n  });\n}\n","import { ErrorCode, VimError } from '../../error';\nimport * as node from '../commands/wall';\nimport { Scanner } from '../scanner';\n\nexport function parseWallCommandArgs(args: string): node.WallCommand {\n  if (!args) {\n    return new node.WallCommand({});\n  }\n  const scannedArgs: node.IWallCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else if (c !== ' ') {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  scanner.skipWhiteSpace();\n  if (!scanner.isAtEof) {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  return new node.WallCommand(scannedArgs);\n}\n","import { IWriteCommandArguments, WriteCommand } from '../commands/write';\nimport { Scanner } from '../scanner';\n\nexport function parseWriteCommandArgs(args: string): WriteCommand {\n  if (!args) {\n    return new WriteCommand({ bgWrite: true });\n  }\n  const scannedArgs: IWriteCommandArguments = { bgWrite: true };\n  const scanner = new Scanner(args);\n  while (true) {\n    scanner.skipWhiteSpace();\n    if (scanner.isAtEof) {\n      break;\n    }\n    let c = scanner.next();\n    switch (c) {\n      case '!':\n        if (scanner.start > 0) {\n          // :write !cmd\n          scanner.ignore();\n          while (!scanner.isAtEof) {\n            scanner.next();\n          }\n          // vim ignores silently if no command after :w !\n          scannedArgs.cmd = scanner.emit().trim() || undefined;\n          continue;\n        }\n        // :write!\n        scannedArgs.bang = true;\n        scanner.ignore();\n        continue;\n      case '+':\n        // :write ++opt=value\n        scanner.expect('+');\n        scanner.ignore();\n        scanner.expectOneOf(['bin', 'nobin', 'ff', 'enc']);\n        scannedArgs.opt = scanner.emit();\n        scanner.expect('=');\n        scanner.ignore();\n        while (!scanner.isAtEof) {\n          c = scanner.next();\n          if (c !== ' ' && c !== '\\t') {\n            continue;\n          }\n          scanner.backup();\n          continue;\n        }\n        const value = scanner.emit();\n        if (!value) {\n          throw new Error('Expected value for option.');\n        }\n        scannedArgs.optValue = value;\n        continue;\n      default:\n        throw new Error('Not implemented.');\n    }\n  }\n  // TODO: actually parse arguments.\n  // ++bin ++nobin ++ff ++enc =VALUE\n  return new WriteCommand(scannedArgs);\n}\n","import { IWriteQuitCommandArguments, WriteQuitCommand } from '../commands/writequit';\nimport { Scanner } from '../scanner';\n\nexport function parseWriteQuitCommandArgs(args: string): WriteQuitCommand {\n  if (!args) {\n    return new WriteQuitCommand({});\n  }\n  const scannedArgs: IWriteQuitCommandArguments = {};\n  const scanner = new Scanner(args);\n  while (true) {\n    scanner.skipWhiteSpace();\n    if (scanner.isAtEof) {\n      break;\n    }\n    let c = scanner.next();\n    switch (c) {\n      case '!':\n        // :writequit!\n        scannedArgs.bang = true;\n        scanner.ignore();\n        continue;\n      case '+':\n        // :writequit ++opt=value\n        scanner.expect('+');\n        scanner.ignore();\n        scanner.expectOneOf(['bin', 'nobin', 'ff', 'enc']);\n        scannedArgs.opt = scanner.emit();\n        scanner.expect('=');\n        scanner.ignore();\n        while (!scanner.isAtEof) {\n          c = scanner.next();\n          if (c !== ' ' && c !== '\\t') {\n            continue;\n          }\n          scanner.backup();\n          continue;\n        }\n        const value = scanner.emit();\n        if (!value) {\n          throw new Error('Expected value for option.');\n        }\n        scannedArgs.optValue = value;\n        continue;\n      default:\n        throw new Error('Not implemented');\n    }\n  }\n  // TODO: parse the stuff (it's really not).\n  // ++bin ++nobin ++ff ++enc =VALUE\n  return new WriteQuitCommand(scannedArgs);\n}\n","import { ErrorCode, VimError } from '../../error';\nimport * as node from '../commands/writequitall';\nimport { Scanner } from '../scanner';\n\nexport function parseWriteQuitAllCommandArgs(args: string): node.WriteQuitAllCommand {\n  if (!args) {\n    return new node.WriteQuitAllCommand({});\n  }\n  const scannedArgs: node.IWriteQuitAllCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else if (c !== ' ') {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  scanner.skipWhiteSpace();\n  if (!scanner.isAtEof) {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  return new node.WriteQuitAllCommand(scannedArgs);\n}\n","// Tokens for the Vim command line.\n\nexport enum TokenType {\n  Unknown,\n  Eof,\n  LineNumber,\n  Dot,\n  Dollar,\n  Percent,\n  Comma,\n  Plus,\n  Minus,\n  CommandName,\n  CommandArgs,\n  ForwardSearch,\n  ReverseSearch,\n  Offset,\n  /**\n   * Marks\n   */\n  SelectionFirstLine,\n  SelectionLastLine,\n  Mark,\n}\n\nexport class Token {\n  type: TokenType;\n  content: string;\n\n  constructor(type: TokenType, content: string) {\n    this.type = type;\n    this.content = content;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from '../../configuration/configuration';\nimport { VimState } from '../../state/vimState';\nimport { Position } from 'vscode';\n\n/**\n * PairMatcher finds the position matching the given character, respecting nested\n * instances of the pair.\n */\nexport class PairMatcher {\n  static pairings: {\n    [key: string]: {\n      match: string;\n      isNextMatchForward: boolean;\n      directionless?: boolean;\n      matchesWithPercentageMotion?: boolean;\n    };\n  } = {\n    '(': { match: ')', isNextMatchForward: true, matchesWithPercentageMotion: true },\n    '{': { match: '}', isNextMatchForward: true, matchesWithPercentageMotion: true },\n    '[': { match: ']', isNextMatchForward: true, matchesWithPercentageMotion: true },\n    ')': { match: '(', isNextMatchForward: false, matchesWithPercentageMotion: true },\n    '}': { match: '{', isNextMatchForward: false, matchesWithPercentageMotion: true },\n    ']': { match: '[', isNextMatchForward: false, matchesWithPercentageMotion: true },\n\n    // These characters can't be used for \"%\"-based matching, but are still\n    // useful for text objects.\n    '<': { match: '>', isNextMatchForward: true },\n    '>': { match: '<', isNextMatchForward: false },\n    // These are useful for deleting closing and opening quotes, but don't seem to negatively\n    // affect how text objects such as `ci\"` work, which was my worry.\n    '\"': { match: '\"', isNextMatchForward: false, directionless: true },\n    \"'\": { match: \"'\", isNextMatchForward: false, directionless: true },\n    '`': { match: '`', isNextMatchForward: false, directionless: true },\n  };\n\n  private static findPairedChar(\n    position: Position,\n    charToFind: string,\n    charToStack: string,\n    stackHeight: number,\n    isNextMatchForward: boolean,\n    vimState: VimState,\n    allowCurrentPosition: boolean\n  ): Position | undefined {\n    let lineNumber = position.line;\n    const linePosition = position.character;\n    const lineCount = vimState.document.lineCount;\n    const cursorChar = vimState.document.lineAt(position).text[position.character];\n    if (\n      allowCurrentPosition &&\n      vimState.cursorStartPosition.isEqual(vimState.cursorStopPosition) &&\n      cursorChar === charToFind\n    ) {\n      return position;\n    }\n\n    while (PairMatcher.keepSearching(lineNumber, lineCount, isNextMatchForward)) {\n      let lineText = vimState.document.lineAt(lineNumber).text.split('');\n      const originalLineLength = lineText.length;\n      if (lineNumber === position.line) {\n        if (isNextMatchForward) {\n          lineText = lineText.slice(linePosition + 1, originalLineLength);\n        } else {\n          lineText = lineText.slice(0, linePosition);\n        }\n      }\n\n      while (true) {\n        if (lineText.length <= 0 || stackHeight <= -1) {\n          break;\n        }\n\n        let nextChar: string | undefined;\n        if (isNextMatchForward) {\n          nextChar = lineText.shift();\n        } else {\n          nextChar = lineText.pop();\n        }\n\n        if (nextChar === charToStack) {\n          stackHeight++;\n        } else if (nextChar === charToFind) {\n          stackHeight--;\n        } else {\n          continue;\n        }\n      }\n\n      if (stackHeight <= -1) {\n        let pairMemberChar: number;\n        if (isNextMatchForward) {\n          pairMemberChar = Math.max(0, originalLineLength - lineText.length - 1);\n        } else {\n          pairMemberChar = lineText.length;\n        }\n        return new Position(lineNumber, pairMemberChar);\n      }\n\n      if (isNextMatchForward) {\n        lineNumber++;\n      } else {\n        lineNumber--;\n      }\n    }\n    return undefined;\n  }\n\n  private static keepSearching(lineNumber: number, lineCount: number, isNextMatchForward: boolean) {\n    if (isNextMatchForward) {\n      return lineNumber <= lineCount - 1;\n    } else {\n      return lineNumber >= 0;\n    }\n  }\n\n  static nextPairedChar(\n    position: Position,\n    charToMatch: string,\n    vimState: VimState,\n    allowCurrentPosition: boolean\n  ): Position | undefined {\n    /**\n     * We do a fairly basic implementation that only tracks the state of the type of\n     * character you're over and its pair (e.g. \"[\" and \"]\"). This is similar to\n     * what Vim does.\n     *\n     * It can't handle strings very well - something like \"|( ')' )\" where | is the\n     * cursor will cause it to go to the ) in the quotes, even though it should skip over it.\n     *\n     * PRs welcomed! (TODO)\n     * Though ideally VSC implements https://github.com/Microsoft/vscode/issues/7177\n     */\n    const pairing = this.pairings[charToMatch];\n\n    if (pairing === undefined || pairing.directionless) {\n      return undefined;\n    }\n\n    const stackHeight = 0;\n    let matchedPos: Position | undefined;\n    const charToFind = pairing.match;\n    const charToStack = charToMatch;\n\n    matchedPos = PairMatcher.findPairedChar(\n      position,\n      charToFind,\n      charToStack,\n      stackHeight,\n      pairing.isNextMatchForward,\n      vimState,\n      allowCurrentPosition\n    );\n\n    if (matchedPos) {\n      return matchedPos;\n    }\n    // TODO(bell)\n    return undefined;\n  }\n\n  static shouldDeleteMatchingBracket(type: 'bracket' | 'quote') {\n    // Don't delete bracket unless autoClosingBrackets is set.\n    const cfgKey = type === 'bracket' ? 'editor.autoClosingBrackets' : 'editor.autoClosingQuotes';\n    const cfgValue = configuration.getConfiguration().get(cfgKey);\n\n    if (cfgValue === 'never') {\n      return false;\n    } else if (cfgValue === 'languageDefined') {\n      // TODO: if possible, we should look up and use the current language's configuration\n      return true;\n    }\n\n    return true;\n  }\n\n  /**\n   * Given a current position, find an immediate following bracket and return the range. If\n   * no matching bracket is found immediately following the opening bracket, return undefined.\n   * This is intended for the deletion of such pairs, so it respects `editor.autoClosingBrackets`.\n   */\n  static immediateMatchingBracket(\n    vimState: VimState,\n    currentPosition: Position\n  ): vscode.Range | undefined {\n    if (currentPosition.isLineEnd()) {\n      return undefined;\n    }\n\n    const charactersToMatch =\n      (this.shouldDeleteMatchingBracket('bracket') ? '{[(' : '') +\n      (this.shouldDeleteMatchingBracket('quote') ? '\"\\'`' : '');\n    const deleteRange = new vscode.Range(\n      currentPosition,\n      currentPosition.getLeftThroughLineBreaks()\n    );\n    const deleteText = vimState.document.getText(deleteRange);\n    let matchRange: vscode.Range | undefined;\n    let isNextMatch = false;\n\n    if (charactersToMatch.includes(deleteText)) {\n      const matchPosition = currentPosition.getRight();\n      matchRange = new vscode.Range(matchPosition, matchPosition.getLeftThroughLineBreaks());\n      isNextMatch =\n        vimState.document.getText(matchRange) === PairMatcher.pairings[deleteText].match;\n    }\n\n    if (isNextMatch && matchRange) {\n      return matchRange;\n    }\n\n    return undefined;\n  }\n}\n","enum QuoteMatch {\n  None,\n  Opening,\n  Closing,\n}\n\n/**\n * QuoteMatcher matches quoted strings, respecting escaped quotes (\\\") and friends\n */\nexport class QuoteMatcher {\n  static escapeChar = '\\\\';\n\n  private quoteMap: QuoteMatch[] = [];\n\n  constructor(char: string, corpus: string) {\n    let openingQuote = false;\n    // Loop over corpus, marking quotes and respecting escape characters.\n    for (let i = 0; i < corpus.length; i++) {\n      if (corpus[i] === QuoteMatcher.escapeChar) {\n        i += 1;\n        continue;\n      }\n      if (corpus[i] === char) {\n        openingQuote = !openingQuote;\n        this.quoteMap[i] = openingQuote ? QuoteMatch.Opening : QuoteMatch.Closing;\n      }\n    }\n  }\n\n  findOpening(start: number): number {\n    // First, search backwards to see if we could be inside a quote\n    for (let i = start; i >= 0; i--) {\n      if (this.quoteMap[i]) {\n        return i;\n      }\n    }\n\n    // Didn't find one behind us, the string may start ahead of us. This happens\n    // to be the same logic we use to search forwards.\n    return this.findClosing(start);\n  }\n\n  findClosing(start: number): number {\n    // Search forwards from start, looking for a non-escaped char\n    for (let i = start; i <= this.quoteMap.length; i++) {\n      if (this.quoteMap[i]) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n}\n","import { TextEditor } from '../../textEditor';\nimport { VimState } from '../../state/vimState';\n\ntype Tag = { name: string; type: 'close' | 'open'; startPos: number; endPos: number };\ntype MatchedTag = {\n  tag: string;\n  openingTagStart: number;\n  openingTagEnd: number;\n  closingTagStart: number;\n  closingTagEnd: number;\n};\n\nexport class TagMatcher {\n  // see regexr.com/3t585\n  static TAG_REGEX = /\\<(\\/)?([^\\>\\<\\s\\/]+)(?:[^\\>\\<]*?)(\\/)?\\>/g;\n  static OPEN_FORWARD_SLASH = 1;\n  static TAG_NAME = 2;\n  static CLOSE_FORWARD_SLASH = 3;\n\n  openStart: number | undefined;\n  openEnd: number | undefined;\n  closeStart: number | undefined;\n  closeEnd: number | undefined;\n\n  constructor(corpus: string, position: number, vimState: VimState) {\n    let match = TagMatcher.TAG_REGEX.exec(corpus);\n    const tags: Tag[] = [];\n\n    // Gather all the existing tags.\n    while (match) {\n      // Node is a self closing tag, skip.\n      if (match[TagMatcher.CLOSE_FORWARD_SLASH]) {\n        match = TagMatcher.TAG_REGEX.exec(corpus);\n        continue;\n      }\n\n      tags.push({\n        name: match[TagMatcher.TAG_NAME],\n        type: match[TagMatcher.OPEN_FORWARD_SLASH] ? 'close' : 'open',\n        startPos: match.index,\n        endPos: TagMatcher.TAG_REGEX.lastIndex,\n      });\n\n      match = TagMatcher.TAG_REGEX.exec(corpus);\n    }\n\n    const stack: Tag[] = [];\n    const matchedTags: MatchedTag[] = [];\n\n    for (const tag of tags) {\n      // We have to push on the stack\n      // if it is an open tag.\n      if (tag.type === 'open') {\n        stack.push(tag);\n      } else {\n        // We have an unmatched closing tag,\n        // so try and match it with any existing tag.\n        for (let i = stack.length - 1; i >= 0; i--) {\n          const openNode = stack[i];\n\n          if (openNode.type === 'open' && openNode.name === tag.name) {\n            // A matching tag was found, ignore\n            // any tags that were in between.\n            matchedTags.push({\n              tag: openNode.name,\n              openingTagStart: openNode.startPos,\n              openingTagEnd: openNode.endPos,\n              closingTagStart: tag.startPos,\n              closingTagEnd: tag.endPos,\n            });\n\n            stack.splice(i);\n            break;\n          }\n        }\n      }\n    }\n\n    const firstNonWhitespacePositionOnLine = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStartPosition.line\n    );\n\n    /**\n     * This adjustment fixes the following situation:\n     * <foo>\n     * |  <bar>\n     *    test\n     *    </bar>\n     * </foo>\n     * Now in tag matching situations, the tag opening on the cursor line is considered as well\n     * (if there is only whitespace before the tag and the cursor is standing on these whitespaces)\n     */\n    const startPos =\n      vimState.cursorStartPosition.character < firstNonWhitespacePositionOnLine.character\n        ? firstNonWhitespacePositionOnLine\n        : vimState.cursorStartPosition;\n\n    const startPosOffset = vimState.document.offsetAt(startPos);\n    const endPosOffset = position;\n    const tagsSurrounding = matchedTags.filter((n) => {\n      return startPosOffset >= n.openingTagStart && endPosOffset < n.closingTagEnd;\n    });\n\n    if (!tagsSurrounding.length) {\n      return;\n    }\n\n    const nodeSurrounding = this.determineRelevantTag(\n      tagsSurrounding,\n      startPosOffset,\n      vimState.cursorStartPosition.compareTo(vimState.cursorStopPosition) !== 0\n    );\n\n    if (!nodeSurrounding) {\n      return;\n    }\n\n    this.openStart = nodeSurrounding.openingTagStart;\n    this.closeEnd = nodeSurrounding.closingTagEnd;\n    // if the inner tag content is already selected, expand to enclose tags with 'it' as in vim\n    if (\n      startPosOffset === nodeSurrounding.openingTagEnd &&\n      endPosOffset + 1 === nodeSurrounding.closingTagStart\n    ) {\n      this.openEnd = this.openStart;\n      this.closeStart = this.closeEnd;\n    } else {\n      this.openEnd = nodeSurrounding.openingTagEnd;\n      this.closeStart = nodeSurrounding.closingTagStart;\n    }\n  }\n\n  /**\n   * Most of the time the relevant tag is the innermost tag, but when Visual mode is active,\n   * the rules are different.\n   * When the cursorStart is standing on the < character of the inner tag, with \"at\" we must\n   * jump to the outer tag.\n   */\n  determineRelevantTag(\n    tagsSurrounding: MatchedTag[],\n    adjustedStartPosOffset: number,\n    selectionActive: boolean\n  ): MatchedTag | undefined {\n    const relevantTag = tagsSurrounding[0];\n\n    if (selectionActive && adjustedStartPosOffset === relevantTag.openingTagStart) {\n      // we adjusted so we have to return the outer tag\n      return tagsSurrounding[1];\n    } else {\n      return relevantTag;\n    }\n  }\n\n  findOpening(inclusive: boolean): number | undefined {\n    if (inclusive) {\n      return this.openStart;\n    }\n    return this.openEnd;\n  }\n\n  findClosing(inclusive: boolean): number | undefined {\n    if (inclusive) {\n      return this.closeEnd;\n    }\n    return this.closeStart;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from './../../configuration/configuration';\nimport { TextEditor } from './../../textEditor';\nimport { clamp } from '../../util/util';\nimport { getSentenceBegin, getSentenceEnd } from '../../textobject/sentence';\nimport {\n  WordType,\n  getCurrentWordEnd,\n  getLastWordEnd,\n  getWordLeft,\n  getWordRight,\n} from '../../textobject/word';\nimport { Position } from 'vscode';\n\n/**\n * Controls how a PositionDiff affects the Position it's applied to.\n */\nexport enum PositionDiffType {\n  /** Simple line and column offset */\n  Offset,\n  /**\n   * Sets the Position's column to `PositionDiff.character`\n   */\n  ExactCharacter,\n  /** Brings the Position to the beginning of the line if `vim.startofline` is true */\n  ObeyStartOfLine,\n}\n\n/**\n * Represents a difference between two Positions.\n * Add it to a Position to get another Position.\n */\nexport class PositionDiff {\n  public readonly line: number;\n  public readonly character: number;\n  public readonly type: PositionDiffType;\n\n  constructor({ line = 0, character = 0, type = PositionDiffType.Offset } = {}) {\n    this.line = line;\n    this.character = character;\n    this.type = type;\n  }\n\n  public static newBOLDiff(lineOffset: number = 0) {\n    return new PositionDiff({\n      line: lineOffset,\n      character: 0,\n      type: PositionDiffType.ExactCharacter,\n    });\n  }\n\n  public toString(): string {\n    switch (this.type) {\n      case PositionDiffType.Offset:\n        return `[ Diff: Offset ${this.line} ${this.character} ]`;\n      case PositionDiffType.ExactCharacter:\n        return `[ Diff: ExactCharacter ${this.line} ${this.character} ]`;\n      case PositionDiffType.ObeyStartOfLine:\n        return `[ Diff: ObeyStartOfLine ${this.line} ]`;\n      default:\n        throw new Error(`Unknown PositionDiffType: ${this.type}`);\n    }\n  }\n}\n\n/**\n * @returns the Position of the 2 provided which comes earlier in the document.\n */\nexport function earlierOf(p1: Position, p2: Position): Position {\n  return p1.isBefore(p2) ? p1 : p2;\n}\n\n/**\n * @returns the Position of the 2 provided which comes later in the document.\n */\nexport function laterOf(p1: Position, p2: Position): Position {\n  return p1.isBefore(p2) ? p2 : p1;\n}\n\n/**\n * @returns the given Positions in the order they appear in the document.\n */\nexport function sorted(p1: Position, p2: Position): [Position, Position] {\n  return p1.isBefore(p2) ? [p1, p2] : [p2, p1];\n}\n\ndeclare module 'vscode' {\n  interface Position {\n    toString(): string;\n\n    add(document: vscode.TextDocument, diff: PositionDiff, boundsCheck?: boolean): Position;\n    subtract(other: Position): PositionDiff;\n\n    /**\n     * @returns a new Position with the same character and the given line.\n     * Does bounds-checking to make sure the result is valid.\n     */\n    withLine(line: number): Position;\n    /**\n     * @returns a new Position with the same line and the given character.\n     * Does bounds-checking to make sure the result is valid.\n     */\n    withColumn(column: number): Position;\n\n    /**\n     * @returns the Position `count` characters to the left of this Position. Does not go over line breaks.\n     */\n    getLeft(count?: number): Position;\n    /**\n     * @returns the Position `count` characters to the right of this Position. Does not go over line breaks.\n     */\n    getRight(count?: number): Position;\n    /**\n     * @returns the Position `count` lines down from this Position\n     */\n    getDown(count?: number): Position;\n    /**\n     * @returns the Position `count` lines up from this Position\n     */\n    getUp(count?: number): Position;\n\n    getLeftThroughLineBreaks(includeEol?: boolean): Position;\n    getRightThroughLineBreaks(includeEol?: boolean): Position;\n    getOffsetThroughLineBreaks(offset: number): Position;\n\n    getWordLeft(inclusive?: boolean): Position;\n    getWordRight(inclusive?: boolean): Position;\n    getCurrentWordEnd(inclusive?: boolean): Position;\n    getLastWordEnd(): Position;\n\n    getBigWordLeft(inclusive?: boolean): Position;\n    getBigWordRight(): Position;\n    getCurrentBigWordEnd(inclusive?: boolean): Position;\n    getLastBigWordEnd(): Position;\n\n    getSentenceBegin(args: { forward: boolean }): Position;\n    getSentenceEnd(): Position;\n\n    getLineBegin(): Position;\n\n    /**\n     * @returns the beginning of the line, excluding preceeding whitespace.\n     * This respects the `autoindent` setting, and returns `getLineBegin()` if auto-indent is disabled.\n     */\n    getLineBeginRespectingIndent(document: vscode.TextDocument): Position;\n\n    /**\n     * @return the beginning of the previous line.\n     * If already on the first line, return the beginning of this line.\n     */\n    getPreviousLineBegin(): Position;\n\n    /**\n     * @return the beginning of the next line.\n     * If already on the last line, return the *end* of this line.\n     */\n    getNextLineBegin(): Position;\n\n    /**\n     * @returns a new Position at the end of this position's line.\n     */\n    getLineEnd(): Position;\n\n    /**\n     * @returns a new Position at the end of this Position's line, including the invisible newline character.\n     */\n    getLineEndIncludingEOL(): Position;\n\n    /**\n     * @returns a new Position one to the left if this Position is on the EOL. Otherwise, returns this position.\n     */\n    getLeftIfEOL(): Position;\n\n    /**\n     * @returns the position that the cursor would be at if you pasted *text* at the current position.\n     */\n    advancePositionByText(text: string): Position;\n\n    /**\n     * Is this position at the beginning of the line?\n     */\n    isLineBeginning(): boolean;\n\n    /**\n     * Is this position at the end of the line?\n     */\n    isLineEnd(): boolean;\n\n    isFirstWordOfLine(document: vscode.TextDocument): boolean;\n\n    isAtDocumentBegin(): boolean;\n\n    isAtDocumentEnd(): boolean;\n\n    /**\n     * Returns whether the current position is in the leading whitespace of a line\n     */\n    isInLeadingWhitespace(document: vscode.TextDocument): boolean;\n\n    /**\n     * If `vim.startofline` is set, get first non-blank character's position.\n     */\n    obeyStartOfLine(document: vscode.TextDocument): Position;\n\n    isValid(textEditor: vscode.TextEditor): boolean;\n  }\n}\n\nPosition.prototype.toString = function (this: Position) {\n  return `[${this.line}, ${this.character}]`;\n};\n\nPosition.prototype.add = function (\n  this: Position,\n  document: vscode.TextDocument,\n  diff: PositionDiff,\n  boundsCheck = true\n): Position {\n  const resultLine = clamp(this.line + diff.line, 0, document.lineCount - 1);\n\n  let resultChar: number;\n  if (diff.type === PositionDiffType.Offset) {\n    resultChar = this.character + diff.character;\n  } else if (diff.type === PositionDiffType.ExactCharacter) {\n    resultChar = diff.character;\n  } else if (diff.type === PositionDiffType.ObeyStartOfLine) {\n    resultChar = this.withLine(resultLine).obeyStartOfLine(document).character;\n  } else {\n    throw new Error(`Unknown PositionDiffType: ${diff.type}`);\n  }\n\n  const pos = new Position(resultLine, Math.max(resultChar, 0));\n  return boundsCheck ? document.validatePosition(pos) : pos;\n};\n\nPosition.prototype.subtract = function (this: Position, other: Position): PositionDiff {\n  return new PositionDiff({\n    line: this.line - other.line,\n    character: this.character - other.character,\n  });\n};\n\n/**\n * @returns a new Position with the same character and the given line.\n * Does bounds-checking to make sure the result is valid.\n */\nPosition.prototype.withLine = function (this: Position, line: number): Position {\n  line = clamp(line, 0, TextEditor.getLineCount() - 1);\n  return new Position(line, this.character);\n};\n\n/**\n * @returns a new Position with the same line and the given character.\n * Does bounds-checking to make sure the result is valid.\n */\nPosition.prototype.withColumn = function (this: Position, column: number): Position {\n  column = clamp(column, 0, TextEditor.getLineLength(this.line));\n  return new Position(this.line, column);\n};\n\n/**\n * @returns the Position `count` characters to the left of this Position. Does not go over line breaks.\n */\nPosition.prototype.getLeft = function (this: Position, count = 1): Position {\n  return new Position(this.line, Math.max(this.character - count, 0));\n};\n\n/**\n * @returns the Position `count` characters to the right of this Position. Does not go over line breaks.\n */\nPosition.prototype.getRight = function (this: Position, count = 1): Position {\n  return new Position(\n    this.line,\n    Math.min(this.character + count, TextEditor.getLineLength(this.line))\n  );\n};\n\n/**\n * @returns the Position `count` lines down from this Position\n */\nPosition.prototype.getDown = function (this: Position, count = 1): Position {\n  const line = Math.min(this.line + count, TextEditor.getLineCount() - 1);\n  return new Position(line, Math.min(this.character, TextEditor.getLineLength(line)));\n};\n\n/**\n * @returns the Position `count` lines up from this Position\n */\nPosition.prototype.getUp = function (this: Position, count = 1): Position {\n  const line = Math.max(this.line - count, 0);\n  return new Position(line, Math.min(this.character, TextEditor.getLineLength(line)));\n};\n\n/**\n * Same as getLeft, but goes up to the previous line on line breaks.\n * Equivalent to left arrow (in a non-vim editor!)\n */\nPosition.prototype.getLeftThroughLineBreaks = function (\n  this: Position,\n  includeEol = true\n): Position {\n  if (!this.isLineBeginning()) {\n    return this.getLeft();\n  }\n\n  // First char on first line, can not go left any more\n  if (this.line === 0) {\n    return this;\n  }\n\n  if (includeEol) {\n    return this.getUp().getLineEnd();\n  } else {\n    return this.getUp().getLineEnd().getLeft();\n  }\n};\n\nPosition.prototype.getRightThroughLineBreaks = function (\n  this: Position,\n  includeEol = false\n): Position {\n  if (this.isAtDocumentEnd()) {\n    return this;\n  }\n\n  if (this.line < TextEditor.getLineCount() - 1) {\n    const pos = includeEol ? this : this.getRight();\n    if (pos.isLineEnd()) {\n      return this.with({ character: 0 }).getDown();\n    }\n  } else if (!includeEol && this.character === TextEditor.getLineLength(this.line) - 1) {\n    // Last character of document, don't go on to non-existent EOL\n    return this;\n  }\n\n  return this.getRight();\n};\n\nPosition.prototype.getOffsetThroughLineBreaks = function (\n  this: Position,\n  offset: number\n): Position {\n  let pos = new Position(this.line, this.character);\n\n  if (offset < 0) {\n    for (let i = 0; i < -offset; i++) {\n      pos = pos.getLeftThroughLineBreaks();\n    }\n  } else {\n    for (let i = 0; i < offset; i++) {\n      pos = pos.getRightThroughLineBreaks();\n    }\n  }\n\n  return pos;\n};\n\n/**\n * Inclusive is true if we consider the current position a valid result, false otherwise.\n */\nPosition.prototype.getWordLeft = function (this: Position, inclusive: boolean = false): Position {\n  return getWordLeft(this, WordType.Normal, inclusive);\n};\n\nPosition.prototype.getBigWordLeft = function (\n  this: Position,\n  inclusive: boolean = false\n): Position {\n  return getWordLeft(this, WordType.Big, inclusive);\n};\n\n/**\n * Inclusive is true if we consider the current position a valid result, false otherwise.\n */\nPosition.prototype.getWordRight = function (this: Position, inclusive: boolean = false): Position {\n  return getWordRight(this, WordType.Normal, inclusive);\n};\n\nPosition.prototype.getBigWordRight = function (this: Position): Position {\n  return getWordRight(this, WordType.Big);\n};\n\nPosition.prototype.getLastWordEnd = function (this: Position): Position {\n  return getLastWordEnd(this, WordType.Normal);\n};\n\nPosition.prototype.getLastBigWordEnd = function (this: Position): Position {\n  return getLastWordEnd(this, WordType.Big);\n};\n\n/**\n * Inclusive is true if we consider the current position a valid result, false otherwise.\n */\nPosition.prototype.getCurrentWordEnd = function (\n  this: Position,\n  inclusive: boolean = false\n): Position {\n  return getCurrentWordEnd(this, WordType.Normal, inclusive);\n};\n\n/**\n * Inclusive is true if we consider the current position a valid result, false otherwise.\n */\nPosition.prototype.getCurrentBigWordEnd = function (\n  this: Position,\n  inclusive: boolean = false\n): Position {\n  return getCurrentWordEnd(this, WordType.Big, inclusive);\n};\n\nPosition.prototype.getSentenceBegin = function (\n  this: Position,\n  args: { forward: boolean }\n): Position {\n  return getSentenceBegin(this, args);\n};\n\nPosition.prototype.getSentenceEnd = function (this: Position): Position {\n  return getSentenceEnd(this);\n};\n\n/**\n * @returns a new Position at the beginning of the current line.\n */\nPosition.prototype.getLineBegin = function (this: Position): Position {\n  return new Position(this.line, 0);\n};\n\n/**\n * @returns the beginning of the line, excluding preceeding whitespace.\n * This respects the `autoindent` setting, and returns `getLineBegin()` if auto-indent is disabled.\n */\nPosition.prototype.getLineBeginRespectingIndent = function (\n  this: Position,\n  document: vscode.TextDocument\n): Position {\n  if (!configuration.autoindent) {\n    return this.getLineBegin();\n  }\n  return TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line);\n};\n\n/**\n * @return the beginning of the previous line.\n * If already on the first line, return the beginning of this line.\n */\nPosition.prototype.getPreviousLineBegin = function (this: Position): Position {\n  if (this.line === 0) {\n    return this.getLineBegin();\n  }\n\n  return new Position(this.line - 1, 0);\n};\n\n/**\n * @return the beginning of the next line.\n * If already on the last line, return the *end* of this line.\n */\nPosition.prototype.getNextLineBegin = function (this: Position): Position {\n  if (this.line >= TextEditor.getLineCount() - 1) {\n    return this.getLineEnd();\n  }\n\n  return new Position(this.line + 1, 0);\n};\n\n/**\n * @returns a new Position at the end of this position's line.\n */\nPosition.prototype.getLineEnd = function (this: Position): Position {\n  return new Position(this.line, TextEditor.getLineLength(this.line));\n};\n\n/**\n * @returns a new Position at the end of this Position's line, including the invisible newline character.\n */\nPosition.prototype.getLineEndIncludingEOL = function (this: Position): Position {\n  // TODO: isn't this one too far?\n  return new Position(this.line, TextEditor.getLineLength(this.line) + 1);\n};\n\n/**\n * @returns a new Position one to the left if this Position is on the EOL. Otherwise, returns this position.\n */\nPosition.prototype.getLeftIfEOL = function (this: Position): Position {\n  return this.character === TextEditor.getLineLength(this.line) ? this.getLeft() : this;\n};\n\n/**\n * @returns the position that the cursor would be at if you pasted *text* at the current position.\n */\nPosition.prototype.advancePositionByText = function (this: Position, text: string): Position {\n  const newlines: number[] = [];\n  let idx = text.indexOf('\\n', 0);\n  while (idx >= 0) {\n    newlines.push(idx);\n    idx = text.indexOf('\\n', idx + 1);\n  }\n\n  if (newlines.length === 0) {\n    return new Position(this.line, this.character + text.length);\n  } else {\n    return new Position(\n      this.line + newlines.length,\n      text.length - (newlines[newlines.length - 1] + 1)\n    );\n  }\n};\n\n/**\n * Is this position at the beginning of the line?\n */\nPosition.prototype.isLineBeginning = function (this: Position): boolean {\n  return this.character === 0;\n};\n\n/**\n * Is this position at the end of the line?\n */\nPosition.prototype.isLineEnd = function (this: Position): boolean {\n  return this.character >= TextEditor.getLineLength(this.line);\n};\n\nPosition.prototype.isFirstWordOfLine = function (\n  this: Position,\n  document: vscode.TextDocument\n): boolean {\n  return (\n    TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line).character === this.character\n  );\n};\n\nPosition.prototype.isAtDocumentBegin = function (this: Position): boolean {\n  return this.line === 0 && this.isLineBeginning();\n};\n\nPosition.prototype.isAtDocumentEnd = function (this: Position): boolean {\n  return this.line === TextEditor.getLineCount() - 1 && this.isLineEnd();\n};\n\n/**\n * Returns whether the current position is in the leading whitespace of a line\n * @param allowEmpty : Use true if \"\" is valid\n */\nPosition.prototype.isInLeadingWhitespace = function (\n  this: Position,\n  document: vscode.TextDocument\n): boolean {\n  return /^\\s+$/.test(document.getText(new vscode.Range(this.getLineBegin(), this)));\n};\n\n/**\n * If `vim.startofline` is set, get first non-blank character's position.\n */\nPosition.prototype.obeyStartOfLine = function (\n  this: Position,\n  document: vscode.TextDocument\n): Position {\n  return configuration.startofline\n    ? TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line)\n    : this;\n};\n\nPosition.prototype.isValid = function (this: Position, textEditor: vscode.TextEditor): boolean {\n  try {\n    // line\n    // TODO: this `|| 1` seems dubious...\n    const lineCount = TextEditor.getLineCount(textEditor) || 1;\n    if (this.line >= lineCount) {\n      return false;\n    }\n\n    // char\n    const charCount = TextEditor.getLineLength(this.line);\n    if (this.character > charCount + 1) {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nexport class Range {\n  public readonly start: Position;\n  public readonly stop: Position;\n\n  constructor(start: Position, stop: Position) {\n    this.start = start;\n    this.stop = stop;\n  }\n\n  public isValid(textEditor: vscode.TextEditor) {\n    return this.start.isValid(textEditor) && this.stop.isValid(textEditor);\n  }\n\n  /**\n   * Create a range from a VSCode selection.\n   */\n  public static FromVSCodeSelection(sel: vscode.Selection): Range {\n    return new Range(sel.start, sel.end);\n  }\n\n  public equals(other: Range): boolean {\n    return this.start.isEqual(other.start) && this.stop.isEqual(other.stop);\n  }\n\n  /**\n   * Returns a new Range which is the same as this Range, but with the provided stop value.\n   */\n  public withNewStop(stop: Position): Range {\n    return new Range(this.start, stop);\n  }\n\n  /**\n   * Returns a new Range which is the same as this Range, but with the provided start value.\n   */\n  public withNewStart(start: Position): Range {\n    return new Range(start, this.stop);\n  }\n\n  public toString(): string {\n    return `[ ${this.start.toString()} | ${this.stop.toString()}]`;\n  }\n\n  public overlaps(other: Range): boolean {\n    return this.start.isBefore(other.stop) && other.start.isBefore(this.stop);\n  }\n}\n","/**\n *      aaaa0x111bbbbbb\n *      |-------------| => NumericString\n *      |--|            => prefix\n *          |---|       => core\n *               |----| => suffix\n *          ||          => numPrefix\n *            |-|       => num\n *\n * Greedy matching, leftmost match wins.\n * If multiple matches begin at the same position, the match with the biggest\n *   span wins.\n * If multiple matches have the same begin position and span (This usually\n *   happens on octal and decimal), following priority sequence is used:\n *   (decimal => octal => hexadecimal)\n *\n * Example:\n *                    |  core  |     What we got      |     Rather than     |\n *  ------------------|--------|----------------------|---------------------|\n *  Leftmost rule:    | 010xff |    (010)xff [octal]  |    01(0xff) [hex]   |\n *  Biggest span rule:| 0xff   |     (0xff) [hex]     |   (0)xff [decimal]  |\n *  Priority rule:    | 00007  |    (00007) [octal]   |  (00007) [decimal]  |\n *\n * Side Effect:\n *  -0xf  Will be parsed as (-0)xf rather than -(0xf), current workaround is\n *          capturing '-' in hexadecimal regex but not consider '-' as a part\n *          of the number. This is achieved by using `negative` boolean value\n *          in `NumericString`.\n */\nexport class NumericString {\n  radix: number;\n  value: number;\n  numLength: number;\n  prefix: string;\n  suffix: string;\n  // If a negative sign should be manually added when converting to string.\n  negative: boolean;\n\n  // Map radix to number prefix\n  private static numPrefix = {\n    8: '0',\n    10: '',\n    16: '0x',\n  };\n\n  // Keep octal at the top of decimal to avoid regarding 0000007 as decimal.\n  // '000009' matches decimal.\n  // '000007' matches octal.\n  // '-0xf' matches hex rather than decimal '-0'\n  private static matchings: Array<{ regex: RegExp; radix: number }> = [\n    { regex: /(-)?0[0-7]+/, radix: 8 },\n    { regex: /(-)?\\d+/, radix: 10 },\n    { regex: /(-)?0x[\\da-fA-F]+/, radix: 16 },\n  ];\n\n  // Return parse result and offset of suffix\n  public static parse(input: string): { num: NumericString; suffixOffset: number } | undefined {\n    // Find core numeric part of input\n    let coreBegin = -1;\n    let coreLength = -1;\n    let coreRadix = -1;\n    let coreSign = false;\n    for (const { regex, radix } of NumericString.matchings) {\n      const match = regex.exec(input);\n      if (match != null) {\n        // Get the leftmost and largest match\n        if (\n          coreRadix < 0 ||\n          match.index < coreBegin ||\n          (match.index === coreBegin && match[0].length > coreLength)\n        ) {\n          coreBegin = match.index;\n          coreLength = match[0].length;\n          coreRadix = radix;\n          coreSign = match[1] === '-';\n        }\n      }\n    }\n\n    if (coreRadix < 0) {\n      return undefined;\n    }\n\n    const coreEnd = coreBegin + coreLength;\n\n    const prefix = input.slice(0, coreBegin);\n    const core = input.slice(coreBegin, coreEnd);\n    const suffix = input.slice(coreEnd, input.length);\n\n    let value = parseInt(core, coreRadix);\n\n    // 0x00ff:  numLength = 4\n    // 077:     numLength = 2\n    // -0999:   numLength = 3\n    // The numLength is only useful for parsing non-decimal. Decimal with\n    // leading zero will be trimmed in `toString()`. If value is negative,\n    // remove the width of negative sign.\n    const numLength = coreLength - NumericString.numPrefix[coreRadix].length - (coreSign ? 1 : 0);\n\n    // According to original vim's behavior, for hex and octal, the leading\n    // '-' *should* be captured and preserved but *should not* be regarded as\n    // part of number, which means with <C-a>, `-0xf` turns into `-0x10`. So\n    // for hex and octal, we make the value absolute and set the negative\n    // sign flag.\n    let negative = false;\n    if (coreRadix !== 10 && coreSign) {\n      value = -value;\n      negative = true;\n    }\n\n    return {\n      num: new NumericString(value, coreRadix, numLength, prefix, suffix, negative),\n      suffixOffset: coreEnd,\n    };\n  }\n\n  private constructor(\n    value: number,\n    radix: number,\n    numLength: number,\n    prefix: string,\n    suffix: string,\n    negative: boolean\n  ) {\n    this.value = value;\n    this.radix = radix;\n    this.numLength = numLength;\n    this.prefix = prefix;\n    this.suffix = suffix;\n    this.negative = negative;\n  }\n\n  public toString(): string {\n    // For decreased octal and hexadecimal\n    if (this.radix !== 10) {\n      const max = 0xffffffff;\n      while (this.value < 0) {\n        this.value = max + this.value + 1;\n      }\n    }\n\n    // Gen num part\n    const absValue = Math.abs(this.value);\n    let num = absValue.toString(this.radix);\n    // numLength of decimal *should not* be preserved.\n    if (this.radix !== 10) {\n      const diff = this.numLength - num.length;\n      if (diff > 0) {\n        // Preserve num length if it's narrower.\n        num = '0'.repeat(diff) + num;\n      }\n    }\n\n    const sign = this.negative || this.value < 0 ? '-' : '';\n    const core = sign + NumericString.numPrefix[this.radix] + num;\n    return this.prefix + core + this.suffix;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { TextEditor } from './../textEditor';\nimport { VimState } from '../state/vimState';\nimport { Range } from '../common/motion/range';\nimport { Position } from 'vscode';\n\n/**\n * Return open text documents, with a given file at the top of the list.\n * @param startingFileName File that will be first in the array, typically current file\n */\nconst documentsStartingWith = (startingFileName: string) => {\n  return vscode.workspace.textDocuments.sort((a, b) => {\n    if (a.fileName === startingFileName) {\n      return -1;\n    } else if (b.fileName === startingFileName) {\n      return 1;\n    }\n    return 0;\n  });\n};\n\n/**\n * Get lines, with leading tabs or whitespace stripped.\n * @param document Document to get lines from.\n * @param lineToStartScanFrom Where to start looking for matches first. Closest matches are sorted first.\n * @param scanAboveFirst Whether to start scan above or below cursor. Other direction is scanned last.\n * @returns\n */\nconst linesWithoutIndentation = (\n  document: vscode.TextDocument,\n  lineToStartScanFrom: number,\n  scanAboveFirst: boolean\n): Array<{ sortPriority: number; text: string }> => {\n  const distanceFromStartLine = (line: number) => {\n    let sortPriority = scanAboveFirst ? lineToStartScanFrom - line : line - lineToStartScanFrom;\n    if (sortPriority < 0) {\n      // We prioritized any items in the main direction searched,\n      // but now find closest items in opposite direction.\n      sortPriority = lineToStartScanFrom + Math.abs(sortPriority);\n    }\n\n    return sortPriority;\n  };\n\n  return document\n    .getText()\n    .split('\\n')\n    .map((text, line) => ({\n      sortPriority: distanceFromStartLine(line),\n      text: text.replace(/^[ \\t]*/, ''),\n    }))\n    .sort((a, b) => (a.sortPriority > b.sortPriority ? 1 : -1));\n};\n\n/**\n * Get all completions that match given text within open documents.\n * @example\n * a1\n * a2\n * a| // <--- Perform line completion here\n * a3\n * a4\n * // Returns: ['a2', 'a1', 'a3', 'a4']\n * @param text Text to partially match. Indentation is stripped.\n * @param currentFileName Current file, which is prioritized in sorting.\n * @param currentPosition Current position, which is prioritized when sorting for current file.\n */\nconst getCompletionsForText = (\n  text: string,\n  currentFileName: string,\n  currentPosition: Position\n): string[] | null => {\n  const matchedLines: string[] = [];\n\n  for (const document of documentsStartingWith(currentFileName)) {\n    let lineToStartScanFrom = 0;\n    let scanAboveFirst = false;\n\n    if (document.fileName === currentFileName) {\n      lineToStartScanFrom = currentPosition.line;\n      scanAboveFirst = true;\n    }\n\n    for (const line of linesWithoutIndentation(document, lineToStartScanFrom, scanAboveFirst)) {\n      if (\n        !matchedLines.includes(line.text) &&\n        line.text &&\n        line.text.startsWith(text) &&\n        line.text !== text\n      ) {\n        matchedLines.push(line.text);\n      }\n    }\n  }\n\n  return matchedLines;\n};\n\n/**\n * Get all completions that match given text within open documents.\n * Results are sorted in a few ways:\n * 1) The current document is prioritized over other open documents.\n * 2) For the current document, lines above the current cursor are always prioritized over lines below it.\n * 3) For the current document, lines are also prioritized based on distance from cursor.\n * 4) For other documents, lines are prioritized based on distance from the top.\n * @example\n * a1\n * a2\n * a| // <--- Perform line completion here\n * a3\n * a4\n * // Returns: ['a2', 'a1', 'a3', 'a4']\n * @param position Position to start scan from\n * @param document Document to start scanning from, starting at the position (other open documents are scanned from top)\n */\nexport const getCompletionsForCurrentLine = (\n  position: Position,\n  document: vscode.TextDocument\n): string[] | null => {\n  const currentLineText = document.getText(\n    new vscode.Range(TextEditor.getFirstNonWhitespaceCharOnLine(document, position.line), position)\n  );\n\n  return getCompletionsForText(currentLineText, document.fileName, position);\n};\n\nexport const lineCompletionProvider = {\n  /**\n   * Get all completions that match given text within open documents.\n   * Results are sorted by priority.\n   * @see getCompletionsForCurrentLine\n   *\n   * Any trailing characters are stripped. Trailing characters are often\n   * from auto-close, such as when importing in JavaScript ES6 and typing a\n   * curly brace. So the trailing characters are removed on purpose.\n   *\n   * Modifies vimState, adding transformations that replaces the\n   * current line's text with the chosen completion, with proper indentation.\n   *\n   * Here we use Quick Pick, instead of registerCompletionItemProvider\n   * Originally I looked at using a standard completion dropdown using that method,\n   * but it doesn't allow you to limit completions, and it became overwhelming\n   * when e.g. trying to do a line completion when the cursor is positioned after\n   * a space character (such that it shows almost any symbol in the list).\n   * Quick Pick also allows for searching, which is a nice bonus.\n   */\n  showLineCompletionsQuickPick: async (position: Position, vimState: VimState): Promise<void> => {\n    const completions = getCompletionsForCurrentLine(position, vimState.document);\n\n    if (!completions) {\n      return;\n    }\n\n    const selectedCompletion = await vscode.window.showQuickPick(completions);\n\n    if (!selectedCompletion) {\n      return;\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRange',\n      range: new Range(\n        TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line),\n        position.getLineEnd()\n      ),\n    });\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertTextVSCode',\n      text: selectedCompletion,\n    });\n  },\n};\n","import * as vscode from 'vscode';\nimport { Globals } from '../globals';\nimport { Notation } from './notation';\nimport { ValidatorResults } from './iconfigurationValidator';\nimport { VSCodeContext } from '../util/vscodeContext';\nimport { configurationValidator } from './configurationValidator';\nimport { decoration } from './decoration';\nimport * as process from 'process';\n\nimport {\n  IConfiguration,\n  IKeyRemapping,\n  IModeSpecificStrings,\n  IAutoSwitchInputMethod,\n  IDebugConfiguration,\n  IHighlightedYankConfiguration,\n  ICamelCaseMotionConfiguration,\n} from './iconfiguration';\n\nimport * as packagejson from '../../package.json';\nimport { SUPPORT_VIMRC } from 'platform/constants';\n\nexport const extensionVersion = packagejson.version;\n\n/**\n * Most options supported by Vim have a short alias. They are provided here.\n * Please keep this list up to date and sorted alphabetically.\n */\nexport const optionAliases: ReadonlyMap<string, string> = new Map<string, string>([\n  ['ai', 'autoindent'],\n  ['et', 'expandtab'],\n  ['gd', 'gdefault'],\n  ['hi', 'history'],\n  ['hls', 'hlsearch'],\n  ['ic', 'ignorecase'],\n  ['is', 'incsearch'],\n  ['isk', 'iskeyword'],\n  ['mmd', 'maxmapdepth'],\n  ['nu', 'number'],\n  ['rnu', 'relativenumber'],\n  ['sc', 'showcmd'],\n  ['scr', 'scroll'],\n  ['scs', 'smartcase'],\n  ['smd', 'showmode'],\n  ['sol', 'startofline'],\n  ['to', 'timeout'],\n  ['ts', 'tabstop'],\n  ['tw', 'textwidth'],\n  ['ws', 'wrapscan'],\n  ['ww', 'whichwrap'],\n]);\n\ntype OptionValue = number | string | boolean;\n\ninterface VSCodeKeybinding {\n  key: string;\n  mac?: string;\n  linux?: string;\n  command: string;\n  when: string;\n}\n\ninterface IHandleKeys {\n  [key: string]: boolean;\n}\n\ninterface IKeyBinding {\n  key: string;\n  command: string;\n}\n\n/**\n * Every Vim option we support should\n * 1. Be added to contribution section of `package.json`.\n * 2. Named as `vim.{optionName}`, `optionName` is the name we use in Vim.\n * 3. Define a public property in `Configuration` with the same name and a default value.\n *    Or define a private property and define customized Getter/Setter accessors for it.\n *    Always remember to decorate Getter accessor as @enumerable()\n * 4. If user doesn't set the option explicitly\n *    a. we don't have a similar setting in Code, initialize the option as default value.\n *    b. we have a similar setting in Code, use Code's setting.\n *\n * Vim option override sequence.\n * 1. `:set {option}` on the fly\n * 2. `vim.{option}`\n * 3. VS Code configuration\n * 4. VSCodeVim configuration default values\n *\n */\nclass Configuration implements IConfiguration {\n  private readonly leaderDefault = '\\\\';\n  private readonly cursorTypeMap = {\n    line: vscode.TextEditorCursorStyle.Line,\n    block: vscode.TextEditorCursorStyle.Block,\n    underline: vscode.TextEditorCursorStyle.Underline,\n    'line-thin': vscode.TextEditorCursorStyle.LineThin,\n    'block-outline': vscode.TextEditorCursorStyle.BlockOutline,\n    'underline-thin': vscode.TextEditorCursorStyle.UnderlineThin,\n  };\n\n  public async load(): Promise<ValidatorResults> {\n    const vimConfigs: any = Globals.isTesting\n      ? Globals.mockConfiguration\n      : this.getConfiguration('vim');\n\n    // tslint:disable-next-line: forin\n    for (const option in this) {\n      let val = vimConfigs[option];\n      if (val !== null && val !== undefined) {\n        if (val.constructor.name === Object.name) {\n          val = Configuration.unproxify(val);\n        }\n        this[option] = val;\n      }\n    }\n\n    if (SUPPORT_VIMRC && this.vimrc.enable) {\n      await import('./vimrc').then((vimrcModel) => {\n        return vimrcModel.vimrc.load(this);\n      });\n    }\n\n    this.leader = Notation.NormalizeKey(this.leader, this.leaderDefault);\n\n    this.clearKeyBindingsMaps();\n\n    const validatorResults = await configurationValidator.validate(configuration);\n\n    // read package.json for bound keys\n    // enable/disable certain key combinations\n    this.boundKeyCombinations = [];\n    for (const keybinding of packagejson.contributes.keybindings) {\n      if (keybinding.when.includes('listFocus')) {\n        continue;\n      }\n\n      if (keybinding.command.startsWith('notebook')) {\n        continue;\n      }\n\n      let key = keybinding.key;\n      if (process.platform === 'darwin') {\n        key = keybinding.mac || key;\n      } else if (process.platform === 'linux') {\n        key = keybinding.linux || key;\n      }\n\n      this.boundKeyCombinations.push({\n        key: Notation.NormalizeKey(key, this.leader),\n        command: keybinding.command,\n      });\n    }\n\n    // decorations\n    decoration.load(this);\n\n    for (const boundKey of this.boundKeyCombinations) {\n      // By default, all key combinations are used\n      let useKey = true;\n\n      const handleKey = this.handleKeys[boundKey.key];\n      if (handleKey !== undefined) {\n        // enabled/disabled through `vim.handleKeys`\n        useKey = handleKey;\n      } else if (!this.useCtrlKeys && boundKey.key.slice(1, 3) === 'C-') {\n        // user has disabled CtrlKeys and the current key is a CtrlKey\n        // <C-c>, still needs to be captured to overrideCopy\n        if (boundKey.key === '<C-c>' && this.overrideCopy) {\n          useKey = true;\n        } else {\n          useKey = false;\n        }\n      }\n\n      VSCodeContext.set(`vim.use${boundKey.key}`, useKey);\n    }\n\n    VSCodeContext.set('vim.overrideCopy', this.overrideCopy);\n    VSCodeContext.set('vim.overrideCtrlC', this.overrideCopy || this.useCtrlKeys);\n\n    return validatorResults;\n  }\n\n  getConfiguration(section: string = ''): vscode.WorkspaceConfiguration {\n    const document = vscode.window.activeTextEditor?.document;\n    const resource = document ? { uri: document.uri, languageId: document.languageId } : undefined;\n    return vscode.workspace.getConfiguration(section, resource);\n  }\n\n  cursorStyleFromString(cursorStyle: string): vscode.TextEditorCursorStyle | undefined {\n    return this.cursorTypeMap[cursorStyle];\n  }\n\n  clearKeyBindingsMaps() {\n    // Clear the KeyBindingsMaps so that the previous configuration maps don't leak to this one\n    this.normalModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.insertModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.visualModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.commandLineModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.operatorPendingModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n  }\n\n  handleKeys: IHandleKeys[] = [];\n\n  useSystemClipboard = false;\n\n  useCtrlKeys = false;\n\n  overrideCopy = true;\n\n  textwidth = 80;\n\n  hlsearch = false;\n\n  ignorecase = true;\n\n  smartcase = true;\n\n  autoindent = true;\n\n  camelCaseMotion: ICamelCaseMotionConfiguration = {\n    enable: true,\n  };\n\n  replaceWithRegister = false;\n\n  smartRelativeLine = false;\n\n  sneak = false;\n  sneakUseIgnorecaseAndSmartcase = false;\n  sneakReplacesF = false;\n\n  surround = true;\n\n  argumentObjectSeparators = [','];\n  argumentObjectOpeningDelimiters = ['(', '['];\n  argumentObjectClosingDelimiters = [')', ']'];\n\n  easymotion = false;\n  easymotionMarkerBackgroundColor = '#0000';\n  easymotionMarkerForegroundColorOneChar = '#ff0000';\n  easymotionMarkerForegroundColorTwoChar = '#ffa500'; // Deprecated! Use the ones bellow\n  easymotionMarkerForegroundColorTwoCharFirst = '#ffb400';\n  easymotionMarkerForegroundColorTwoCharSecond = '#b98300';\n  easymotionIncSearchForegroundColor = '#7fbf00';\n  easymotionDimColor = '#777777';\n  easymotionMarkerWidthPerChar = 8; // Deprecated! No longer needed!\n  easymotionDimBackground = true;\n  easymotionMarkerFontFamily = 'Consolas'; // Deprecated! No longer needed!\n  easymotionMarkerFontSize = '14'; // Deprecated! No longer needed!\n  easymotionMarkerFontWeight = 'bold';\n  easymotionMarkerMargin = 0; // Deprecated! No longer needed!\n  easymotionKeys = 'hklyuiopnm,qwertzxcvbasdgjf;';\n  easymotionJumpToAnywhereRegex = '\\\\b[A-Za-z0-9]|[A-Za-z0-9]\\\\b|_.|#.|[a-z][A-Z]';\n\n  autoSwitchInputMethod: IAutoSwitchInputMethod = {\n    enable: false,\n    defaultIM: '',\n    obtainIMCmd: '',\n    switchIMCmd: '',\n  };\n\n  timeout = 1000;\n\n  maxmapdepth = 1000;\n\n  showcmd = true;\n\n  showmodename = true;\n\n  leader = this.leaderDefault;\n\n  history = 50;\n\n  incsearch = true;\n\n  startInInsertMode = false;\n\n  statusBarColorControl = false;\n\n  statusBarColors: IModeSpecificStrings<string | string[]> = {\n    normal: '#005f5f',\n    insert: '#5f0000',\n    visual: '#5f00af',\n    visualline: '#005f87',\n    visualblock: '#86592d',\n    replace: '#000000',\n  };\n\n  debug: IDebugConfiguration = {\n    silent: false,\n    loggingLevelForAlert: 'error',\n    loggingLevelForConsole: 'error',\n  };\n\n  searchHighlightColor = '';\n  searchHighlightTextColor = '';\n\n  highlightedyank: IHighlightedYankConfiguration = {\n    enable: false,\n    color: 'rgba(250, 240, 170, 0.5)',\n    textColor: '',\n    duration: 200,\n  };\n\n  @overlapSetting({ settingName: 'tabSize', defaultValue: 8 })\n  tabstop: number;\n\n  @overlapSetting({ settingName: 'cursorStyle', defaultValue: 'line' })\n  private editorCursorStyleRaw: string;\n\n  get editorCursorStyle(): vscode.TextEditorCursorStyle | undefined {\n    return this.cursorStyleFromString(this.editorCursorStyleRaw);\n  }\n  set editorCursorStyle(val: vscode.TextEditorCursorStyle | undefined) {\n    // nop\n  }\n\n  @overlapSetting({ settingName: 'insertSpaces', defaultValue: false })\n  expandtab: boolean;\n\n  @overlapSetting({\n    settingName: 'lineNumbers',\n    defaultValue: true,\n    map: new Map([\n      ['on', true],\n      ['off', false],\n      ['relative', false],\n      ['interval', false],\n    ]),\n  })\n  number: boolean;\n\n  @overlapSetting({\n    settingName: 'lineNumbers',\n    defaultValue: false,\n    map: new Map([\n      ['on', false],\n      ['off', false],\n      ['relative', true],\n      ['interval', false],\n    ]),\n  })\n  relativenumber: boolean;\n\n  @overlapSetting({\n    settingName: 'wordSeparators',\n    defaultValue: '/\\\\()\"\\':,.;<>~!@#$%^&*|+=[]{}`?-',\n  })\n  iskeyword: string;\n\n  @overlapSetting({\n    settingName: 'wordWrap',\n    defaultValue: false,\n    map: new Map([\n      ['on', true],\n      ['off', false],\n      ['wordWrapColumn', true],\n      ['bounded', true],\n    ]),\n  })\n  wrap: boolean;\n\n  boundKeyCombinations: IKeyBinding[] = [];\n\n  visualstar = false;\n\n  mouseSelectionGoesIntoVisualMode = true;\n\n  changeWordIncludesWhitespace = false;\n\n  foldfix = false;\n\n  disableExtension: boolean = false;\n\n  enableNeovim = false;\n  neovimPath = '';\n  neovimUseConfigFile = false;\n  neovimConfigPath = '';\n\n  vimrc = {\n    enable: false,\n    path: '',\n  };\n\n  digraphs = {};\n\n  gdefault = false;\n  substituteGlobalFlag = false; // Deprecated in favor of gdefault\n\n  whichwrap = 'b,s';\n\n  startofline = true;\n\n  showMarksInGutter = false;\n\n  report = 2;\n  wrapscan = true;\n\n  scroll = 0;\n  getScrollLines(visibleRanges: vscode.Range[]): number {\n    return this.scroll === 0\n      ? Math.ceil((visibleRanges[0].end.line - visibleRanges[0].start.line) / 2)\n      : this.scroll;\n  }\n\n  cursorStylePerMode: IModeSpecificStrings<string> = {\n    normal: undefined,\n    insert: undefined,\n    visual: undefined,\n    visualline: undefined,\n    visualblock: undefined,\n    replace: undefined,\n  };\n\n  getCursorStyleForMode(modeName: string): vscode.TextEditorCursorStyle | undefined {\n    const cursorStyle = this.cursorStylePerMode[modeName.toLowerCase()];\n    if (cursorStyle) {\n      return this.cursorStyleFromString(cursorStyle);\n    }\n\n    return;\n  }\n\n  // remappings\n  insertModeKeyBindings: IKeyRemapping[] = [];\n  insertModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  normalModeKeyBindings: IKeyRemapping[] = [];\n  normalModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  operatorPendingModeKeyBindings: IKeyRemapping[] = [];\n  operatorPendingModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  visualModeKeyBindings: IKeyRemapping[] = [];\n  visualModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  commandLineModeKeyBindings: IKeyRemapping[] = [];\n  commandLineModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n\n  insertModeKeyBindingsMap: Map<string, IKeyRemapping>;\n  normalModeKeyBindingsMap: Map<string, IKeyRemapping>;\n  operatorPendingModeKeyBindingsMap: Map<string, IKeyRemapping>;\n  visualModeKeyBindingsMap: Map<string, IKeyRemapping>;\n  commandLineModeKeyBindingsMap: Map<string, IKeyRemapping>;\n\n  private static unproxify(obj: object): object {\n    const result = {};\n    // tslint:disable-next-line: forin\n    for (const key in obj) {\n      const val = obj[key] as any;\n      if (val !== null && val !== undefined) {\n        result[key] = val;\n      }\n    }\n    return result;\n  }\n}\n\n// handle mapped settings between vscode to vim\nfunction overlapSetting(args: {\n  settingName: string;\n  defaultValue: OptionValue;\n  map?: Map<string | number | boolean, string | number | boolean>;\n}) {\n  return (target: any, propertyKey: string) => {\n    Object.defineProperty(target, propertyKey, {\n      get() {\n        // retrieve value from vim configuration\n        // if the value is not defined or empty\n        // look at the equivalent `editor` setting\n        // if that is not defined then defer to the default value\n        let val = this['_' + propertyKey];\n        if (val !== undefined && val !== '') {\n          return val;\n        }\n\n        val = this.getConfiguration('editor').get(args.settingName, args.defaultValue);\n        if (args.map && val !== undefined) {\n          val = args.map.get(val);\n        }\n\n        return val;\n      },\n      set(value) {\n        // synchronize the vim setting with the `editor` equivalent\n        this['_' + propertyKey] = value;\n\n        if (value === undefined || value === '' || Globals.isTesting) {\n          return;\n        }\n\n        if (args.map) {\n          for (const [vscodeSetting, vimSetting] of args.map.entries()) {\n            if (value === vimSetting) {\n              value = vscodeSetting;\n              break;\n            }\n          }\n        }\n\n        // update configuration asynchronously\n        this.getConfiguration('editor').update(\n          args.settingName,\n          value,\n          vscode.ConfigurationTarget.Global\n        );\n      },\n      enumerable: true,\n      configurable: true,\n    });\n  };\n}\n\nexport const configuration = new Configuration();\n","import { IConfiguration } from './iconfiguration';\nimport { IConfigurationValidator, ValidatorResults } from './iconfigurationValidator';\n\nclass ConfigurationValidator {\n  private _validators: IConfigurationValidator[];\n\n  constructor() {\n    this._validators = [];\n  }\n\n  public registerValidator(validator: IConfigurationValidator) {\n    this._validators.push(validator);\n  }\n\n  public async validate(config: IConfiguration): Promise<ValidatorResults> {\n    const results = new ValidatorResults();\n\n    for (const validator of this._validators) {\n      const validatorResults = await validator.validate(config);\n      if (validatorResults.hasError) {\n        // errors found in configuration, disable feature\n        validator.disable(config);\n      }\n\n      results.concat(validatorResults);\n    }\n\n    return results;\n  }\n}\n\nexport const configurationValidator = new ConfigurationValidator();\n","import * as vscode from 'vscode';\nimport { IConfiguration } from './iconfiguration';\n\nclass DecorationImpl {\n  private _default: vscode.TextEditorDecorationType;\n  private _searchHighlight: vscode.TextEditorDecorationType;\n  private _easyMotionIncSearch: vscode.TextEditorDecorationType;\n  private _easyMotionDimIncSearch: vscode.TextEditorDecorationType;\n  private _insertModeVirtualCharacter: vscode.TextEditorDecorationType;\n  private _operatorPendingModeCursor: vscode.TextEditorDecorationType;\n  private _operatorPendingModeCursorChar: vscode.TextEditorDecorationType;\n\n  private _markDecorationCache = new Map<string, vscode.TextEditorDecorationType>();\n\n  private _createMarkDecoration(name: string): vscode.TextEditorDecorationType {\n    const svg = [\n      '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 30 30\" width=\"30px\" height=\"30px\">',\n      '<style>text { font-family: sans-serif; font-size: 0.8em; }</style>',\n      '<path fill=\"rgb(3,102,214)\" d=\"M23,27l-8-7l-8,7V5c0-1.105,0.895-2,2-2h12c1.105,0,2,0.895,2,2V27z\"/>',\n      `<text x=\"50%\" y=\"40%\" fill=\"rgb(200,200,200)\" text-anchor=\"middle\" dominant-baseline=\"middle\">${name}</text>`,\n      '</svg>',\n    ].join('');\n\n    const uri = vscode.Uri.parse(`data:image/svg+xml;utf8,${encodeURI(svg)}`, true);\n\n    return vscode.window.createTextEditorDecorationType({\n      isWholeLine: false,\n      gutterIconPath: uri,\n      gutterIconSize: 'cover',\n    });\n  }\n\n  public set default(value: vscode.TextEditorDecorationType) {\n    if (this._default) {\n      this._default.dispose();\n    }\n    this._default = value;\n  }\n\n  public get default() {\n    return this._default;\n  }\n\n  public set searchHighlight(value: vscode.TextEditorDecorationType) {\n    if (this._searchHighlight) {\n      this._searchHighlight.dispose();\n    }\n    this._searchHighlight = value;\n  }\n\n  public get searchHighlight() {\n    return this._searchHighlight;\n  }\n\n  public get easyMotionIncSearch() {\n    return this._easyMotionIncSearch;\n  }\n\n  public set easyMotionIncSearch(value: vscode.TextEditorDecorationType) {\n    if (this._easyMotionIncSearch) {\n      this._easyMotionIncSearch.dispose();\n    }\n    this._easyMotionIncSearch = value;\n  }\n\n  public get easyMotionDimIncSearch() {\n    return this._easyMotionDimIncSearch;\n  }\n\n  public set easyMotionDimIncSearch(value: vscode.TextEditorDecorationType) {\n    if (this._easyMotionDimIncSearch) {\n      this._easyMotionDimIncSearch.dispose();\n    }\n    this._easyMotionDimIncSearch = value;\n  }\n\n  public getOrCreateMarkDecoration(name: string): vscode.TextEditorDecorationType {\n    const decorationType = this.getMarkDecoration(name);\n\n    if (decorationType) {\n      return decorationType;\n    } else {\n      const type = this._createMarkDecoration(name);\n      this._markDecorationCache.set(name, type);\n      return type;\n    }\n  }\n\n  public getMarkDecoration(name: string): vscode.TextEditorDecorationType | undefined {\n    return this._markDecorationCache.get(name);\n  }\n\n  public allMarkDecorations(): IterableIterator<vscode.TextEditorDecorationType> {\n    return this._markDecorationCache.values();\n  }\n\n  public set insertModeVirtualCharacter(value: vscode.TextEditorDecorationType) {\n    if (this._insertModeVirtualCharacter) {\n      this._insertModeVirtualCharacter.dispose();\n    }\n    this._insertModeVirtualCharacter = value;\n  }\n\n  public get insertModeVirtualCharacter() {\n    return this._insertModeVirtualCharacter;\n  }\n\n  public set operatorPendingModeCursor(value: vscode.TextEditorDecorationType) {\n    if (this._operatorPendingModeCursor) {\n      this._operatorPendingModeCursor.dispose();\n    }\n    this._operatorPendingModeCursor = value;\n  }\n\n  public get operatorPendingModeCursor() {\n    return this._operatorPendingModeCursor;\n  }\n\n  public set operatorPendingModeCursorChar(value: vscode.TextEditorDecorationType) {\n    if (this._operatorPendingModeCursorChar) {\n      this._operatorPendingModeCursorChar.dispose();\n    }\n    this._operatorPendingModeCursorChar = value;\n  }\n\n  public get operatorPendingModeCursorChar() {\n    return this._operatorPendingModeCursorChar;\n  }\n\n  public load(configuration: IConfiguration) {\n    this.default = vscode.window.createTextEditorDecorationType({\n      backgroundColor: new vscode.ThemeColor('editorCursor.foreground'),\n      borderColor: new vscode.ThemeColor('editorCursor.foreground'),\n      dark: {\n        color: 'rgb(81,80,82)',\n      },\n      light: {\n        // used for light colored themes\n        color: 'rgb(255, 255, 255)',\n      },\n      borderStyle: 'solid',\n      borderWidth: '1px',\n    });\n\n    const searchHighlightColor = configuration.searchHighlightColor\n      ? configuration.searchHighlightColor\n      : new vscode.ThemeColor('editor.findMatchHighlightBackground');\n\n    this.searchHighlight = vscode.window.createTextEditorDecorationType({\n      backgroundColor: searchHighlightColor,\n      color: configuration.searchHighlightTextColor,\n      overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n    });\n\n    this.easyMotionIncSearch = vscode.window.createTextEditorDecorationType({\n      color: configuration.easymotionIncSearchForegroundColor,\n      fontWeight: configuration.easymotionMarkerFontWeight,\n    });\n\n    this.easyMotionDimIncSearch = vscode.window.createTextEditorDecorationType({\n      color: configuration.easymotionDimColor,\n    });\n\n    this.insertModeVirtualCharacter = vscode.window.createTextEditorDecorationType({\n      color: 'transparent', // no color to hide the existing character\n      before: {\n        color: 'currentColor',\n        backgroundColor: new vscode.ThemeColor('editor.background'),\n        borderColor: new vscode.ThemeColor('editor.background'),\n        margin: '0 -1ch 0 0',\n        height: '100%',\n      },\n    });\n\n    // This creates the half block cursor when on operator pending mode\n    this.operatorPendingModeCursor = vscode.window.createTextEditorDecorationType({\n      before: {\n        // no color to hide the existing character. We only need the character here to make\n        // the width be the same as the existing character.\n        color: 'transparent',\n        // The '-1ch' right margin is so that it displays on top of the existing character. The amount\n        // here doesn't really matter, it could be '-1px' it just needs to be negative so that the left\n        // of this 'before' element coincides with the left of the existing character.\n        margin: `0 -1ch 0 0;\n        position: absolute;\n        bottom: 0;\n        line-height: 0;`,\n        height: '50%',\n        backgroundColor: new vscode.ThemeColor('editorCursor.foreground'),\n      },\n    });\n\n    // This puts a character on top of the half block cursor and on top of the existing character\n    // to create the mix-blend 'magic'\n    this.operatorPendingModeCursorChar = vscode.window.createTextEditorDecorationType({\n      // We make the existing character 'black' -> rgb(0,0,0), because when using the mix-blend-mode\n      // with 'exclusion' it subtracts the darker color from the lightest color which means we will\n      // subtract zero from our 'currentcolor' leaving us with 'currentcolor' on the part above the\n      // background of the half cursor.\n      color: 'black',\n      before: {\n        color: 'currentcolor',\n        // The '-1ch' right margin is so that it displays on top of the existing character. The amount\n        // here doesn't really matter, it could be '-1px' it just needs to be negative so that the left\n        // of this 'before' element coincides with the left of the existing character.\n        margin: `0 -1ch 0 0;\n        position: absolute;\n        mix-blend-mode: exclusion;`,\n        height: '100%',\n      },\n    });\n  }\n}\n\nexport const decoration = new DecorationImpl();\n","import { IConfiguration } from './iconfiguration';\n\ninterface IValidatorResult {\n  level: 'error' | 'warning';\n  message: string;\n}\n\nexport class ValidatorResults {\n  errors = new Array<IValidatorResult>();\n\n  public append(validationResult: IValidatorResult) {\n    this.errors.push(validationResult);\n  }\n\n  public concat(validationResults: ValidatorResults) {\n    this.errors = this.errors.concat(validationResults.get());\n  }\n\n  public get(): ReadonlyArray<IValidatorResult> {\n    return this.errors;\n  }\n\n  public get numErrors(): number {\n    return this.errors.filter((e) => e.level === 'error').length;\n  }\n\n  public get hasError(): boolean {\n    return this.numErrors > 0;\n  }\n\n  public get numWarnings(): number {\n    return this.errors.filter((e) => e.level === 'warning').length;\n  }\n\n  public get hasWarning(): boolean {\n    return this.numWarnings > 0;\n  }\n}\n\nexport interface IConfigurationValidator {\n  validate(config: IConfiguration): Promise<ValidatorResults>;\n  disable(config: IConfiguration): void;\n}\n","export class Notation {\n  // Mapping from a regex to the normalized string that it should be converted to.\n  private static readonly _notationMap: ReadonlyArray<[RegExp, string]> = [\n    [/ctrl\\+|c\\-/gi, 'C-'],\n    [/cmd\\+|d\\-/gi, 'D-'],\n    [/shift\\+|s\\-/gi, 'S-'],\n    [/escape|esc/gi, 'Esc'],\n    [/backspace|bs/gi, 'BS'],\n    [/delete|del/gi, 'Del'],\n    [/home/gi, 'Home'],\n    [/end/gi, 'End'],\n    [/insert/gi, 'Insert'],\n    [/<space>/gi, ' '],\n    [/<cr>|<enter>|<return>/gi, '\\n'],\n  ];\n\n  private static shiftedLetterRegex = /<S-[a-zA-Z]>/;\n\n  /**\n   * Converts keystroke like <tab> to a single control character like \\t\n   */\n  public static ToControlCharacter(key: string) {\n    if (key === '<tab>') {\n      return '\\t';\n    }\n\n    return key;\n  }\n\n  public static IsControlKey(key: string): boolean {\n    key = key.toLocaleUpperCase();\n    return (\n      this.isSurroundedByAngleBrackets(key) && key !== '<BS>' && key !== '<S-BS>' && key !== '<TAB>'\n    );\n  }\n\n  /**\n   * Normalizes key to AngleBracketNotation\n   * (e.g. <ctrl+x>, Ctrl+x, <c-x> normalized to <C-x>)\n   * and converts the characters to their literals\n   * (e.g. <space>, <cr>, <leader>)\n   */\n  public static NormalizeKey(key: string, leaderKey: string): string {\n    if (typeof key !== 'string') {\n      return key;\n    }\n\n    if (key.length === 1) {\n      return key;\n    }\n\n    key = key.toLocaleLowerCase();\n\n    if (!this.isSurroundedByAngleBrackets(key)) {\n      key = `<${key}>`;\n    }\n\n    if (key === '<leader>') {\n      return leaderKey;\n    }\n\n    if (['<up>', '<down>', '<left>', '<right>'].includes(key)) {\n      return key;\n    }\n\n    for (const [regex, standardNotation] of this._notationMap) {\n      key = key.replace(regex, standardNotation);\n    }\n\n    if (this.shiftedLetterRegex.test(key)) {\n      key = key[3].toUpperCase();\n    }\n\n    return key;\n  }\n\n  /**\n   * Converts a key to a form which will look nice when logged, etc.\n   */\n  public static printableKey(key: string, leaderKey: string) {\n    const normalized = this.NormalizeKey(key, leaderKey);\n    return normalized === ' ' ? '<space>' : normalized === '\\n' ? '<enter>' : normalized;\n  }\n\n  private static isSurroundedByAngleBrackets(key: string): boolean {\n    return key.startsWith('<') && key.endsWith('>');\n  }\n}\n","import * as vscode from 'vscode';\nimport { IKeyRemapping } from './iconfiguration';\nimport { Logger } from '../util/logger';\nimport { ModeHandler } from '../mode/modeHandler';\nimport { Mode } from '../mode/mode';\nimport { commandLine } from '../cmd_line/commandLine';\nimport { configuration } from '../configuration/configuration';\nimport { StatusBar } from '../statusBar';\nimport { VimError, ErrorCode, ForceStopRemappingError } from '../error';\nimport { SpecialKeys } from '../util/specialKeys';\n\ninterface IRemapper {\n  /**\n   * Send keys to remapper\n   */\n  sendKey(keys: string[], modeHandler: ModeHandler): Promise<boolean>;\n\n  /**\n   * Given keys pressed thus far, denotes if it is a potential remap\n   */\n  readonly isPotentialRemap: boolean;\n}\n\nexport class Remappers implements IRemapper {\n  private readonly remappers = [\n    new InsertModeRemapper(),\n    new NormalModeRemapper(),\n    new VisualModeRemapper(),\n    new CommandLineModeRemapper(),\n    new OperatorPendingModeRemapper(),\n  ];\n\n  get isPotentialRemap(): boolean {\n    return this.remappers.some((r) => r.isPotentialRemap);\n  }\n\n  public async sendKey(keys: string[], modeHandler: ModeHandler): Promise<boolean> {\n    for (const remapper of this.remappers) {\n      if (await remapper.sendKey(keys, modeHandler)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport class Remapper implements IRemapper {\n  private readonly _configKey: string;\n  private readonly _remappedModes: Mode[];\n  private readonly _logger = Logger.get('Remapper');\n\n  /**\n   * Checks if the current commandList is a potential remap.\n   */\n  private _isPotentialRemap = false;\n\n  /**\n   * If the commandList has a remap but there is still another potential remap we\n   * call it an Ambiguous Remap and we store it here. If later we need to handle it\n   * we don't need to go looking for it.\n   */\n  private _hasAmbiguousRemap: IKeyRemapping | undefined;\n\n  /**\n   * If the commandList is a potential remap but has no ambiguous remap\n   * yet, we say that it has a Potential Remap.\n   *\n   * This is to distinguish the commands with ambiguous remaps and the\n   * ones without.\n   *\n   * Example 1: if 'aaaa' is mapped and so is 'aa', when the user has pressed\n   * 'aaa' we say it has an Ambiguous Remap which is 'aa', because if the\n   * user presses other key than 'a' next or waits for the timeout to finish\n   * we need to now that there was a remap to run so we first run the 'aa'\n   * remap and then handle the remaining keys.\n   *\n   * Example 2: if only 'aaaa' is mapped, when the user has pressed 'aaa'\n   * we say it has a Potential Remap, because if the user presses other key\n   * than 'a' next or waits for the timeout to finish we need to now that\n   * there was a potential remap that never came or was broken, so we can\n   * resend the keys again without allowing for a potential remap on the first\n   * key, which means we won't get to the same state because the first key\n   * will be handled as an action (in this case a 'CommandInsertAfterCursor')\n   */\n  private _hasPotentialRemap = false;\n\n  get isPotentialRemap(): boolean {\n    return this._isPotentialRemap;\n  }\n\n  constructor(configKey: string, remappedModes: Mode[]) {\n    this._configKey = configKey;\n    this._remappedModes = remappedModes;\n  }\n\n  public async sendKey(keys: string[], modeHandler: ModeHandler): Promise<boolean> {\n    const { vimState, remapState } = modeHandler;\n\n    this._isPotentialRemap = false;\n    const allowPotentialRemapOnFirstKey = vimState.recordedState.allowPotentialRemapOnFirstKey;\n    let remainingKeys: string[] = [];\n\n    /**\n     * Means that the timeout finished so we now can't allow the keys to be buffered again\n     * because the user already waited for timeout.\n     */\n    let allowBufferingKeys = true;\n\n    if (!this._remappedModes.includes(vimState.currentModeIncludingPseudoModes)) {\n      return false;\n    }\n\n    const userDefinedRemappings = configuration[this._configKey] as Map<string, IKeyRemapping>;\n\n    if (keys[keys.length - 1] === SpecialKeys.TimeoutFinished) {\n      // Timeout finished. Don't let an ambiguous or potential remap start another timeout again\n      keys = keys.slice(0, keys.length - 1);\n      allowBufferingKeys = false;\n    }\n\n    if (keys.length === 0) {\n      return true;\n    }\n\n    this._logger.debug(\n      `trying to find matching remap. keys=${keys}. mode=${\n        Mode[vimState.currentMode]\n      }. keybindings=${this._configKey}.`\n    );\n\n    let remapping: IKeyRemapping | undefined = this.findMatchingRemap(\n      userDefinedRemappings,\n      keys,\n      vimState.currentMode\n    );\n\n    // Check to see if a remapping could potentially be applied when more keys are received\n    let isPotentialRemap = Remapper.hasPotentialRemap(keys, userDefinedRemappings);\n\n    this._isPotentialRemap =\n      isPotentialRemap && allowBufferingKeys && allowPotentialRemapOnFirstKey;\n\n    /**\n     * Handle a broken potential or ambiguous remap\n     * 1. If this Remapper doesn't have a remapping AND\n     * 2. (It previously had an AmbiguousRemap OR a PotentialRemap) AND\n     * 3. (It doesn't have a potential remap anymore OR timeout finished) AND\n     * 4. keys length is more than 1\n     *\n     * Points 1-3: If we no longer have a remapping but previously had one or a potential one\n     * and there is no longer potential remappings because of another pressed key or because the\n     * timeout has passed we need to handle those situations by resending the keys or handling the\n     * ambiguous remap and resending any remaining keys.\n     * Point 4: if there is only one key there is no point in resending it without allowing remaps\n     * on first key, we can let the remapper go to the end because since either there was no potential\n     * remap anymore or the timeout finished so this means that the next two checks (the 'Buffer keys\n     * and create timeout' and 'Handle remapping and remaining keys') will never be hit, so it reaches\n     * the end without doing anything which means that this key will be handled as an action as intended.\n     */\n    if (\n      !remapping &&\n      (this._hasAmbiguousRemap || this._hasPotentialRemap) &&\n      (!isPotentialRemap || !allowBufferingKeys) &&\n      keys.length > 1\n    ) {\n      if (this._hasAmbiguousRemap) {\n        remapping = this._hasAmbiguousRemap;\n        isPotentialRemap = false;\n        this._isPotentialRemap = false;\n\n        // Use the commandList to get the remaining keys so that it includes any existing\n        // '<TimeoutFinished>' key\n        remainingKeys = vimState.recordedState.commandList.slice(remapping.before.length);\n        this._hasAmbiguousRemap = undefined;\n      }\n      if (!remapping) {\n        // if there is still no remapping, handle all the keys without allowing\n        // a potential remap on the first key so that we don't repeat everything\n        // again, but still allow for other ambiguous remaps after the first key.\n        //\n        // Example: if 'iiii' is mapped in normal and 'ii' is mapped in insert mode,\n        // and the user presses 'iiia' in normal mode or presses 'iii' and waits\n        // for the timeout to finish, we want the first 'i' to be handled without\n        // allowing potential remaps, which means it will go into insert mode,\n        // but then the next 'ii' should be remapped in insert mode and after the\n        // remap the 'a' should be handled.\n        if (!allowBufferingKeys) {\n          // Timeout finished and there is no remapping, so handle the buffered\n          // keys but resend the '<TimeoutFinished>' key as well so we don't wait\n          // for the timeout again but can still handle potential remaps.\n          //\n          // Example 1: if 'ccc' is mapped in normal mode and user presses 'cc' and\n          // waits for the timeout to finish, this will resend the 'cc<TimeoutFinished>'\n          // keys without allowing a potential remap on first key, which makes the\n          // first 'c' be handled as a 'ChangeOperator' and the second 'c' which has\n          // potential remaps (the 'ccc' remap) is buffered and the timeout started\n          // but then the '<TimeoutFinished>' key comes straight away that clears the\n          // timeout without waiting again, and makes the second 'c' be handled normally\n          // as another 'ChangeOperator'.\n          //\n          // Example 2: if 'iiii' is mapped in normal and 'ii' is mapped in insert\n          // mode, and the user presses 'iii' in normal mode and waits for the timeout\n          // to finish, this will resend the 'iii<TimeoutFinished>' keys without allowing\n          // a potential remap on first key, which makes the first 'i' be handled as\n          // an 'CommandInsertAtCursor' and goes to insert mode, next the second 'i'\n          // is buffered, then the third 'i' finds the insert mode remapping of 'ii'\n          // and handles that remap, after the remapping being handled the '<TimeoutFinished>'\n          // key comes that clears the timeout and since the commandList will be empty\n          // we return true as we finished handling this sequence of keys.\n\n          keys.push(SpecialKeys.TimeoutFinished); // include the '<TimeoutFinished>' key\n\n          this._logger.debug(\n            `${this._configKey}. timeout finished, handling timed out buffer keys without allowing a new timeout.`\n          );\n        }\n        this._logger.debug(\n          `${this._configKey}. potential remap broken. resending keys without allowing a potential remap on first key. keys=${keys}`\n        );\n        this._hasPotentialRemap = false;\n        vimState.recordedState.allowPotentialRemapOnFirstKey = false;\n        vimState.recordedState.resetCommandList();\n\n        if (remapState.wasPerformingRemapThatFinishedWaitingForTimeout) {\n          // Some keys that broke the possible remap were typed by the user so handle them seperatly\n          const lastRemapLength = remapState.wasPerformingRemapThatFinishedWaitingForTimeout.after!\n            .length;\n          const keysPressedByUser = keys.slice(lastRemapLength);\n          keys = keys.slice(0, lastRemapLength);\n\n          try {\n            remapState.isCurrentlyPerformingRecursiveRemapping = true;\n            await modeHandler.handleMultipleKeyEvents(keys);\n          } catch (e) {\n            if (e instanceof ForceStopRemappingError) {\n              this._logger.debug(\n                `${this._configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`\n              );\n            }\n          } finally {\n            remapState.isCurrentlyPerformingRecursiveRemapping = false;\n            remapState.wasPerformingRemapThatFinishedWaitingForTimeout = false;\n            await modeHandler.handleMultipleKeyEvents(keysPressedByUser);\n          }\n        } else {\n          await modeHandler.handleMultipleKeyEvents(keys);\n        }\n        return true;\n      }\n    }\n\n    /**\n     * Buffer keys and create timeout\n     * 1. If the current keys have a potential remap AND\n     * 2. The timeout hasn't finished yet so we allow buffering keys AND\n     * 3. We allow potential remap on first key (check the note on RecordedState. TLDR: this will only\n     * be false for one key, the first one, when we resend keys that had a potential remap but no longer\n     * have it or the timeout finished)\n     *\n     * Points 1-3: If the current keys still have a potential remap and the timeout hasn't finished yet\n     * and we are not preventing a potential remap on the first key then we need to buffer this keys\n     * and wait for another key or the timeout to finish.\n     */\n    if (isPotentialRemap && allowBufferingKeys && allowPotentialRemapOnFirstKey) {\n      if (remapping) {\n        // There are other potential remaps (ambiguous remaps), wait for other key or for the timeout\n        // to finish. Also store this current ambiguous remap on '_hasAmbiguousRemap' so that if later\n        // this ambiguous remap is broken or the user waits for timeout we don't need to go looking for\n        // it again.\n        this._hasAmbiguousRemap = remapping;\n\n        this._logger.debug(\n          `${this._configKey}. ambiguous match found. before=${remapping.before}. after=${remapping.after}. command=${remapping.commands}. waiting for other key or timeout to finish.`\n        );\n      } else {\n        this._hasPotentialRemap = true;\n        this._logger.debug(\n          `${this._configKey}. potential remap found. waiting for other key or timeout to finish.`\n        );\n      }\n\n      // Store BufferedKeys\n      vimState.recordedState.bufferedKeys = [...keys];\n\n      // Create Timeout\n      vimState.recordedState.bufferedKeysTimeoutObj = setTimeout(() => {\n        modeHandler.handleKeyEvent(SpecialKeys.TimeoutFinished);\n      }, configuration.timeout);\n      return true;\n    }\n\n    /**\n     * Handle Remapping and any remaining keys\n     * If we get here with a remapping that means we need to handle it.\n     */\n    if (remapping) {\n      if (!allowBufferingKeys) {\n        // If the user already waited for the timeout to finish, prevent the\n        // remapping from waiting for the timeout again by making a clone of\n        // remapping and change 'after' to send the '<TimeoutFinished>' key at\n        // the end.\n        const newRemapping = { ...remapping };\n        newRemapping.after = remapping.after?.slice(0);\n        newRemapping.after?.push(SpecialKeys.TimeoutFinished);\n        remapping = newRemapping;\n      }\n\n      this._hasAmbiguousRemap = undefined;\n      this._hasPotentialRemap = false;\n\n      let skipFirstCharacter = false;\n\n      // If we were performing a remapping already, it means this remapping has a parent remapping\n      const hasParentRemapping = remapState.isCurrentlyPerformingRemapping;\n      if (!hasParentRemapping) {\n        remapState.mapDepth = 0;\n      }\n\n      if (!remapping.recursive) {\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = true;\n      } else {\n        remapState.isCurrentlyPerformingRecursiveRemapping = true;\n\n        // As per the Vim documentation: (:help recursive)\n        // If the {rhs} starts with {lhs}, the first character is not mapped\n        // again (this is Vi compatible).\n        // For example:\n        // map ab abcd\n        // will execute the \"a\" command and insert \"bcd\" in the text. The \"ab\"\n        // in the {rhs} will not be mapped again.\n        if (remapping.after?.join('').startsWith(remapping.before.join(''))) {\n          skipFirstCharacter = true;\n        }\n      }\n\n      // Increase mapDepth\n      remapState.mapDepth++;\n\n      this._logger.debug(\n        `${this._configKey}. match found. before=${remapping.before}. after=${remapping.after}. command=${remapping.commands}. remainingKeys=${remainingKeys}. mapDepth=${remapState.mapDepth}.`\n      );\n\n      let remapFailed = false;\n\n      try {\n        // Check maxMapDepth\n        if (remapState.mapDepth >= configuration.maxmapdepth) {\n          const vimError = VimError.fromCode(ErrorCode.RecursiveMapping);\n          StatusBar.displayError(vimState, vimError);\n          throw ForceStopRemappingError.fromVimError(vimError);\n        }\n\n        // Hacky code incoming!!! If someone has a better way to do this please change it\n        if (remapState.mapDepth % 10 === 0) {\n          // Allow the user to press <C-c> or <Esc> key when inside an infinite looping remap.\n          // When inside an infinite looping recursive mapping it would block the editor until it reached\n          // the maxmapdepth. This 0ms wait allows the extension to handle any key typed by the user which\n          // means it allows the user to press <C-c> or <Esc> to force stop the looping remap.\n          // This shouldn't impact the normal use case because we're only running this every 10 nested\n          // remaps. Also when the logs are set to Error only, a looping recursive remap takes around 1.5s\n          // to reach 1000 mapDepth and give back control to the user, but when logs are set to debug it\n          // can take as long as 7 seconds.\n          const wait = (ms: number) => new Promise((res) => setTimeout(res, ms));\n          await wait(0);\n        }\n\n        remapState.remapUsedACharacter = false;\n\n        await this.handleRemapping(remapping, modeHandler, skipFirstCharacter);\n      } catch (e) {\n        if (e instanceof ForceStopRemappingError) {\n          // If a motion fails or a VimError happens during any kind of remapping or if the user presses the\n          // force stop remapping key (<C-c> or <Esc>) during a recursive remapping it should stop handling\n          // the remap and all its parent remaps if we are on a chain of recursive remaps.\n          // (Vim documentation :help map-error)\n          remapFailed = true;\n\n          // keep throwing until we reach the first parent\n          if (hasParentRemapping) {\n            throw e;\n          }\n\n          this._logger.debug(\n            `${this._configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`\n          );\n        } else {\n          // If some other error happens during the remapping handling it should stop the remap and rethrow\n          this._logger.debug(\n            `${this._configKey}. error found in the middle of remapping, ignoring the rest of the remap. error: ${e}`\n          );\n          throw e;\n        }\n      } finally {\n        // Check if we are still inside a recursive remap\n        if (!hasParentRemapping && remapState.isCurrentlyPerformingRecursiveRemapping) {\n          // no more recursive remappings being handled\n          if (vimState.recordedState.bufferedKeysTimeoutObj !== undefined) {\n            // In order to be able to receive other keys and at the same time wait for timeout, we need\n            // to create a timeout and return from the remapper so that modeHandler can be free to receive\n            // more keys. This means that if we are inside a recursive remapping, when we return on the\n            // last key of that remapping it will think that it is finished and set the currently\n            // performing recursive remapping flag to false, which would result in the current bufferedKeys\n            // not knowing they had a parent remapping. So we store that remapping here.\n            remapState.wasPerformingRemapThatFinishedWaitingForTimeout = { ...remapping };\n          }\n          remapState.isCurrentlyPerformingRecursiveRemapping = false;\n          remapState.forceStopRecursiveRemapping = false;\n        }\n\n        if (!hasParentRemapping) {\n          // Last remapping finished handling. Set undo step.\n          vimState.historyTracker.finishCurrentStep();\n        }\n\n        // NonRecursive remappings can't have nested remaps so after a finished remap we always set this to\n        // false, because either we were performing a non recursive remap and now we finish or we weren't\n        // performing a non recursive remapping and this was false anyway.\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = false;\n\n        // if there were other remaining keys on the buffered keys that weren't part of the remapping\n        // handle them now, except if the remap failed and the remaining keys weren't typed by the user.\n        // (we know that if this remapping has a parent remapping then the remaining keys weren't typed\n        // by the user, but instead were sent by the parent remapping handler)\n        if (remainingKeys.length > 0 && !(remapFailed && hasParentRemapping)) {\n          if (remapState.wasPerformingRemapThatFinishedWaitingForTimeout) {\n            // If there was a performing remap that finished waiting for timeout then only the remaining keys\n            // that are not part of that remap were typed by the user.\n            let specialKey: string | undefined = '';\n            if (remainingKeys[remainingKeys.length - 1] === SpecialKeys.TimeoutFinished) {\n              specialKey = remainingKeys.pop();\n            }\n            const lastRemap = remapState.wasPerformingRemapThatFinishedWaitingForTimeout.after!;\n            const lastRemapWithoutAmbiguousRemap = lastRemap.slice(remapping.before.length);\n            const keysPressedByUser = remainingKeys.slice(lastRemapWithoutAmbiguousRemap.length);\n            remainingKeys = remainingKeys.slice(0, remainingKeys.length - keysPressedByUser.length);\n            if (specialKey) {\n              remainingKeys.push(specialKey);\n              if (keysPressedByUser.length !== 0) {\n                keysPressedByUser.push(specialKey);\n              }\n            }\n            try {\n              remapState.isCurrentlyPerformingRecursiveRemapping = true;\n              await modeHandler.handleMultipleKeyEvents(remainingKeys);\n            } catch (e) {\n              this._logger.debug(\n                `${this._configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`\n              );\n            } finally {\n              remapState.isCurrentlyPerformingRecursiveRemapping = false;\n              remapState.wasPerformingRemapThatFinishedWaitingForTimeout = false;\n              if (keysPressedByUser.length > 0) {\n                await modeHandler.handleMultipleKeyEvents(keysPressedByUser);\n              }\n            }\n          } else {\n            await modeHandler.handleMultipleKeyEvents(remainingKeys);\n          }\n        }\n      }\n\n      return true;\n    }\n\n    this._hasPotentialRemap = false;\n    this._hasAmbiguousRemap = undefined;\n    return false;\n  }\n\n  private async handleRemapping(\n    remapping: IKeyRemapping,\n    modeHandler: ModeHandler,\n    skipFirstCharacter: boolean\n  ) {\n    const { vimState, remapState } = modeHandler;\n\n    vimState.recordedState.resetCommandList();\n    if (remapping.after) {\n      if (skipFirstCharacter) {\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = true;\n        await modeHandler.handleKeyEvent(remapping.after[0]);\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = false;\n        await modeHandler.handleMultipleKeyEvents(remapping.after.slice(1));\n      } else {\n        await modeHandler.handleMultipleKeyEvents(remapping.after);\n      }\n    }\n\n    if (remapping.commands) {\n      const count = vimState.recordedState.count || 1;\n      vimState.recordedState.count = 0;\n      for (let i = 0; i < count; i++) {\n        for (const command of remapping.commands) {\n          let commandString: string;\n          let commandArgs: string[];\n          if (typeof command === 'string') {\n            commandString = command;\n            commandArgs = [];\n          } else {\n            commandString = command.command;\n            commandArgs = command.args;\n          }\n\n          if (commandString.slice(0, 1) === ':') {\n            // Check if this is a vim command by looking for :\n            await commandLine.Run(\n              commandString.slice(1, commandString.length),\n              modeHandler.vimState\n            );\n            await modeHandler.updateView();\n          } else if (commandArgs) {\n            await vscode.commands.executeCommand(commandString, commandArgs);\n          } else {\n            await vscode.commands.executeCommand(commandString);\n          }\n\n          StatusBar.setText(vimState, `${commandString} ${commandArgs ?? ''}`);\n        }\n      }\n    }\n  }\n\n  protected findMatchingRemap(\n    userDefinedRemappings: Map<string, IKeyRemapping>,\n    inputtedKeys: string[],\n    currentMode: Mode\n  ): IKeyRemapping | undefined {\n    if (userDefinedRemappings.size === 0) {\n      return undefined;\n    }\n\n    const range = Remapper.getRemappedKeysLengthRange(userDefinedRemappings);\n    const startingSliceLength = inputtedKeys.length;\n    const inputtedString = inputtedKeys.join('');\n    for (let sliceLength = startingSliceLength; sliceLength >= range[0]; sliceLength--) {\n      const keySlice = inputtedKeys.slice(-sliceLength).join('');\n\n      this._logger.verbose(`key=${inputtedKeys}. keySlice=${keySlice}.`);\n      if (userDefinedRemappings.has(keySlice)) {\n        const precedingKeys = inputtedString.slice(0, inputtedString.length - keySlice.length);\n        if (precedingKeys.length > 0 && !/^[0-9]+$/.test(precedingKeys)) {\n          this._logger.verbose(\n            `key sequences need to match precisely. precedingKeys=${precedingKeys}.`\n          );\n          break;\n        }\n\n        return userDefinedRemappings.get(keySlice);\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Given list of remappings, returns the length of the shortest and longest remapped keys\n   * @param remappings\n   */\n  protected static getRemappedKeysLengthRange(\n    remappings: ReadonlyMap<string, IKeyRemapping>\n  ): [number, number] {\n    if (remappings.size === 0) {\n      return [0, 0];\n    }\n    const keyLengths = Array.from(remappings.values()).map((remap) => remap.before.length);\n    return [Math.min(...keyLengths), Math.max(...keyLengths)];\n  }\n\n  /**\n   * Given list of keys and list of remappings, returns true if the keys are a potential remap\n   * @param keys the list of keys to be checked for potential remaps\n   * @param remappings The remappings Map\n   * @param countRemapAsPotential If the current keys are themselves a remap should they be considered a potential remap as well?\n   */\n  protected static hasPotentialRemap(\n    keys: string[],\n    remappings: ReadonlyMap<string, IKeyRemapping>,\n    countRemapAsPotential: boolean = false\n  ): boolean {\n    const keysAsString = keys.join('');\n    const re = /^<([^>]+)>/;\n    if (keysAsString !== '') {\n      for (const remap of remappings.keys()) {\n        if (remap.startsWith(keysAsString) && (remap !== keysAsString || countRemapAsPotential)) {\n          // Don't confuse a key combination starting with '<' that is not a special key like '<C-a>'\n          // with a remap that starts with a special key.\n          if (keysAsString.startsWith('<') && !re.test(keysAsString) && re.test(remap)) {\n            continue;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\nfunction keyBindingsConfigKey(mode: string): string {\n  return `${mode}ModeKeyBindingsMap`;\n}\n\nclass InsertModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('insert'), [Mode.Insert, Mode.Replace]);\n  }\n}\n\nclass NormalModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('normal'), [Mode.Normal]);\n  }\n}\n\nclass OperatorPendingModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('operatorPending'), [Mode.OperatorPendingMode]);\n  }\n}\n\nclass VisualModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('visual'), [Mode.Visual, Mode.VisualLine, Mode.VisualBlock]);\n  }\n}\n\nclass CommandLineModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('commandLine'), [\n      Mode.CommandlineInProgress,\n      Mode.SearchInProgressMode,\n    ]);\n  }\n}\n","import { IConfigurationValidator, ValidatorResults } from '../iconfigurationValidator';\nimport { IConfiguration } from '../iconfiguration';\nimport { existsAsync } from 'platform/fs';\nimport { Globals } from '../../globals';\nimport { configurationValidator } from '../configurationValidator';\n\nexport class InputMethodSwitcherConfigurationValidator implements IConfigurationValidator {\n  async validate(config: IConfiguration): Promise<ValidatorResults> {\n    const result = new ValidatorResults();\n\n    const inputMethodConfig = config.autoSwitchInputMethod;\n\n    if (!inputMethodConfig.enable || Globals.isTesting) {\n      return Promise.resolve(result);\n    }\n\n    if (!inputMethodConfig.switchIMCmd.includes('{im}')) {\n      result.append({\n        level: 'error',\n        message:\n          'vim.autoSwitchInputMethod.switchIMCmd is incorrect, it should contain the placeholder {im}.',\n      });\n    }\n\n    if (inputMethodConfig.obtainIMCmd === undefined || inputMethodConfig.obtainIMCmd === '') {\n      result.append({\n        level: 'error',\n        message: 'vim.autoSwitchInputMethod.obtainIMCmd is empty.',\n      });\n    } else if (!(await existsAsync(this.getRawCmd(inputMethodConfig.obtainIMCmd)))) {\n      result.append({\n        level: 'error',\n        message: `Unable to find ${inputMethodConfig.obtainIMCmd}. Check your 'vim.autoSwitchInputMethod.obtainIMCmd' in VSCode setting.`,\n      });\n    }\n\n    if (inputMethodConfig.defaultIM === undefined || inputMethodConfig.defaultIM === '') {\n      result.append({\n        level: 'error',\n        message: 'vim.autoSwitchInputMethod.defaultIM is empty.',\n      });\n    } else if (!(await existsAsync(this.getRawCmd(inputMethodConfig.switchIMCmd)))) {\n      result.append({\n        level: 'error',\n        message: `Unable to find ${inputMethodConfig.switchIMCmd}. Check your 'vim.autoSwitchInputMethod.switchIMCmd' in VSCode setting.`,\n      });\n    }\n\n    return Promise.resolve(result);\n  }\n\n  disable(config: IConfiguration) {\n    config.autoSwitchInputMethod.enable = false;\n  }\n\n  private getRawCmd(cmd: string): string {\n    return cmd.split(' ')[0];\n  }\n}\n\nconfigurationValidator.registerValidator(new InputMethodSwitcherConfigurationValidator());\n","import * as vscode from 'vscode';\nimport { IConfiguration, IKeyRemapping } from '../iconfiguration';\nimport { Notation } from '../notation';\nimport { IConfigurationValidator, ValidatorResults } from '../iconfigurationValidator';\nimport { configurationValidator } from '../configurationValidator';\n\nexport class RemappingValidator implements IConfigurationValidator {\n  private _commandMap: Map<string, boolean>;\n\n  async validate(config: IConfiguration): Promise<ValidatorResults> {\n    const result = new ValidatorResults();\n    const modeKeyBindingsKeys = [\n      'insertModeKeyBindings',\n      'insertModeKeyBindingsNonRecursive',\n      'normalModeKeyBindings',\n      'normalModeKeyBindingsNonRecursive',\n      'operatorPendingModeKeyBindings',\n      'operatorPendingModeKeyBindingsNonRecursive',\n      'visualModeKeyBindings',\n      'visualModeKeyBindingsNonRecursive',\n      'commandLineModeKeyBindings',\n      'commandLineModeKeyBindingsNonRecursive',\n    ];\n    for (const modeKeyBindingsKey of modeKeyBindingsKeys) {\n      const keybindings = config[modeKeyBindingsKey];\n      const isRecursive = modeKeyBindingsKey.indexOf('NonRecursive') === -1;\n\n      const modeMapName = modeKeyBindingsKey.replace('NonRecursive', '');\n      let modeKeyBindingsMap = config[modeMapName + 'Map'] as Map<string, IKeyRemapping>;\n      if (!modeKeyBindingsMap) {\n        modeKeyBindingsMap = new Map<string, IKeyRemapping>();\n      }\n      for (let i = keybindings.length - 1; i >= 0; i--) {\n        const remapping = keybindings[i] as IKeyRemapping;\n\n        // set 'recursive' of the remapping according to where it was stored\n        remapping.recursive = isRecursive;\n\n        // validate\n        const remappingError = await this.isRemappingValid(remapping);\n        result.concat(remappingError);\n        if (remappingError.hasError) {\n          // errors with remapping, skip\n          keybindings.splice(i, 1);\n          continue;\n        }\n\n        // normalize\n        if (remapping.before) {\n          remapping.before.forEach(\n            (key, idx) => (remapping.before[idx] = Notation.NormalizeKey(key, config.leader))\n          );\n        }\n\n        if (remapping.after) {\n          remapping.after.forEach(\n            (key, idx) => (remapping.after![idx] = Notation.NormalizeKey(key, config.leader))\n          );\n        }\n\n        // check for duplicates\n        const beforeKeys = remapping.before.join('');\n        if (modeKeyBindingsMap.has(beforeKeys)) {\n          result.append({\n            level: 'warning',\n            message: `${remapping.before}. Duplicate remapped key for ${beforeKeys}.`,\n          });\n          continue;\n        }\n\n        // add to map\n        modeKeyBindingsMap.set(beforeKeys, remapping);\n      }\n\n      config[modeMapName + 'Map'] = modeKeyBindingsMap;\n    }\n\n    return result;\n  }\n\n  disable(config: IConfiguration) {\n    // no-op\n  }\n\n  private async isRemappingValid(remapping: IKeyRemapping): Promise<ValidatorResults> {\n    const result = new ValidatorResults();\n\n    if (!remapping.after && !remapping.commands) {\n      result.append({\n        level: 'error',\n        message: `${remapping.before} missing 'after' key or 'command'.`,\n      });\n    }\n\n    if (!(remapping.before instanceof Array)) {\n      result.append({\n        level: 'error',\n        message: `Remapping of '${remapping.before}' should be a string array.`,\n      });\n    }\n\n    if (remapping.recursive === undefined) {\n      result.append({\n        level: 'error',\n        message: `Remapping of '${remapping.before}' missing 'recursive' info.`,\n      });\n    }\n\n    if (remapping.after && !(remapping.after instanceof Array)) {\n      result.append({\n        level: 'error',\n        message: `Remapping of '${remapping.after}' should be a string array.`,\n      });\n    }\n\n    if (remapping.commands) {\n      for (const command of remapping.commands) {\n        let cmd: string;\n\n        if (typeof command === 'string') {\n          cmd = command;\n        } else if (command.command) {\n          cmd = command.command;\n\n          if (!(await this.isCommandValid(cmd))) {\n            result.append({ level: 'warning', message: `${cmd} does not exist.` });\n          }\n        } else {\n          result.append({\n            level: 'error',\n            message: `Remapping of '${remapping.before}' has wrong \"commands\" structure. Should be 'string[] | { \"command\": string, \"args\": any[] }[]'.`,\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private async isCommandValid(command: string): Promise<boolean> {\n    if (command.startsWith(':')) {\n      return true;\n    }\n\n    return (await this.getCommandMap()).has(command);\n  }\n\n  private async getCommandMap(): Promise<Map<string, boolean>> {\n    if (this._commandMap == null) {\n      this._commandMap = new Map(\n        (await vscode.commands.getCommands(true)).map((x) => [x, true] as [string, boolean])\n      );\n    }\n    return this._commandMap;\n  }\n}\n\nconfigurationValidator.registerValidator(new RemappingValidator());\n","import * as vscode from 'vscode';\n\n/**\n * We consider two editors to be the same iff their EditorIdentities are the same\n */\nexport class EditorIdentity {\n  public readonly fileName: string;\n\n  public static fromEditor(textEditor: vscode.TextEditor | undefined) {\n    return new EditorIdentity(textEditor?.document?.fileName ?? '');\n  }\n\n  public constructor(fileName: string) {\n    this.fileName = fileName;\n  }\n\n  public isEqual(other: EditorIdentity): boolean {\n    return this.fileName === other.fileName;\n  }\n\n  public toString() {\n    return this.fileName;\n  }\n}\n","interface IErrorMessage {\n  [index: number]: string;\n}\n\nexport enum ErrorCode {\n  MarkNotSet = 20,\n  NoAlternateFile = 23,\n  NoInsertedTextYet = 29,\n  NoFileName = 32,\n  NoPreviousCommand = 34,\n  NoPreviousRegularExpression = 35,\n  NoWriteSinceLastChange = 37,\n  ErrorWritingToFile = 208,\n  RecursiveMapping = 223,\n  NoStringUnderCursor = 348,\n  NothingInRegister = 353,\n  SearchHitTop = 384,\n  SearchHitBottom = 385,\n  CannotCloseLastWindow = 444,\n  ArgumentRequired = 471,\n  InvalidArgument = 474,\n  PatternNotFound = 486,\n  TrailingCharacters = 488,\n  NotAnEditorCommand = 492,\n  NoBuffersDeleted = 516,\n  UnknownOption = 518,\n}\n\nexport const ErrorMessage: IErrorMessage = {\n  20: 'Mark not set',\n  23: 'No alternate file',\n  29: 'No inserted text yet',\n  32: 'No file name',\n  34: 'No previous command',\n  35: 'No previous regular expression',\n  37: 'No write since last change (add ! to override)',\n  208: 'Error writing to file',\n  223: 'Recursive mapping',\n  348: 'No string under cursor',\n  353: 'Nothing in register', // TODO: this needs an extra value (\"Nothing in register x\")\n  384: 'Search hit TOP without match for',\n  385: 'Search hit BOTTOM without match for',\n  444: 'Cannot close last window',\n  471: 'Argument required',\n  474: 'Invalid argument',\n  486: 'Pattern not found',\n  488: 'Trailing characters',\n  492: 'Not an editor command',\n  516: 'No buffers were deleted',\n  518: 'Unknown option',\n};\n\nexport class VimError extends Error {\n  public readonly code: number;\n  public readonly message: string;\n\n  private constructor(code: number, message: string) {\n    super();\n    this.code = code;\n    this.message = message;\n  }\n\n  static fromCode(code: ErrorCode, extraValue?: string): VimError {\n    if (ErrorMessage[code]) {\n      return new VimError(code, ErrorMessage[code] + (extraValue ? `: ${extraValue}` : ''));\n    }\n\n    throw new Error('unknown error code: ' + code);\n  }\n\n  toString(): string {\n    return `E${this.code}: ${this.message}`;\n  }\n}\n\n/**\n * Used to stop a remapping or a chain of nested remappings after a VimError, a failed action\n * or the force stop recursive mapping key (<C-c> or <Esc>). (Vim doc :help map-error)\n */\nexport class ForceStopRemappingError extends Error {\n  constructor(reason: string = 'StopRemapping') {\n    super(reason);\n  }\n\n  static fromVimError(vimError: VimError): ForceStopRemappingError {\n    return new ForceStopRemappingError(vimError.toString());\n  }\n}\n","import { IConfiguration } from './configuration/iconfiguration';\nimport { ModeHandler } from './mode/modeHandler';\n\n/**\n * Global variables shared throughout extension\n */\nexport class Globals {\n  /**\n   * This is where we put files like HistoryFile. The path is given to us by VSCode.\n   */\n  static extensionStoragePath: string;\n\n  /**\n   * Used for testing.\n   */\n  static isTesting = false;\n  static mockModeHandler: ModeHandler;\n  static mockConfiguration: IConfiguration;\n}\n","import * as vscode from 'vscode';\nimport { Logger } from '../util/logger';\nimport { configuration } from '../configuration/configuration';\nimport { Globals } from '../globals';\nimport { HistoryBase } from 'platform/history';\n\nexport class HistoryFile {\n  private readonly _logger = Logger.get('HistoryFile');\n  private _base: HistoryBase;\n  private _history: string[] = [];\n\n  get historyFilePath(): string {\n    return this._base.historyKey;\n  }\n\n  constructor(context: vscode.ExtensionContext, historyFileName: string) {\n    this._base = new HistoryBase(\n      context,\n      historyFileName,\n      Globals.extensionStoragePath,\n      this._logger\n    );\n  }\n\n  public async add(value: string | undefined): Promise<void> {\n    return this._base.add(value, configuration.history);\n  }\n\n  public get(): string[] {\n    return this._base.get(configuration.history);\n  }\n\n  public clear() {\n    this._base.clear();\n  }\n\n  public async load(): Promise<void> {\n    await this._base.load();\n  }\n\n  private async save(): Promise<void> {\n    await this._base.save();\n  }\n}\n\nexport class SearchHistory extends HistoryFile {\n  constructor(context: vscode.ExtensionContext) {\n    super(context, '.search_history');\n  }\n}\n\nexport class CommandLineHistory extends HistoryFile {\n  constructor(context: vscode.ExtensionContext) {\n    super(context, '.cmdline_history');\n  }\n}\n","/**\n * HistoryTracker is a handrolled undo/redo tracker for VSC. We currently\n * track history as a list of \"steps\", each of which consists of 1 or more\n * \"changes\".\n *\n * A Change is something like adding or deleting a few letters.\n *\n * A Step is multiple Changes.\n *\n * Undo/Redo will advance forward or backwards through Steps.\n */\nimport DiffMatchPatch = require('diff-match-patch');\nimport * as vscode from 'vscode';\n\nimport { Logger } from './../util/logger';\nimport { VimState } from './../state/vimState';\nimport { TextEditor } from './../textEditor';\nimport { StatusBar } from '../statusBar';\nimport { Mode } from '../mode/mode';\nimport { Position } from 'vscode';\nimport { Jump } from '../jumps/jump';\nimport { globalState } from '../state/globalState';\n\nconst diffEngine = new DiffMatchPatch.diff_match_patch();\ndiffEngine.Diff_Timeout = 1; // 1 second\n\nclass DocumentChange {\n  public readonly start: Position;\n\n  /**\n   * true => addition\n   * false => deletion\n   */\n  // TODO: support replacement, which would cut the number of changes for :s/foo/bar in half\n  public isAdd: boolean;\n\n  private _end: Position | undefined;\n  private _text: string;\n\n  constructor(start: Position, text: string, isAdd: boolean) {\n    this.start = start;\n    this._text = text;\n    this.isAdd = isAdd;\n  }\n\n  /**\n   * Run this change.\n   */\n  public async do(editor: vscode.TextEditor, undo = false): Promise<void> {\n    if ((this.isAdd && !undo) || (!this.isAdd && undo)) {\n      await TextEditor.insert(editor, this.text, this.start, false);\n    } else {\n      await TextEditor.delete(editor, new vscode.Range(this.start, this.end));\n    }\n  }\n\n  /**\n   * Run this change in reverse.\n   */\n  public async undo(editor: vscode.TextEditor): Promise<void> {\n    return this.do(editor, true);\n  }\n\n  /**\n   * The position after advancing start by text\n   */\n  public get end(): Position {\n    if (this._end === undefined) {\n      this._end = this.start.advancePositionByText(this._text);\n    }\n    return this._end;\n  }\n\n  public get text(): string {\n    return this._text;\n  }\n\n  public set text(text: string) {\n    this._text = text;\n    this._end = undefined;\n  }\n}\n\nexport interface IMark {\n  name: string;\n  position: Position;\n  isUppercaseMark: boolean;\n  editor?: vscode.TextEditor; // only required when using global marks (isUppercaseMark is true)\n}\n\n/**\n * An undo's worth of changes; generally corresponds to a single action.\n */\nclass HistoryStep {\n  /**\n   * The insertions and deletions that occured in this history step.\n   */\n  changes: DocumentChange[];\n\n  /**\n   * Whether the user is still inserting or deleting for this history step.\n   */\n  isFinished: boolean;\n\n  /**\n   * When this step was finished.\n   * // TODO: we currently set it to the current time upon creation to cover some edge cases, but this is messy.\n   */\n  timestamp: Date;\n\n  /**\n   * The cursor position at the start of this history step.\n   */\n  cursorStart: Position[] | undefined;\n\n  /**\n   * The cursor position at the end of this history step so far.\n   */\n  cursorEnd: Position[] | undefined;\n\n  /**\n   * The position of every mark at the start of this history step.\n   */\n  marks: IMark[] = [];\n\n  /**\n   * \"global\" marks which operate across files. (when IMark.name is uppercase)\n   */\n  static globalMarks: IMark[] = [];\n\n  constructor(init: {\n    changes?: DocumentChange[];\n    isFinished?: boolean;\n    cursorStart?: Position[] | undefined;\n    cursorEnd?: Position[] | undefined;\n    marks?: IMark[];\n  }) {\n    // This is a bug, but fixing it causes regressions. See PR #2081.\n    this.changes = init.changes = [];\n    this.isFinished = init.isFinished || false;\n    this.cursorStart = init.cursorStart || undefined;\n    this.cursorEnd = init.cursorEnd || undefined;\n    this.marks = init.marks || [];\n\n    // This will usually be overwritten when the HistoryStep is finished\n    this.timestamp = new Date();\n  }\n\n  /**\n   * Collapse individual character changes into larger blocks of changes\n   */\n  public merge(): void {\n    if (this.changes.length < 2) {\n      return;\n    }\n\n    // merged will replace this.changes\n    const merged: DocumentChange[] = [];\n    // manually reduce() this.changes with variables `current` and `next`\n    // we can't use reduce() directly because the loop can emit multiple elements\n    let current = this.changes[0];\n    for (const next of this.changes.slice(1)) {\n      if (current.text.length === 0) {\n        // current is eliminated, replace it with top of merged, or adopt next as current\n        // see also add+del case\n        if (merged.length > 0) {\n          current = merged.pop()!;\n        } else {\n          current = next;\n          continue;\n        }\n      }\n      // merge logic. also compares start & end Positions to ensure this is the same location\n      if (current.isAdd && next.isAdd && current.end.isEqual(next.start)) {\n        // merge add+add together\n        current.text += next.text;\n      } else if (!current.isAdd && !next.isAdd && next.end.isEqual(current.start)) {\n        // merge del+del together, but in reverse so it still reads forward\n        next.text += current.text;\n        current = next;\n      } else if (current.isAdd && !next.isAdd && current.end.isEqual(next.end)) {\n        // collapse add+del into add. this might make current.text.length === 0, see beginning of loop\n        current.text = current.text.slice(0, -next.text.length);\n      } else {\n        // del+add must be two separate DocumentChanges. e.g. start with \"a|b\", do `i<BS>x<Esc>` you end up with \"|xb\"\n        // also handles multiple changes in distant locations in the document\n        merged.push(current);\n        current = next;\n      }\n    }\n    merged.push(current);\n    this.changes = merged;\n  }\n\n  /**\n   * Returns, as a string, the time that has passed since this step took place.\n   */\n  public howLongAgo(): string {\n    const now = new Date();\n    const timeDiffMillis = now.getTime() - this.timestamp.getTime();\n    const timeDiffSeconds = Math.floor(timeDiffMillis / 1000);\n    if (timeDiffSeconds === 1) {\n      return `1 second ago`;\n    } else if (timeDiffSeconds >= 100) {\n      const hours = this.timestamp.getHours();\n      const minutes = this.timestamp.getMinutes().toString().padStart(2, '0');\n      const seconds = this.timestamp.getSeconds().toString().padStart(2, '0');\n      return `${hours}:${minutes}:${seconds}`;\n    } else {\n      return `${timeDiffSeconds} seconds ago`;\n    }\n  }\n}\n\n/**\n * A simple wrapper around a list of HistorySteps, for sanity's sake\n */\nclass UndoStack {\n  private historySteps: HistoryStep[] = [];\n  private currentStepIndex = -1;\n\n  // The marks as they existed before the first HistoryStep\n  private initialMarks: IMark[] = [];\n\n  public getHistoryStepAtIndex(idx: number): HistoryStep | undefined {\n    return this.historySteps[idx];\n  }\n\n  public getCurrentHistoryStepIndex(): number {\n    return this.currentStepIndex;\n  }\n\n  public getStackDepth(): number {\n    return this.historySteps.length;\n  }\n\n  /**\n   * @returns the current HistoryStep, or undefined if nothing's been done yet\n   */\n  public getCurrentHistoryStep(): HistoryStep | undefined {\n    if (this.currentStepIndex === -1) {\n      return undefined;\n    }\n\n    return this.historySteps[this.currentStepIndex];\n  }\n\n  /**\n   * Goes forward in time (redo), if possible\n   *\n   * @returns the new current HistoryStep, or undefined if none exists\n   */\n  public stepForward(): HistoryStep | undefined {\n    if (this.currentStepIndex === this.historySteps.length - 1) {\n      return undefined;\n    }\n\n    this.currentStepIndex++;\n    return this.getCurrentHistoryStep();\n  }\n\n  /**\n   * Goes forward in time (redo), if possible\n   *\n   * @returns the old HistoryStep, or undefined if there was none\n   */\n  public stepBackward(): HistoryStep | undefined {\n    const step = this.getCurrentHistoryStep();\n    if (step) {\n      this.currentStepIndex--;\n    }\n    return step;\n  }\n\n  /**\n   * Adds a change to the current unfinished step if there is one, or a new step if there isn't\n   */\n  public pushChange(change: DocumentChange): void {\n    let step = this.getCurrentHistoryStep();\n    if (step === undefined || step.isFinished) {\n      this.currentStepIndex++;\n      this.historySteps.splice(this.currentStepIndex);\n      step = new HistoryStep({\n        marks: step?.marks ?? this.initialMarks,\n      });\n      this.historySteps.push(step);\n    }\n\n    step.changes.push(change);\n  }\n\n  /**\n   * You probably don't want to use this.\n   * @see pushChange\n   */\n  public pushHistoryStep(step: HistoryStep) {\n    this.currentStepIndex++;\n    this.historySteps.splice(this.currentStepIndex + 1);\n    this.historySteps.push(step);\n  }\n\n  public getCurrentMarkList(): IMark[] {\n    const step = this.getCurrentHistoryStep();\n    return step?.marks ?? this.initialMarks;\n  }\n\n  public removeMarks(marks?: string[]): void {\n    const step = this.getCurrentHistoryStep();\n    if (marks === undefined) {\n      if (step) {\n        step.marks = [];\n      } else {\n        this.initialMarks = [];\n      }\n    } else {\n      if (step) {\n        step.marks = step.marks.filter((m) => !marks.includes(m.name));\n      } else {\n        this.initialMarks = this.initialMarks.filter((m) => !marks.includes(m.name));\n      }\n    }\n  }\n}\n\nexport class HistoryTracker {\n  private static readonly logger = Logger.get('DocumentChange');\n  public lastContentChanges: vscode.TextDocumentContentChangeEvent[];\n  public currentContentChanges: vscode.TextDocumentContentChangeEvent[];\n\n  // Current index in changelist for navigation, resets when a new change is made\n  public changelistIndex = 0;\n\n  private undoStack: UndoStack;\n\n  /**\n   * The state of the document the last time HistoryTracker.addChange() or HistoryTracker.ignoreChange() was called.\n   * This is used to avoid retrieiving the document text and doing a full diff when it isn't necessary.\n   */\n  private previousDocumentState: {\n    text: string;\n    versionNumber: number;\n  };\n\n  private readonly vimState: VimState;\n\n  private currentMode: Mode;\n\n  constructor(vimState: VimState) {\n    this.vimState = vimState;\n    // TODO: we should initialize currentMode here, right?\n    this.undoStack = new UndoStack();\n    this.previousDocumentState = {\n      text: this._getDocumentText(),\n      versionNumber: this._getDocumentVersion(),\n    };\n    this.lastContentChanges = [];\n    this.currentContentChanges = [];\n  }\n\n  private _getDocumentText(): string {\n    // vimState.editor can be undefined in some unit tests\n    return this.vimState.editor?.document.getText() ?? '';\n  }\n\n  private _getDocumentVersion(): number {\n    // vimState.editor can be undefined in some unit tests\n    return this.vimState.editor?.document.version ?? -1;\n  }\n\n  /**\n   * Marks refer to relative locations in the document, rather than absolute ones.\n   *\n   * This big gnarly method updates our marks such that they continue to mark\n   * the same character when the user does a document edit that would move the\n   * text that was marked.\n   */\n  private updateAndReturnMarks(): IMark[] {\n    const previousMarks = this.getAllCurrentDocumentMarks();\n    const newMarks: IMark[] = [];\n\n    // clone old marks into new marks\n    for (const mark of previousMarks) {\n      newMarks.push({ ...mark });\n    }\n\n    for (const change of this.undoStack.getCurrentHistoryStep()?.changes ?? []) {\n      for (const newMark of newMarks) {\n        // Run through each character added/deleted, and see if it could have\n        // affected the position of this mark.\n\n        let pos: Position = change.start;\n\n        if (change.isAdd) {\n          // (Yes, I could merge these together, but that would obfusciate the logic.)\n\n          for (const ch of change.text) {\n            // Update mark\n\n            if (pos.isBeforeOrEqual(newMark.position)) {\n              if (ch === '\\n') {\n                newMark.position = new Position(\n                  newMark.position.line + 1,\n                  newMark.position.character\n                );\n              } else if (ch !== '\\n' && pos.line === newMark.position.line) {\n                newMark.position = new Position(\n                  newMark.position.line,\n                  newMark.position.character + 1\n                );\n              }\n            }\n\n            // Advance position\n\n            if (ch === '\\n') {\n              pos = new Position(pos.line + 1, 0);\n            } else {\n              pos = new Position(pos.line, pos.character + 1);\n            }\n          }\n        } else {\n          for (const ch of change.text) {\n            // Update mark\n\n            if (pos.isBefore(newMark.position)) {\n              if (ch === '\\n') {\n                newMark.position = new Position(\n                  Math.max(newMark.position.line - 1, 0),\n                  newMark.position.character\n                );\n              } else if (pos.line === newMark.position.line) {\n                newMark.position = new Position(\n                  newMark.position.line,\n                  Math.max(newMark.position.character - 1, 0)\n                );\n              }\n            }\n\n            // De-advance position\n            // (What's the opposite of advance? Retreat position?)\n\n            if (ch === '\\n') {\n              // The 99999 is a bit of a hack here. It's very difficult and\n              // completely unnecessary to get the correct position, so we\n              // just fake it.\n              pos = new Position(Math.max(pos.line - 1, 0), 99999);\n            } else {\n              pos = new Position(pos.line, Math.max(pos.character - 1, 0));\n            }\n          }\n        }\n      }\n    }\n\n    // Ensure the position of every mark is within the range of the document.\n\n    const docEnd = TextEditor.getDocumentEnd(this.vimState.document);\n    for (const mark of newMarks) {\n      if (mark.position.isAfter(docEnd)) {\n        mark.position = docEnd;\n      }\n    }\n\n    return newMarks;\n  }\n\n  /**\n   * Returns the shared static list if isFileMark is true,\n   * otherwise returns the currentHistoryStep.marks.\n   */\n  private getMarkList(isFileMark: boolean): IMark[] {\n    return isFileMark ? HistoryStep.globalMarks : this.undoStack.getCurrentMarkList();\n  }\n\n  /**\n   * @returns all local and global marks in this editor\n   */\n  private getAllCurrentDocumentMarks(): IMark[] {\n    const globalMarks = HistoryStep.globalMarks.filter(\n      (mark) => mark.editor === vscode.window.activeTextEditor\n    );\n    return [...this.getLocalMarks(), ...globalMarks];\n  }\n\n  /**\n   * Adds a mark.\n   */\n  public addMark(position: Position, markName: string): void {\n    // Sets previous context mark (adds current position to jump list).\n\n    if (markName === \"'\" || markName === '`') {\n      return globalState.jumpTracker.recordJump(Jump.fromStateNow(this.vimState));\n    }\n\n    const isUppercaseMark = markName.toUpperCase() === markName;\n    const newMark: IMark = {\n      position,\n      name: markName,\n      isUppercaseMark,\n      editor: isUppercaseMark ? vscode.window.activeTextEditor : undefined,\n    };\n    this.putMarkInList(newMark);\n  }\n\n  /**\n   * Puts the mark into either the global or local marks array depending on\n   * mark.isUppercaseMark.\n   */\n  private putMarkInList(mark: IMark): void {\n    const marks = this.getMarkList(mark.isUppercaseMark);\n    const previousIndex = marks.findIndex((existingMark) => existingMark.name === mark.name);\n    if (previousIndex !== -1) {\n      marks[previousIndex] = mark;\n    } else {\n      marks.push(mark);\n    }\n  }\n\n  /**\n   * Retrieves a mark from either the global or local array depending on\n   * mark.isUppercaseMark.\n   */\n  public getMark(markName: string): IMark | undefined {\n    const marks = this.getMarkList(markName.toUpperCase() === markName);\n    return marks.find((mark) => mark.name === markName);\n  }\n\n  /**\n   * Removes all local marks.\n   */\n  public removeLocalMarks(): void {\n    this.undoStack.removeMarks();\n  }\n\n  /**\n   * Removes all marks matching from either the global or local array.\n   */\n  public removeMarks(markNames: string[]): void {\n    if (markNames.length === 0) {\n      return;\n    }\n\n    this.undoStack.removeMarks(markNames);\n\n    HistoryStep.globalMarks = HistoryStep.globalMarks.filter(\n      (mark) => mark.name === '' || !markNames.includes(mark.name)\n    );\n  }\n\n  /**\n   * Gets all local marks.  I.e., marks that are specific for the current\n   * editor.\n   */\n  public getLocalMarks(): IMark[] {\n    return [...this.undoStack.getCurrentMarkList()];\n  }\n\n  /**\n   * Gets all global marks.  I.e., marks that are shared among all editors.\n   */\n  public getGlobalMarks(): IMark[] {\n    return [...HistoryStep.globalMarks];\n  }\n\n  public getMarks(): IMark[] {\n    return [...this.getLocalMarks(), ...HistoryStep.globalMarks];\n  }\n\n  /**\n   * Adds an individual Change to the current Step.\n   *\n   * Determines what changed by diffing the document against what it used to look like.\n   */\n  public addChange(cursorPosition = [new Position(0, 0)]): void {\n    if (this._getDocumentVersion() === this.previousDocumentState.versionNumber) {\n      return;\n    }\n\n    const newText = this._getDocumentText();\n    if (newText === this.previousDocumentState.text) {\n      return;\n    }\n\n    // TODO: This is actually pretty stupid! Since we already have the cursorPosition,\n    // and most diffs are just +/- a few characters, we can just do a direct comparison rather\n    // than using jsdiff.\n\n    // The difficulty is with a few rare commands like :%s/one/two/g that make\n    // multiple changes in different places simultaneously. For those, we could require\n    // them to call addChange manually, I guess...\n\n    const diffs = diffEngine.diff_main(this.previousDocumentState.text, newText);\n    diffEngine.diff_cleanupEfficiency(diffs);\n\n    let currentPosition = new Position(0, 0);\n\n    for (const diff of diffs) {\n      const [whatHappened, text] = diff;\n      const added = whatHappened === DiffMatchPatch.DIFF_INSERT;\n      const removed = whatHappened === DiffMatchPatch.DIFF_DELETE;\n\n      let change: DocumentChange;\n\n      if (added || removed) {\n        change = new DocumentChange(currentPosition, text, !!added);\n\n        this.undoStack.pushChange(change);\n\n        this.undoStack.getCurrentHistoryStep()!.cursorStart ??= cursorPosition;\n      }\n\n      if (!removed) {\n        currentPosition = currentPosition.advancePositionByText(text);\n      }\n    }\n\n    this.undoStack.getCurrentHistoryStep()!.cursorEnd = cursorPosition;\n    this.previousDocumentState = {\n      text: newText,\n      versionNumber: this._getDocumentVersion(),\n    };\n\n    // A change has been made, reset the changelist navigation index to the end\n    this.changelistIndex = this.undoStack.getStackDepth() - 1;\n  }\n\n  /**\n   * Both undoes and completely removes the last n changes applied.\n   */\n  public async undoAndRemoveChanges(n: number): Promise<void> {\n    if (this.currentContentChanges.length < n) {\n      HistoryTracker.logger.warn('Something bad happened in removeChange');\n      return;\n    } else if (n === 0) {\n      return;\n    }\n\n    // Remove the last N elements from the currentContentChanges array.\n    const removedChanges = this.currentContentChanges.splice(\n      this.currentContentChanges.length - n,\n      this.currentContentChanges.length\n    );\n\n    // Remove the characters from the editor in reverse order otherwise the characters\n    // position would change.\n    await vscode.window.activeTextEditor?.edit((edit) => {\n      for (const removedChange of removedChanges.reverse()) {\n        edit.delete(\n          new vscode.Range(\n            removedChange.range.start,\n            removedChange.range.end.translate({ characterDelta: 1 })\n          )\n        );\n      }\n    });\n\n    // Remove the previous deletions from currentContentChanges otherwise the DotCommand\n    // or a recorded macro will be deleting a character that wasn't typed.\n    this.currentContentChanges.splice(\n      this.currentContentChanges.length - removedChanges.length,\n      removedChanges.length\n    );\n\n    // We can't ignore the change, because that would mean that addChange() doesn't run.\n    // In the event of \"jj\" -> <Esc> remap, that would mean that the second part of the modification\n    // does not get added to currentHistoryStep.changes (only the first character).\n    // This messes with the undo stack, i.e. if we were to call Undo, only that first character would be erased.\n\n    // this.ignoreChange();\n  }\n\n  /**\n   * Tells the HistoryTracker that although the document has changed, we should simply\n   * ignore that change. Most often used when the change was itself triggered by\n   * the HistoryTracker.\n   */\n  public ignoreChange(): void {\n    this.previousDocumentState = {\n      text: this._getDocumentText(),\n      versionNumber: this._getDocumentVersion(),\n    };\n  }\n\n  /**\n   * Until we mark it as finished, the active Step will\n   * accrue multiple changes. This function will mark it as finished,\n   * and the next time we add a change, it'll be added to a new Step.\n   */\n  public finishCurrentStep(): void {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep && !currentHistoryStep.isFinished) {\n      currentHistoryStep.isFinished = true;\n      currentHistoryStep.timestamp = new Date();\n\n      currentHistoryStep.merge();\n\n      currentHistoryStep.marks = this.updateAndReturnMarks();\n    }\n  }\n\n  /**\n   * Undo the current HistoryStep, if there is one\n   *\n   * @returns the new cursor positions, or undefined if there are no steps to undo\n   */\n  public async goBackHistoryStep(): Promise<Position[] | undefined> {\n    const step = this.undoStack.stepBackward();\n    if (step === undefined) {\n      return undefined;\n    }\n\n    for (const change of step.changes.slice(0).reverse()) {\n      await change.undo(this.vimState.editor);\n    }\n\n    // TODO: if there are more/fewer lines after undoing the change, it should say so\n    const changes = step.changes.length === 1 ? `1 change` : `${step.changes.length} changes`;\n    StatusBar.setText(\n      this.vimState,\n      `${changes}; before #${this.undoStack.getCurrentHistoryStepIndex() + 1}  ${step.howLongAgo()}`\n    );\n\n    return step.cursorStart;\n  }\n\n  /**\n   * Logic for command U.\n   *\n   * Performs an undo action for all changes which occurred on\n   * the same line as the most recent change.\n   * Returns undefined if there's no more steps back to go.\n   * Only acts upon consecutive changes on the most-recently-changed line.\n   * U itself is a change, so all the changes are reversed and added back\n   * to the history.\n   *\n   * This method contains a significant amount of extra logic to account for\n   * the difficult scenario where a newline is embedded in a change (ex: '\\nhello'), which\n   * is created by the 'o' command. Vim behavior for the 'U' command does\n   * not undo newlines, so the change text needs to be checked & trimmed.\n   * This worst-case scenario tends to offset line values and make it harder to\n   * determine the line of the change, so this behavior is also compensated.\n   */\n  public async goBackHistoryStepsOnLine(): Promise<Position[] | undefined> {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    let done: boolean = false;\n    let stepsToUndo: number = 0;\n    const changesToUndo: DocumentChange[] = [];\n\n    const changes = currentHistoryStep.changes;\n\n    let lastChange = changes[0];\n    let currentLine = changes[changes.length - 1].start.line;\n\n    // Adjusting for the case where the most recent change is newline followed by text\n    const mostRecentText = changes[0].text;\n    if (mostRecentText.includes('\\n') && mostRecentText !== '\\n' && mostRecentText !== '\\r\\n') {\n      currentLine++;\n    }\n\n    for (let stepIdx = this.undoStack.getCurrentHistoryStepIndex(); stepIdx >= 0; stepIdx--) {\n      const step = this.undoStack.getHistoryStepAtIndex(stepIdx);\n      for (let change of step!.changes.reverse()) {\n        /*\n         * This conditional accounts for the behavior where the change is a newline\n         * followed by text to undo. Note the line offset behavior that must be compensated.\n         */\n        if (change.text.includes('\\n') && change.start.line + 1 === currentLine) {\n          done = true;\n          // Modify & replace the change to avoid undoing the newline embedded in the change\n          change = new DocumentChange(\n            new Position(change.start.line + 1, 0),\n            change.text.replace('\\n', '').replace('\\r', ''),\n            change.isAdd\n          );\n          stepsToUndo++;\n        }\n\n        if (change.text.includes('\\n') || change.start.line !== currentLine) {\n          done = true;\n          break;\n        }\n\n        changesToUndo.push(change);\n        lastChange = change;\n        if (done) {\n          break;\n        }\n      }\n      if (done) {\n        break;\n      }\n      stepsToUndo++;\n    }\n\n    // Note that reverse() is call-by-reference, so the changes are already in reverse order\n    for (const change of changesToUndo) {\n      await change.undo(this.vimState.editor);\n      change.isAdd = !change.isAdd;\n    }\n\n    for (let count = stepsToUndo; count > 0; count--) {\n      this.undoStack.stepBackward();\n    }\n\n    const newStep = new HistoryStep({\n      isFinished: true,\n      cursorStart: [lastChange.start],\n      cursorEnd: [lastChange.start],\n    });\n    newStep.changes = changesToUndo;\n\n    this.undoStack.pushHistoryStep(newStep);\n\n    /*\n     * Unlike the goBackHistoryStep() function, this function does not trust the\n     * HistoryStep.cursorStart property. This can lead to invalid cursor position errors.\n     * Since this function reverses change-by-change, rather than step-by-step,\n     * the cursor position is based on the start of the last change that is undone.\n     */\n    return lastChange && [lastChange.start];\n  }\n\n  /**\n   * Redo the next HistoryStep, if there is one\n   *\n   * @returns the new cursor positions, or undefined if there are no steps to redo\n   */\n  public async goForwardHistoryStep(): Promise<Position[] | undefined> {\n    const step = this.undoStack.stepForward();\n    if (step === undefined) {\n      return undefined;\n    }\n\n    // TODO: do these transformations in a batch\n    for (const change of step.changes) {\n      await change.do(this.vimState.editor);\n    }\n\n    const changes = step.changes.length === 1 ? `1 change` : `${step.changes.length} changes`;\n    StatusBar.setText(\n      this.vimState,\n      `${changes}; after #${this.undoStack.getCurrentHistoryStepIndex()}  ${step.howLongAgo()}`\n    );\n\n    return step.cursorStart;\n  }\n\n  /**\n   * Gets the ending cursor position of the last Change of the last Step.\n   *\n   * In practice, this sets the cursor position to the end of\n   * the most recent text change.\n   */\n  public getLastChangeEndPosition(): Position | undefined {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    const lastChangeIndex = currentHistoryStep.changes.length;\n    if (lastChangeIndex === 0) {\n      return undefined;\n    }\n\n    const lastChange = currentHistoryStep.changes[lastChangeIndex - 1];\n    if (lastChange.isAdd) {\n      return lastChange.end;\n    }\n\n    return lastChange.start;\n  }\n\n  public getLastHistoryStartPosition(): Position[] | undefined {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    return currentHistoryStep.cursorStart;\n  }\n\n  public getLastChangeStartPosition(): Position | undefined {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    const changes = currentHistoryStep.changes;\n    if (changes.length === 0) {\n      return undefined;\n    }\n\n    return changes[changes.length - 1].start;\n  }\n\n  public setLastHistoryEndPosition(pos: Position[]) {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep) {\n      currentHistoryStep.cursorEnd = pos;\n    }\n  }\n\n  public getChangePositionAtIndex(index: number): Position[] | undefined {\n    const step = this.undoStack.getHistoryStepAtIndex(index);\n\n    if (step && step.changes.length > 0) {\n      const change = step.changes[0];\n      return [change.isAdd ? change.end : change.start];\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Handy for debugging the undo/redo stack. + means our current position, check means active.\n   */\n  public toString(): string {\n    let result = '';\n\n    for (let i = 0; i < this.undoStack.getStackDepth(); i++) {\n      const step = this.undoStack.getHistoryStepAtIndex(i)!;\n\n      result += step.changes.map((x) => x.text.replace(/\\n/g, '\\\\n')).join('');\n      if (i === this.undoStack.getCurrentHistoryStepIndex()) {\n        result += '+';\n      }\n      if (step.isFinished) {\n        result += '';\n      }\n      result += '| ';\n    }\n\n    return result;\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nimport { VimState } from '../state/vimState';\n\n/**\n * Represents a Jump in the JumpTracker.\n * Includes information necessary to determine jump actions,\n * and to be able to open the related file.\n */\nexport class Jump {\n  public readonly editor: vscode.TextEditor | null;\n  public readonly fileName: string;\n  public readonly position: Position;\n\n  /**\n   *\n   * @param options\n   * @param options.editor - The editor associated with the jump.\n   * @param options.fileName - The absolute or relative file path.\n   * @param options.position - The line and column number information.\n   */\n  constructor({\n    editor,\n    fileName,\n    position,\n  }: {\n    editor: vscode.TextEditor | null;\n    fileName: string;\n    position: Position;\n  }) {\n    this.editor = editor;\n    this.fileName = fileName;\n    this.position = position;\n  }\n\n  /**\n   * Factory method for creating a Jump from a VimState's current cursor position.\n   * @param vimState - State that contains the fileName and position for the jump\n   */\n  public static fromStateNow(vimState: VimState) {\n    return new Jump({\n      editor: vimState.editor,\n      fileName: vimState.document.fileName,\n      position: vimState.cursorStopPosition,\n    });\n  }\n\n  /**\n   * Factory method for creating a Jump from a VimState's cursor position,\n   * before any actions or commands were performed.\n   * @param vimState - State that contains the fileName and prior position for the jump\n   */\n  public static fromStateBefore(vimState: VimState) {\n    return new Jump({\n      editor: vimState.editor,\n      fileName: vimState.document.fileName,\n      position: vimState.cursorsInitialState[0].stop,\n    });\n  }\n\n  /**\n   * Determine whether another jump matches the same file path, line number, and character column.\n   * @param other - Another Jump to compare against\n   */\n  public isSamePosition(other: Jump): boolean {\n    return this.fileName === other.fileName && this.position.isEqual(other.position);\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { FileCommand } from './../cmd_line/commands/file';\nimport { VimState } from '../state/vimState';\n\nimport { Jump } from './jump';\nimport { existsAsync } from 'platform/fs';\nimport { Position } from 'vscode';\n\n/**\n * JumpTracker is a handrolled version of VSCode's TextEditorState\n * in relation to the 'workbench.action.navigateBack' command.\n */\nexport class JumpTracker {\n  private _jumps: Jump[] = [];\n  private _currentJumpNumber = 0;\n\n  /**\n   * When receiving vscode.window.onDidChangeActiveTextEditor messages,\n   * don't record the jump if we initiated the command.\n   *\n   * Either the jump was added, or it was traversing jump history\n   * and shouldn't count as a new jump.\n   */\n  public isJumpingThroughHistory = false;\n\n  /**\n   * All recorded jumps, in the order of occurrence.\n   */\n  public get jumps(): Jump[] {\n    return this._jumps;\n  }\n\n  /**\n   * Current position in the list of jumps.\n   * This will be past last index if not traveling through history.\n   */\n  public get currentJumpNumber(): number {\n    return this._currentJumpNumber;\n  }\n\n  /**\n   * Current jump in the list of jumps.\n   */\n  public get currentJump(): Jump {\n    return this._jumps[this._currentJumpNumber] || null;\n  }\n\n  /**\n   * Current jump in the list of jumps.\n   */\n  public get hasJumps(): boolean {\n    return this._jumps.length > 0;\n  }\n\n  /**\n   * Last jump in list of jumps.\n   */\n  public get end(): Jump | null {\n    return this._jumps[this._jumps.length - 1];\n  }\n\n  /**\n   * Record that a jump occurred.\n   *\n   * If the current position is back in history,\n   * jumps after this position will be removed.\n   *\n   * @param from - File/position jumped from\n   * @param to - File/position jumped to\n   */\n  public recordJump(from: Jump, to?: Jump) {\n    if (to && from.isSamePosition(to)) {\n      return;\n    }\n\n    this.pushJump(from, to);\n  }\n\n  /**\n   * Record that a jump occurred from one file to another.\n   * This is likely only needed on a handler for\n   * vscode.window.onDidChangeActiveTextEditor.\n   *\n   * File jumps have extra checks in place, keeping in mind\n   * whether this plugin initiated the jump, whether the new file is\n   * a legitimate file.\n   *\n   * @param from - File/position jumped from\n   * @param to - File/position jumped to\n   */\n  public handleFileJump(from: Jump | null, to: Jump) {\n    if (this.isJumpingThroughHistory) {\n      this.isJumpingThroughHistory = false;\n      return;\n    }\n\n    if (to.editor && to.editor.document && to.editor.document.isClosed) {\n      // Wallaby.js seemed to be adding an extra file jump, named e.g. extension-output-#4\n      // It was marked closed when jumping to it. Hopefully we can rely on checking isClosed\n      // when extensions get all weird on us.\n      return;\n    }\n\n    this.pushJump(from, to);\n  }\n\n  private async performFileJump(jump: Jump, vimState: VimState): Promise<void> {\n    this.isJumpingThroughHistory = true;\n\n    if (jump.editor) {\n      // Open jump file from stored editor\n      await vscode.window.showTextDocument(jump.editor.document);\n    } else if (await existsAsync(jump.fileName)) {\n      // Open jump file from disk\n      await new FileCommand({\n        name: jump.fileName,\n        lineNumber: jump.position.line,\n        createFileIfNotExists: false,\n      }).execute(vimState);\n    } else {\n      // Get jump file from visible editors\n      const editor: vscode.TextEditor = vscode.window.visibleTextEditors.filter(\n        (e) => e.document.fileName === jump.fileName\n      )[0];\n\n      if (editor) {\n        await vscode.window.showTextDocument(editor.document, jump.position.character, false);\n      }\n    }\n  }\n\n  /**\n   * Jump forward, possibly resulting in a file jump\n   */\n  public async jumpForward(position: Position, vimState: VimState): Promise<void> {\n    await this.jumpThroughHistory(this.recordJumpForward.bind(this), position, vimState);\n  }\n\n  /**\n   * Jump back, possibly resulting in a file jump\n   */\n  public async jumpBack(position: Position, vimState: VimState): Promise<void> {\n    await this.jumpThroughHistory(this.recordJumpBack.bind(this), position, vimState);\n  }\n\n  private async jumpThroughHistory(\n    getJump: (j: Jump) => Jump,\n    position: Position,\n    vimState: VimState\n  ): Promise<void> {\n    let jump = new Jump({\n      editor: vimState.editor,\n      fileName: vimState.document.fileName,\n      position,\n    });\n\n    const iterations = vimState.recordedState.count || 1;\n    for (let i = 0; i < iterations; i++) {\n      jump = getJump(Jump.fromStateNow(vimState));\n    }\n\n    if (!jump) {\n      return;\n    }\n\n    const jumpedFiles = jump.fileName !== vimState.document.fileName;\n\n    if (jumpedFiles) {\n      await this.performFileJump(jump, vimState);\n    } else {\n      vimState.cursorStopPosition = jump.position;\n    }\n  }\n\n  /**\n   * Get the previous jump in history.\n   * Continues further back if the current line is on the same line.\n   *\n   * @param from - File/position jumped from\n   */\n  public recordJumpBack(from: Jump): Jump {\n    if (!this.hasJumps) {\n      return from;\n    }\n\n    if (this._currentJumpNumber <= 0) {\n      return this._jumps[0];\n    }\n\n    const to: Jump = this._jumps[this._currentJumpNumber - 1];\n\n    if (this._currentJumpNumber === this._jumps.length) {\n      this.recordJump(from, to);\n      this._currentJumpNumber = this._currentJumpNumber - 2;\n    } else {\n      this._currentJumpNumber = this._currentJumpNumber - 1;\n    }\n\n    return to;\n  }\n\n  /**\n   * Get the next jump in history.\n   * Continues further ahead if the current line is on the same line.\n   *\n   * @param from - File/position jumped from\n   */\n  public recordJumpForward(from: Jump): Jump {\n    if (!this.hasJumps) {\n      return from;\n    }\n\n    if (this._currentJumpNumber >= this._jumps.length) {\n      return from;\n    }\n\n    this._currentJumpNumber = Math.min(this._currentJumpNumber + 1, this._jumps.length - 1);\n    return this._jumps[this._currentJumpNumber];\n  }\n\n  /**\n   * Update existing jumps when lines were added to a document.\n   *\n   * @param document - Document that was changed, typically a vscode.TextDocument.\n   * @param range - Location where the text was added.\n   * @param text - Text containing one or more newline characters.\n   */\n  public handleTextAdded(document: { fileName: string }, range: vscode.Range, text: string): void {\n    // Get distance from newlines in the text added.\n    // Unlike handleTextDeleted, the range parameter distance between start/end is generally zero,\n    // just showing where the text was added.\n    const distance = text.split('').filter((c) => c === '\\n').length;\n\n    this._jumps.forEach((jump, i) => {\n      const jumpIsAfterAddedText =\n        jump.fileName === document.fileName && jump.position.line > range.start.line;\n\n      if (jumpIsAfterAddedText) {\n        const newPosition = new Position(jump.position.line + distance, jump.position.character);\n\n        this.changePositionForJumpNumber(i, jump, newPosition);\n      }\n    });\n  }\n\n  /**\n   * Update existing jumps when lines were removed from a document.\n   *\n   * Vim doesn't actually remove deleted lines. Instead, it seems to shift line numbers down\n   * for any jumps after the deleted text, and preserves position for jumps on deleted lines or\n   * lines above the deleted lines. After lines are shifted, if there are multiple jumps on a line,\n   * the duplicates are removed, preserving the newest jumps (preserving latest column number).\n   *\n   * Lines are shifted based on number of lines deleted before the jump. So if e.g. the jump is on\n   * a middle line #6, where the jump above and below it were also deleted, the jump position would\n   * move down just one so it is now line #5, based on the line above it being deleted.\n   *\n   * @param document - Document that was changed, typically a vscode.TextDocument.\n   * @param range - Location where the text was removed.\n   */\n  public handleTextDeleted(document: { fileName: string }, range: vscode.Range): void {\n    // Note that this is like Array.slice, such that range.end.line is one line AFTER a deleted line,\n    // so distance is expected to be at least 1.\n    const distance = range.end.line - range.start.line;\n\n    for (let i = this._jumps.length - 1; i >= 0; i--) {\n      const jump = this._jumps[i];\n\n      if (jump.fileName !== document.fileName) {\n        continue;\n      }\n\n      const jumpIsAfterDeletedText = jump.position.line > range.start.line;\n\n      if (jumpIsAfterDeletedText) {\n        const newLineShiftedUp =\n          jump.position.line - Math.min(jump.position.line - range.start.line, distance);\n        const newPosition = new Position(newLineShiftedUp, jump.position.character);\n\n        this.changePositionForJumpNumber(i, jump, newPosition);\n      }\n    }\n\n    this.removeDuplicateJumps();\n  }\n\n  /**\n   * Clear existing jumps and reset jump position.\n   */\n  public clearJumps(): void {\n    this._jumps.splice(0, this._jumps.length);\n    this._currentJumpNumber = 0;\n  }\n\n  private pushJump(from: Jump | null, to?: Jump) {\n    if (from) {\n      this.clearJumpsOnSamePosition(from);\n    }\n\n    if (from && (!to || !from.isSamePosition(to))) {\n      this._jumps.push(from);\n    }\n\n    this._currentJumpNumber = this._jumps.length;\n\n    this.clearOldJumps();\n  }\n\n  private changePositionForJumpNumber(index: number, jump: Jump, newPosition: Position) {\n    this._jumps.splice(\n      index,\n      1,\n      new Jump({\n        editor: jump.editor,\n        fileName: jump.fileName,\n        position: newPosition,\n      })\n    );\n  }\n\n  private clearOldJumps(): void {\n    if (this._jumps.length > 100) {\n      this._jumps.splice(0, this._jumps.length - 100);\n    }\n  }\n\n  private clearJumpsOnSamePosition(jump: Jump): void {\n    this._jumps = this._jumps.filter((j) => j === jump || !j.isSamePosition(jump));\n  }\n\n  private removeDuplicateJumps() {\n    const linesSeenPerFile = {};\n    for (let i = this._jumps.length - 1; i >= 0; i--) {\n      const jump = this._jumps[i];\n\n      if (!linesSeenPerFile[jump.fileName]) {\n        linesSeenPerFile[jump.fileName] = [];\n      }\n\n      if (linesSeenPerFile[jump.fileName].includes(jump.position.line)) {\n        this._jumps.splice(i, 1);\n      } else {\n        linesSeenPerFile[jump.fileName].push(jump.position.line);\n      }\n    }\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nexport enum Mode {\n  Normal,\n  Insert,\n  Visual,\n  VisualBlock,\n  VisualLine,\n  SearchInProgressMode,\n  CommandlineInProgress,\n  Replace,\n  EasyMotionMode,\n  EasyMotionInputMode,\n  SurroundInputMode,\n  OperatorPendingMode, // Pseudo-Mode, used only when remapping. DON'T SET TO THIS MODE\n  Disabled,\n}\n\nexport enum VSCodeVimCursorType {\n  Block,\n  Line,\n  LineThin,\n  Underline,\n  TextDecoration,\n  Native,\n  UnderlineThin,\n}\n\n/**\n * Is the given mode visual, visual line, or visual block?\n */\nexport function isVisualMode(mode: Mode) {\n  return [Mode.Visual, Mode.VisualLine, Mode.VisualBlock].includes(mode);\n}\n\n/**\n * Is the given mode one where the cursor is on the status bar?\n * This means SearchInProgess and CommandlineInProgress modes.\n */\nexport function isStatusBarMode(mode: Mode): boolean {\n  return [Mode.SearchInProgressMode, Mode.CommandlineInProgress].includes(mode);\n}\n\nexport function getCursorStyle(cursorType: VSCodeVimCursorType) {\n  switch (cursorType) {\n    case VSCodeVimCursorType.Block:\n      return vscode.TextEditorCursorStyle.Block;\n    case VSCodeVimCursorType.Line:\n      return vscode.TextEditorCursorStyle.Line;\n    case VSCodeVimCursorType.LineThin:\n      return vscode.TextEditorCursorStyle.LineThin;\n    case VSCodeVimCursorType.Underline:\n      return vscode.TextEditorCursorStyle.Underline;\n    case VSCodeVimCursorType.UnderlineThin:\n      return vscode.TextEditorCursorStyle.UnderlineThin;\n    case VSCodeVimCursorType.TextDecoration:\n      return vscode.TextEditorCursorStyle.LineThin;\n    case VSCodeVimCursorType.Native:\n    default:\n      return vscode.TextEditorCursorStyle.Block;\n  }\n}\n\nexport function visualBlockGetTopLeftPosition(start: Position, stop: Position): Position {\n  return new Position(Math.min(start.line, stop.line), Math.min(start.character, stop.character));\n}\n\nexport function visualBlockGetBottomRightPosition(start: Position, stop: Position): Position {\n  return new Position(Math.max(start.line, stop.line), Math.max(start.character, stop.character));\n}\n","import * as vscode from 'vscode';\n\nimport { BaseAction, KeypressState, BaseCommand, getRelevantAction } from './../actions/base';\nimport { BaseMovement } from '../actions/baseMotion';\nimport { CommandInsertInInsertMode, CommandInsertPreviousText } from './../actions/commands/insert';\nimport { Jump } from '../jumps/jump';\nimport { Logger } from '../util/logger';\nimport { Mode, VSCodeVimCursorType, isVisualMode, getCursorStyle, isStatusBarMode } from './mode';\nimport { PairMatcher } from './../common/matching/matcher';\nimport { laterOf } from './../common/motion/position';\nimport { Range } from './../common/motion/range';\nimport { IBaseAction, RecordedState } from './../state/recordedState';\nimport { Register, RegisterMode } from './../register/register';\nimport { Remappers } from '../configuration/remapper';\nimport { StatusBar } from '../statusBar';\nimport { TextEditor } from './../textEditor';\nimport { VimError, ForceStopRemappingError } from './../error';\nimport { VimState } from './../state/vimState';\nimport { VSCodeContext } from '../util/vscodeContext';\nimport { commandLine } from '../cmd_line/commandLine';\nimport { configuration } from '../configuration/configuration';\nimport { decoration } from '../configuration/decoration';\nimport { scrollView } from '../util/util';\nimport {\n  CommandQuitRecordMacro,\n  DocumentContentChangeAction,\n  ActionOverrideCmdD,\n  CommandNumber,\n} from './../actions/commands/actions';\nimport { isTextTransformation } from '../transformations/transformations';\nimport { executeTransformations } from '../transformations/execute';\nimport { globalState } from '../state/globalState';\nimport { Notation } from '../configuration/notation';\nimport { EditorIdentity } from '../editorIdentity';\nimport { SpecialKeys } from '../util/specialKeys';\nimport { BaseOperator } from '../actions/operator';\nimport { SearchByNCharCommand } from '../actions/plugins/easymotion/easymotion.cmd';\nimport { Position } from 'vscode';\nimport { RemapState } from '../state/remapState';\nimport * as process from 'process';\nimport { EasyMotion } from '../actions/plugins/easymotion/easymotion';\n\ninterface IModeHandlerMap {\n  get(editorId: EditorIdentity): ModeHandler | undefined;\n}\n\n/**\n * ModeHandler is the extension's backbone. It listens to events and updates the VimState.\n * One of these exists for each editor - see ModeHandlerMap\n *\n * See:  https://github.com/VSCodeVim/Vim/blob/master/.github/CONTRIBUTING.md#the-vim-state-machine\n */\nexport class ModeHandler implements vscode.Disposable {\n  public readonly vimState: VimState;\n  public readonly remapState: RemapState;\n\n  private _disposables: vscode.Disposable[] = [];\n  private _handlerMap: IModeHandlerMap;\n  private _remappers: Remappers;\n  private static readonly logger = Logger.get('ModeHandler');\n\n  // TODO: clarify the difference between ModeHandler.currentMode and VimState.currentMode\n  private _currentMode: Mode;\n\n  get currentMode(): Mode {\n    return this._currentMode;\n  }\n\n  private async setCurrentMode(modeName: Mode): Promise<void> {\n    await this.vimState.setCurrentMode(modeName);\n    this._currentMode = modeName;\n  }\n\n  public static async create(\n    handlerMap: IModeHandlerMap,\n    textEditor = vscode.window.activeTextEditor!\n  ): Promise<ModeHandler> {\n    const modeHandler = new ModeHandler(handlerMap, textEditor);\n    await modeHandler.vimState.load();\n    await modeHandler.setCurrentMode(configuration.startInInsertMode ? Mode.Insert : Mode.Normal);\n    modeHandler.syncCursors();\n    return modeHandler;\n  }\n\n  private constructor(handlerMap: IModeHandlerMap, textEditor: vscode.TextEditor) {\n    this._handlerMap = handlerMap;\n    this._remappers = new Remappers();\n\n    this.vimState = new VimState(textEditor, new EasyMotion());\n    this.remapState = new RemapState();\n    this._disposables.push(this.vimState);\n  }\n\n  /**\n   * Updates VSCodeVim's internal representation of cursors to match VSCode's selections.\n   * This loses some information, so it should only be done when necessary.\n   */\n  public syncCursors() {\n    // TODO: getCursorsAfterSync() is basically this, but stupider\n    global.setImmediate(() => {\n      if (this.vimState.editor) {\n        const { selections } = this.vimState.editor;\n        if (\n          !this.vimState.cursorStartPosition.isEqual(selections[0].anchor) ||\n          !this.vimState.cursorStopPosition.isEqual(selections[0].active)\n        ) {\n          this.vimState.desiredColumn = selections[0].active.character;\n        }\n\n        this.vimState.cursors = selections.map(({ active, anchor }) =>\n          active.isBefore(anchor) ? new Range(anchor.getLeft(), active) : new Range(anchor, active)\n        );\n      }\n    }, 0);\n  }\n\n  /**\n   * This is easily the worst function in VSCodeVim.\n   *\n   * We need to know when VSCode has updated our selection, so that we can sync\n   * that internally. Unfortunately, VSCode has a habit of calling this\n   * function at weird times, or or with incomplete information, so we have to\n   * do a lot of voodoo to make sure we're updating the cursors correctly.\n   *\n   * Even worse, we don't even know how to test this stuff.\n   *\n   * Anyone who wants to change the behavior of this method should make sure\n   * all selection related test cases pass. Follow this spec\n   * https://gist.github.com/rebornix/d21d1cc060c009d4430d3904030bd4c1 to\n   * perform the manual testing. Besides this testing you should still test\n   * commands like 'editor.action.smartSelect.grow' and you should test moving\n   * continuously up/down or left/right with and without remapped movement keys\n   * because sometimes vscode lags behind and calls this function with information\n   * that is not up to date with our selections yet and we need to make sure we don't\n   * change our cursors to previous information (this usally is only an issue in visual\n   * mode because of our different ways of handling selections and in those cases\n   * updating our cursors with not up to date info might result in us changing our\n   * cursor start position).\n   */\n  public async handleSelectionChange(e: vscode.TextEditorSelectionChangeEvent): Promise<void> {\n    if (\n      vscode.window.activeTextEditor === undefined ||\n      e.textEditor.document !== vscode.window.activeTextEditor.document\n    ) {\n      // we don't care if there is no active editor\n      // or user selection changed in a paneled window (e.g debug console/terminal)\n      // This check is made before enqueuing this selection change, but sometimes\n      // between the enqueueing and the actual calling of this function the editor\n      // might close or change to other document\n      return;\n    }\n    const selection = e.selections[0];\n    ModeHandler.logger.debug(\n      `Selections: Handling Selection Change! Selection: ${selection.anchor.toString()}, ${\n        selection.active\n      }, SelectionsLength: ${e.selections.length}`\n    );\n\n    // If our previous cursors are not included on any of the current selections, then a snippet\n    // must have been inserted.\n    const isSnippetSelectionChange = () => {\n      return e.selections.every((s) => {\n        return this.vimState.cursors.every((c) => !s.contains(new vscode.Range(c.start, c.stop)));\n      });\n    };\n\n    if (\n      (e.selections.length !== this.vimState.cursors.length || this.vimState.isMultiCursor) &&\n      this.vimState.currentMode !== Mode.VisualBlock\n    ) {\n      const allowedModes = [Mode.Normal];\n      if (!isSnippetSelectionChange()) {\n        allowedModes.push(...[Mode.Insert, Mode.Replace]);\n      }\n      // Number of selections changed, make sure we know about all of them still\n      this.vimState.cursors = e.textEditor.selections.map(\n        (sel) =>\n          new Range(\n            // Adjust the cursor positions because cursors & selections don't match exactly\n            sel.anchor.isAfter(sel.active) ? sel.anchor.getLeft() : sel.anchor,\n            sel.active\n          )\n      );\n      if (\n        e.selections.some((s) => !s.anchor.isEqual(s.active)) &&\n        allowedModes.includes(this.vimState.currentMode)\n      ) {\n        // If we got a visual selection and we are on normal, insert or replace mode, enter visual mode.\n        // We shouldn't go to visual mode on any other mode, because the other visual modes are handled\n        // very differently than vscode so only our extension will create them. And the other modes\n        // like the plugin modes shouldn't be changed or else it might mess up the plugins actions.\n        await this.setCurrentMode(Mode.Visual);\n      }\n      return this.updateView({ drawSelection: false, revealRange: false });\n    }\n\n    /**\n     * We only trigger our view updating process if it's a mouse selection.\n     * Otherwise we only update our internal cursor positions accordingly.\n     */\n    if (e.kind !== vscode.TextEditorSelectionChangeKind.Mouse) {\n      if (selection) {\n        if (e.kind === vscode.TextEditorSelectionChangeKind.Command) {\n          // This 'Command' kind is triggered when using a command like 'editor.action.smartSelect.grow'\n          // but it is also triggered when we set the 'editor.selections' on 'updateView'.\n          const allowedModes = [Mode.Normal, Mode.Visual];\n          if (!isSnippetSelectionChange()) {\n            // if we just inserted a snippet then don't allow insert modes to go to visual mode\n            allowedModes.push(...[Mode.Insert, Mode.Replace]);\n          }\n          if (allowedModes.includes(this.vimState.currentMode)) {\n            // Since the selections weren't ignored then probably we got change of selection from\n            // a command, so we need to update our start and stop positions. This is where commands\n            // like 'editor.action.smartSelect.grow' are handled.\n            if (this.vimState.currentMode === Mode.Visual) {\n              ModeHandler.logger.debug('Selections: Updating Visual Selection!');\n              this.vimState.cursorStopPosition = selection.active;\n              this.vimState.cursorStartPosition = selection.anchor;\n              await this.updateView({ drawSelection: false, revealRange: false });\n              return;\n            } else if (!selection.active.isEqual(selection.anchor)) {\n              ModeHandler.logger.debug('Selections: Creating Visual Selection from command!');\n              this.vimState.cursorStopPosition = selection.active;\n              this.vimState.cursorStartPosition = selection.anchor;\n              await this.setCurrentMode(Mode.Visual);\n              await this.updateView({ drawSelection: false, revealRange: false });\n              return;\n            }\n          }\n        }\n        // Here we are on the selection changed of kind 'Keyboard' or 'undefined' which is triggered\n        // when pressing movement keys that are not caught on the 'type' override but also when using\n        // commands like 'cursorMove'.\n\n        if (isVisualMode(this.vimState.currentMode)) {\n          /**\n           * In Visual Mode, our `cursorPosition` and `cursorStartPosition` can not reflect `active`,\n           * `start`, `end` and `anchor` information in a selection.\n           * See `Fake block cursor with text decoration` section of `updateView` method.\n           * Besides this, sometimes on visual modes our start position is not the same has vscode\n           * anchor because we need to move vscode anchor one to the right of our start when our start\n           * is after our stop in order to include the start character on vscodes selection.\n           */\n          return;\n        }\n\n        const cursorEnd = laterOf(\n          this.vimState.cursorStartPosition,\n          this.vimState.cursorStopPosition\n        );\n        if (e.textEditor.document.validatePosition(cursorEnd).isBefore(cursorEnd)) {\n          // The document changed such that our cursor position is now out of bounds, possibly by\n          // another program. Let's just use VSCode's selection.\n          // TODO: if this is the case, but we're in visual mode, we never get here (because of branch above)\n        } else if (\n          this.vimState.cursorStopPosition.isEqual(this.vimState.cursorStartPosition) &&\n          this.vimState.cursorStopPosition.getRight().isLineEnd() &&\n          this.vimState.cursorStopPosition.getLineEnd().isEqual(selection.active)\n        ) {\n          // We get here when we use a 'cursorMove' command (that is considered a selection changed\n          // kind of 'Keyboard') that ends past the line break. But our cursors are already on last\n          // character which is what we want. Even though our cursors will be corrected again when\n          // checking if they are in bounds on 'runAction' there is no need to be changing them back\n          // and forth so we check for this situation here.\n          return;\n        }\n\n        // Here we allow other 'cursorMove' commands to update our cursors in case there is another\n        // extension making cursor changes that we need to catch.\n        //\n        // We still need to be careful with this because this here might be changing our cursors\n        // in ways we don't want to. So with future selection issues this is a good place to start\n        // looking.\n        ModeHandler.logger.debug(\n          `Selections: Changing Cursors from selection handler... ${selection.anchor.toString()}, ${\n            selection.active\n          }`\n        );\n        this.vimState.cursorStopPosition = selection.active;\n        this.vimState.cursorStartPosition = selection.anchor;\n        await this.updateView({ drawSelection: false, revealRange: false });\n      }\n      return;\n    }\n\n    if (e.selections.length === 1) {\n      this.vimState.isMultiCursor = false;\n    }\n\n    if (isStatusBarMode(this.vimState.currentMode)) {\n      return;\n    }\n\n    let toDraw = false;\n\n    if (selection) {\n      let newPosition = selection.active;\n\n      // Only check on a click, not a full selection (to prevent clicking past EOL)\n      if (newPosition.character >= newPosition.getLineEnd().character && selection.isEmpty) {\n        if (this.vimState.currentMode !== Mode.Insert) {\n          this.vimState.lastClickWasPastEol = true;\n\n          // This prevents you from mouse clicking past the EOL\n          newPosition = newPosition.withColumn(Math.max(newPosition.getLineEnd().character - 1, 0));\n\n          // Switch back to normal mode since it was a click not a selection\n          await this.setCurrentMode(Mode.Normal);\n\n          toDraw = true;\n        }\n      } else if (selection.isEmpty) {\n        this.vimState.lastClickWasPastEol = false;\n      }\n\n      this.vimState.cursorStopPosition = newPosition;\n      this.vimState.cursorStartPosition = newPosition;\n      this.vimState.desiredColumn = newPosition.character;\n\n      // start visual mode?\n      if (\n        selection.anchor.line === selection.active.line &&\n        selection.anchor.character >= newPosition.getLineEnd().character - 1 &&\n        selection.active.character >= newPosition.getLineEnd().character - 1\n      ) {\n        // This prevents you from selecting EOL\n      } else if (!selection.anchor.isEqual(selection.active)) {\n        let selectionStart = new Position(selection.anchor.line, selection.anchor.character);\n\n        if (selectionStart.character > selectionStart.getLineEnd().character) {\n          selectionStart = new Position(selectionStart.line, selectionStart.getLineEnd().character);\n        }\n\n        this.vimState.cursorStartPosition = selectionStart;\n\n        if (selectionStart.isAfter(newPosition)) {\n          this.vimState.cursorStartPosition = this.vimState.cursorStartPosition.getLeft();\n        }\n\n        // If we prevented from clicking past eol but it is part of this selection, include the last char\n        if (this.vimState.lastClickWasPastEol) {\n          const newStart = new Position(selection.anchor.line, selection.anchor.character + 1);\n          this.vimState.editor.selection = new vscode.Selection(newStart, selection.end);\n          this.vimState.cursorStartPosition = selectionStart;\n          this.vimState.lastClickWasPastEol = false;\n        }\n\n        if (\n          configuration.mouseSelectionGoesIntoVisualMode &&\n          !isVisualMode(this.vimState.currentMode) &&\n          this.currentMode !== Mode.Insert\n        ) {\n          await this.setCurrentMode(Mode.Visual);\n\n          // double click mouse selection causes an extra character to be selected so take one less character\n        }\n      } else if (this.vimState.currentMode !== Mode.Insert) {\n        await this.setCurrentMode(Mode.Normal);\n      }\n\n      this.updateView({ drawSelection: toDraw, revealRange: false });\n    }\n  }\n\n  async handleMultipleKeyEvents(keys: string[]): Promise<void> {\n    for (const key of keys) {\n      await this.handleKeyEvent(key);\n    }\n  }\n\n  public async handleKeyEvent(key: string): Promise<void> {\n    const now = Number(new Date());\n    const printableKey = Notation.printableKey(key, configuration.leader);\n\n    // Check forceStopRemapping\n    if (this.remapState.forceStopRecursiveRemapping) {\n      return;\n    }\n\n    ModeHandler.logger.debug(`handling key=${printableKey}.`);\n\n    if (\n      (key === SpecialKeys.TimeoutFinished ||\n        this.vimState.recordedState.bufferedKeys.length > 0) &&\n      this.vimState.recordedState.bufferedKeysTimeoutObj\n    ) {\n      // Handle the bufferedKeys or append the new key to the previously bufferedKeys\n      clearTimeout(this.vimState.recordedState.bufferedKeysTimeoutObj);\n      this.vimState.recordedState.bufferedKeysTimeoutObj = undefined;\n      this.vimState.recordedState.commandList = [...this.vimState.recordedState.bufferedKeys];\n      this.vimState.recordedState.bufferedKeys = [];\n    }\n\n    // rewrite copy\n    if (configuration.overrideCopy) {\n      // The conditions when you trigger a \"copy\" rather than a ctrl-c are\n      // too sophisticated to be covered by the \"when\" condition in package.json\n      if (key === '<D-c>') {\n        key = '<copy>';\n      }\n\n      if (key === '<C-c>' && process.platform !== 'darwin') {\n        if (\n          !configuration.useCtrlKeys ||\n          this.vimState.currentMode === Mode.Visual ||\n          this.vimState.currentMode === Mode.VisualBlock ||\n          this.vimState.currentMode === Mode.VisualLine\n        ) {\n          key = '<copy>';\n        }\n      }\n    }\n\n    // <C-d> triggers \"add selection to next find match\" by default,\n    // unless users explicity make <C-d>: true\n    if (key === '<C-d>' && !(configuration.handleKeys['<C-d>'] === true)) {\n      key = '<D-d>';\n    }\n\n    this.vimState.cursorsInitialState = this.vimState.cursors;\n    this.vimState.recordedState.commandList.push(key);\n\n    const oldMode = this.vimState.currentMode;\n    const oldFullMode = this.vimState.currentModeIncludingPseudoModes;\n    const oldStatusBarText = StatusBar.getText();\n    const oldWaitingForAnotherActionKey = this.vimState.recordedState.waitingForAnotherActionKey;\n\n    let handledAsRemap = false;\n    let handledAsAction = false;\n    try {\n      // Handling special case for '0'. From Vim documentation (:help :map-modes)\n      // Special case: While typing a count for a command in Normal mode, mapping zero\n      // is disabled. This makes it possible to map zero without making it impossible\n      // to type a count with a zero.\n      const preventZeroRemap =\n        key === '0' && this.vimState.recordedState.getLastActionRun() instanceof CommandNumber;\n\n      // Check for remapped keys if:\n      // 1. We are not currently performing a non-recursive remapping\n      // 2. We are not typing '0' after starting to type a count\n      // 3. We are not waiting for another action key\n      //    Example: jj should not remap the second 'j', if jj -> <Esc> in insert mode\n      //             0 should not be remapped if typed after another number, like 10\n      //             for actions with multiple keys like 'gg' or 'fx' the second character\n      //           shouldn't be mapped\n      if (\n        !this.remapState.isCurrentlyPerformingNonRecursiveRemapping &&\n        !preventZeroRemap &&\n        !this.vimState.recordedState.waitingForAnotherActionKey\n      ) {\n        handledAsRemap = await this._remappers.sendKey(\n          this.vimState.recordedState.commandList,\n          this\n        );\n      }\n\n      this.vimState.recordedState.allowPotentialRemapOnFirstKey = true;\n\n      if (!handledAsRemap) {\n        if (key === SpecialKeys.TimeoutFinished) {\n          // Remove the <TimeoutFinished> key and get the key before that. If the <TimeoutFinished>\n          // key was the last key, then 'key' will be undefined and won't be sent to handle action.\n          this.vimState.recordedState.commandList.pop();\n          key = this.vimState.recordedState.commandList[\n            this.vimState.recordedState.commandList.length - 1\n          ];\n        }\n        if (key !== undefined) {\n          handledAsAction = await this.handleKeyAsAnAction(key);\n        }\n      }\n    } catch (e) {\n      this.vimState.selectionsChanged.ignoreIntermediateSelections = false;\n      if (e instanceof VimError) {\n        StatusBar.displayError(this.vimState, e);\n        this.vimState.recordedState = new RecordedState();\n        if (this.remapState.isCurrentlyPerformingRemapping) {\n          // If we are handling a remap and we got a VimError stop handling the remap\n          // and discard the rest of the keys. We throw an Exception here to stop any other\n          // remapping handling steps and go straight to the 'finally' step of the remapper.\n          throw ForceStopRemappingError.fromVimError(e);\n        }\n      } else if (e instanceof ForceStopRemappingError) {\n        // If this is a ForceStopRemappingError rethrow it until it gets to the remapper\n        throw e;\n      } else if (e instanceof Error) {\n        e.message = `Failed to handle key=${key}. ${e.message}`;\n        throw e;\n      } else {\n        throw new Error(`Failed to handle key=${key} due to an unknown error.`);\n      }\n    }\n\n    this.remapState.lastKeyPressedTimestamp = now;\n\n    StatusBar.updateShowCmd(this.vimState);\n\n    // We don't want to immediately erase any message that resulted from the action just performed\n    if (StatusBar.getText() === oldStatusBarText) {\n      // Clear the status bar of high priority messages if the mode has changed, the view has scrolled\n      // or it is recording a Macro\n      const forceClearStatusBar =\n        (this.vimState.currentMode !== oldMode && this.vimState.currentMode !== Mode.Normal) ||\n        this.vimState.macro !== undefined;\n      StatusBar.clear(this.vimState, forceClearStatusBar);\n    }\n\n    // We either already ran an action or we have a potential action to run but\n    // the key is already stored on 'actionKeys' in that case we don't need it\n    // anymore on commandList that is only used for the remapper and 'showCmd'\n    // and both had already been handled at this point.\n    // If we got here it means that there is no potential remap for the key\n    // either so we need to clear it from commandList so that it doesn't interfere\n    // with the next remapper check.\n    this.vimState.recordedState.resetCommandList();\n\n    ModeHandler.logger.debug(\n      `handleKeyEvent('${printableKey}') took ${Number(new Date()) - now}ms`\n    );\n\n    // If we are handling a remap and the last movement failed stop handling the remap\n    // and discard the rest of the keys. We throw an Exception here to stop any other\n    // remapping handling steps and go straight to the 'finally' step of the remapper.\n    if (this.remapState.isCurrentlyPerformingRemapping && this.vimState.lastMovementFailed) {\n      this.vimState.lastMovementFailed = false;\n      throw new ForceStopRemappingError('Last movement failed');\n    }\n\n    // Reset lastMovementFailed. Anyone who needed it has probably already handled it.\n    // And keeping it past this point would make any following remapping force stop.\n    this.vimState.lastMovementFailed = false;\n\n    if (!handledAsAction) {\n      // There was no action run yet but we still want to update the view to be able\n      // to show the potential remapping keys being pressed, the `\"` character when\n      // waiting on a register key or the `?` character and any following character\n      // when waiting on digraph keys. The 'oldWaitingForAnotherActionKey' is used\n      // to call the updateView after we are no longer waiting keys so that any\n      // existing overlapped key is removed.\n      if (\n        ((this.vimState.currentMode === Mode.Insert ||\n          this.vimState.currentMode === Mode.Replace) &&\n          (this.vimState.recordedState.bufferedKeys.length > 0 ||\n            this.vimState.recordedState.waitingForAnotherActionKey ||\n            this.vimState.recordedState.waitingForAnotherActionKey !==\n              oldWaitingForAnotherActionKey)) ||\n        this.vimState.currentModeIncludingPseudoModes !== oldFullMode\n      ) {\n        // TODO: this call to updateView is only used to update the virtualCharacter and halfBlock\n        // cursor decorations, if in the future we split up the updateView function there should\n        // be no need to call all of it.\n        await this.updateView({ drawSelection: false, revealRange: false });\n      }\n    }\n  }\n\n  private async handleKeyAsAnAction(key: string): Promise<boolean> {\n    if (vscode.window.activeTextEditor !== this.vimState.editor) {\n      ModeHandler.logger.warn('Current window is not active');\n      return false;\n    }\n\n    // Catch any text change not triggered by us (example: tab completion).\n    this.vimState.historyTracker.addChange(this.vimState.cursorsInitialState.map((c) => c.stop));\n\n    this.vimState.keyHistory.push(key);\n\n    const recordedState = this.vimState.recordedState;\n    recordedState.actionKeys.push(key);\n\n    const action = getRelevantAction(recordedState.actionKeys, this.vimState);\n    switch (action) {\n      case KeypressState.NoPossibleMatch:\n        if (this.vimState.currentMode === Mode.Insert) {\n          this.vimState.recordedState.actionKeys = [];\n        } else {\n          this.vimState.recordedState = new RecordedState();\n        }\n        // Since there is no possible action we are no longer waiting any action keys\n        this.vimState.recordedState.waitingForAnotherActionKey = false;\n\n        return false;\n      case KeypressState.WaitingOnKeys:\n        this.vimState.recordedState.waitingForAnotherActionKey = true;\n\n        return false;\n    }\n\n    if (\n      !this.remapState.remapUsedACharacter &&\n      this.remapState.isCurrentlyPerformingRecursiveRemapping\n    ) {\n      // Used a character inside a recursive remapping so we reset the mapDepth.\n      this.remapState.remapUsedACharacter = true;\n      this.remapState.mapDepth = 0;\n    }\n\n    // Since we got an action we are no longer waiting any action keys\n    this.vimState.recordedState.waitingForAnotherActionKey = false;\n\n    // Store action pressed keys for showCmd\n    recordedState.actionsRunPressedKeys.push(...recordedState.actionKeys);\n\n    let actionToRecord: BaseAction | undefined = action;\n    if (recordedState.actionsRun.length === 0) {\n      recordedState.actionsRun.push(action);\n    } else {\n      const lastAction = recordedState.actionsRun[recordedState.actionsRun.length - 1];\n\n      if (lastAction instanceof DocumentContentChangeAction) {\n        lastAction.keysPressed.push(key);\n\n        if (\n          action instanceof CommandInsertInInsertMode ||\n          action instanceof CommandInsertPreviousText\n        ) {\n          // delay the macro recording\n          actionToRecord = undefined;\n        } else {\n          // Push document content change to the stack\n          lastAction.addChanges(this.vimState.historyTracker.currentContentChanges);\n          this.vimState.historyTracker.currentContentChanges = [];\n          recordedState.actionsRun.push(action);\n        }\n      } else {\n        if (\n          action instanceof CommandInsertInInsertMode ||\n          action instanceof CommandInsertPreviousText\n        ) {\n          // This means we are already in Insert Mode but there is still not DocumentContentChangeAction in stack\n          this.vimState.historyTracker.currentContentChanges = [];\n          const newContentChange = new DocumentContentChangeAction();\n          newContentChange.keysPressed.push(key);\n          recordedState.actionsRun.push(newContentChange);\n          actionToRecord = newContentChange;\n        } else {\n          recordedState.actionsRun.push(action);\n        }\n      }\n    }\n\n    if (\n      this.vimState.macro !== undefined &&\n      actionToRecord &&\n      !(actionToRecord instanceof CommandQuitRecordMacro)\n    ) {\n      this.vimState.macro.actionsRun.push(actionToRecord);\n    }\n\n    await this.runAction(recordedState, action);\n\n    if (this.vimState.currentMode === Mode.Insert) {\n      recordedState.isInsertion = true;\n    }\n\n    // Update view\n    await this.updateView();\n\n    if (action.isJump) {\n      globalState.jumpTracker.recordJump(\n        Jump.fromStateBefore(this.vimState),\n        Jump.fromStateNow(this.vimState)\n      );\n    }\n\n    return true;\n  }\n\n  private async runAction(recordedState: RecordedState, action: IBaseAction): Promise<void> {\n    let ranRepeatableAction = false;\n    let ranAction = false;\n    this.vimState.selectionsChanged.ignoreIntermediateSelections = true;\n\n    // If arrow keys or mouse was used prior to entering characters while in insert mode, create an undo point\n    // this needs to happen before any changes are made\n\n    /*\n\n    TODO: This causes . to crash vscodevim for some reason.\n\n    if (!this.vimState.isMultiCursor) {\n      let prevPos = this.vimState.historyTracker.getLastHistoryEndPosition();\n      if (prevPos !== undefined && !this.vimState.isRunningDotCommand) {\n        if (this.vimState.cursorPositionJustBeforeAnythingHappened[0].line !== prevPos[0].line ||\n          this.vimState.cursorPositionJustBeforeAnythingHappened[0].character !== prevPos[0].character) {\n          globalState.previousFullAction = recordedState;\n          this.vimState.historyTracker.finishCurrentStep();\n        }\n      }\n    }\n    */\n\n    // We handle the end of selections different to VSCode. In order for VSCode to select\n    // including the last character we will at the end of 'runAction' shift our stop position\n    // to the right. So here we shift it back by one so that our actions have our correct\n    // position instead of the position sent to VSCode.\n    if (this.vimState.currentMode === Mode.Visual) {\n      this.vimState.cursors = this.vimState.cursors.map((c) =>\n        c.start.isBefore(c.stop) ? c.withNewStop(c.stop.getLeftThroughLineBreaks(true)) : c\n      );\n    }\n\n    if (action instanceof BaseMovement) {\n      recordedState = await this.executeMovement(action);\n      ranAction = true;\n    }\n\n    if (action instanceof BaseCommand) {\n      await action.execCount(this.vimState.cursorStopPosition, this.vimState);\n\n      const transformer = this.vimState.recordedState.transformer;\n      await executeTransformations(this, transformer.transformations);\n\n      if (action.isCompleteAction) {\n        ranAction = true;\n      }\n\n      if (action.canBeRepeatedWithDot) {\n        ranRepeatableAction = true;\n      }\n    }\n\n    if (action instanceof DocumentContentChangeAction) {\n      await action.exec(this.vimState.cursorStopPosition, this.vimState);\n    }\n\n    if (action instanceof BaseOperator) {\n      recordedState.operatorCount = recordedState.count;\n    }\n\n    // Update mode (note the ordering allows you to go into search mode,\n    // then return and have the motion immediately applied to an operator).\n    const prevMode = this.currentMode;\n    if (this.vimState.currentMode !== this.currentMode) {\n      await this.setCurrentMode(this.vimState.currentMode);\n\n      // We don't want to mark any searches as a repeatable action\n      if (\n        this.vimState.currentMode === Mode.Normal &&\n        prevMode !== Mode.SearchInProgressMode &&\n        prevMode !== Mode.CommandlineInProgress &&\n        prevMode !== Mode.EasyMotionInputMode &&\n        prevMode !== Mode.EasyMotionMode\n      ) {\n        ranRepeatableAction = true;\n      }\n    }\n\n    if (recordedState.operatorReadyToExecute(this.vimState.currentMode)) {\n      const operator = this.vimState.recordedState.operator;\n      if (operator) {\n        await this.executeOperator();\n        this.vimState.recordedState.hasRunOperator = true;\n        ranRepeatableAction = operator.canBeRepeatedWithDot;\n        ranAction = true;\n      }\n    }\n\n    // And then we have to do it again because an operator could\n    // have changed it as well. (TODO: do you even decomposition bro)\n    if (this.vimState.currentMode !== this.currentMode) {\n      await this.setCurrentMode(this.vimState.currentMode);\n\n      if (this.vimState.currentMode === Mode.Normal) {\n        ranRepeatableAction = true;\n      }\n    }\n\n    ranRepeatableAction =\n      (ranRepeatableAction && this.vimState.currentMode === Mode.Normal) ||\n      this.createUndoPointForBrackets();\n    ranAction = ranAction && this.vimState.currentMode === Mode.Normal;\n\n    // Record down previous action and flush temporary state\n    if (ranRepeatableAction) {\n      globalState.previousFullAction = this.vimState.recordedState;\n\n      if (recordedState.isInsertion) {\n        Register.putByKey(recordedState, '.', undefined, true);\n      }\n    }\n\n    // Update desiredColumn\n    if (!action.preservesDesiredColumn()) {\n      if (action instanceof BaseMovement) {\n        // We check !operator here because e.g. d$ should NOT set the desired column to EOL.\n        if (action.setsDesiredColumnToEOL && !recordedState.operator) {\n          this.vimState.desiredColumn = Number.POSITIVE_INFINITY;\n        } else {\n          this.vimState.desiredColumn = this.vimState.cursorStopPosition.character;\n        }\n      } else if (this.vimState.currentMode !== Mode.VisualBlock) {\n        // TODO: explain why not VisualBlock\n        this.vimState.desiredColumn = this.vimState.cursorStopPosition.character;\n      }\n    }\n\n    // Like previously stated we handle the end of selections different to VSCode. In order\n    // for VSCode to select including the last character we shift our stop position to the\n    // right now that all steps that need that position have already run. On the next action\n    // we will shift it back again on the start of 'runAction'.\n    if (this.vimState.currentMode === Mode.Visual) {\n      this.vimState.cursors = this.vimState.cursors.map((c) =>\n        c.start.isBeforeOrEqual(c.stop)\n          ? c.withNewStop(\n              c.stop.isLineEnd() ? c.stop.getRightThroughLineBreaks() : c.stop.getRight()\n            )\n          : c\n      );\n    }\n\n    if (ranAction) {\n      this.vimState.recordedState = new RecordedState();\n\n      // Return to insert mode after 1 command in this case for <C-o>\n      if (this.vimState.returnToInsertAfterCommand) {\n        if (this.vimState.actionCount > 0) {\n          await this.setCurrentMode(Mode.Insert);\n        } else {\n          this.vimState.actionCount++;\n        }\n      }\n    }\n\n    // track undo history\n    if (!this.vimState.focusChanged) {\n      // important to ensure that focus didn't change, otherwise\n      // we'll grab the text of the incorrect active window and assume the\n      // whole document changed!\n\n      if (this.vimState.alteredHistory) {\n        this.vimState.alteredHistory = false;\n        this.vimState.historyTracker.ignoreChange();\n      } else {\n        this.vimState.historyTracker.addChange(\n          this.vimState.cursorsInitialState.map((c) => c.stop)\n        );\n      }\n    }\n\n    // Don't record an undo point for every action of a macro, only at the very end\n    if (\n      ranRepeatableAction &&\n      !this.vimState.isReplayingMacro &&\n      !this.remapState.isCurrentlyPerformingRemapping\n    ) {\n      this.vimState.historyTracker.finishCurrentStep();\n    }\n\n    recordedState.actionKeys = [];\n    this.vimState.currentRegisterMode = RegisterMode.AscertainFromCurrentMode;\n\n    if (this.currentMode === Mode.Normal) {\n      this.vimState.cursorStartPosition = this.vimState.cursorStopPosition;\n    }\n\n    // Ensure cursors are within bounds\n    if (\n      !this.vimState.document.isClosed &&\n      this.vimState.editor === vscode.window.activeTextEditor\n    ) {\n      this.vimState.cursors = this.vimState.cursors.map((cursor: Range) => {\n        // adjust start/stop\n        const documentEndPosition = TextEditor.getDocumentEnd(this.vimState.document);\n        const documentLineCount = this.vimState.document.lineCount;\n        if (cursor.start.line >= documentLineCount) {\n          cursor = cursor.withNewStart(documentEndPosition);\n        }\n        if (cursor.stop.line >= documentLineCount) {\n          cursor = cursor.withNewStop(documentEndPosition);\n        }\n\n        // adjust column\n        if (this.vimState.currentMode === Mode.Normal || isVisualMode(this.vimState.currentMode)) {\n          const currentLineLength = TextEditor.getLineLength(cursor.stop.line);\n          const currentStartLineLength = TextEditor.getLineLength(cursor.start.line);\n\n          // When in visual mode you can move the cursor past the last character in order\n          // to select that character. We use this offset to allow for that, otherwise\n          // we would consider the position invalid and change it to the left of the last\n          // character.\n          const offsetAllowed =\n            isVisualMode(this.vimState.currentMode) && currentLineLength > 0 ? 1 : 0;\n          if (cursor.start.character >= currentStartLineLength) {\n            cursor = cursor.withNewStart(\n              cursor.start.withColumn(Math.max(currentStartLineLength - 1, 0))\n            );\n          }\n\n          if (cursor.stop.character >= currentLineLength + offsetAllowed) {\n            cursor = cursor.withNewStop(cursor.stop.withColumn(Math.max(currentLineLength - 1, 0)));\n          }\n        }\n        return cursor;\n      });\n    }\n\n    // Update the current history step to have the latest cursor position\n    this.vimState.historyTracker.setLastHistoryEndPosition(\n      this.vimState.cursors.map((c) => c.stop)\n    );\n\n    if (isVisualMode(this.vimState.currentMode) && !this.vimState.isRunningDotCommand) {\n      // Store selection for commands like gv\n      this.vimState.lastVisualSelection = {\n        mode: this.vimState.currentMode,\n        start: this.vimState.cursorStartPosition,\n        end: this.vimState.cursorStopPosition,\n      };\n    }\n\n    this.vimState.selectionsChanged.ignoreIntermediateSelections = false;\n  }\n\n  private async executeMovement(movement: BaseMovement): Promise<RecordedState> {\n    this.vimState.lastMovementFailed = false;\n    const recordedState = this.vimState.recordedState;\n    const cursorsToRemove: number[] = [];\n\n    for (let i = 0; i < this.vimState.cursors.length; i++) {\n      /**\n       * Essentially what we're doing here is pretending like the\n       * current VimState only has one cursor (the cursor that we just\n       * iterated to).\n       *\n       * We set the cursor position to be equal to the iterated one,\n       * and then set it back immediately after we're done.\n       *\n       * The slightly more complicated logic here allows us to write\n       * Action definitions without having to think about multiple\n       * cursors in almost all cases.\n       */\n      const oldCursorPositionStart = this.vimState.cursorStartPosition;\n      const oldCursorPositionStop = this.vimState.cursorStopPosition;\n      movement.multicursorIndex = i;\n\n      this.vimState.cursorStartPosition = this.vimState.cursors[i].start;\n      const cursorPosition = this.vimState.cursors[i].stop;\n      this.vimState.cursorStopPosition = cursorPosition;\n\n      const result = await movement.execActionWithCount(\n        cursorPosition,\n        this.vimState,\n        recordedState.count\n      );\n\n      // We also need to update the specific cursor, in case the cursor position was modified inside\n      // the handling functions (e.g. 'it')\n      this.vimState.cursors[i] = new Range(\n        this.vimState.cursorStartPosition,\n        this.vimState.cursorStopPosition\n      );\n\n      this.vimState.cursorStartPosition = oldCursorPositionStart;\n      this.vimState.cursorStopPosition = oldCursorPositionStop;\n\n      if (result instanceof Position) {\n        this.vimState.cursors[i] = this.vimState.cursors[i].withNewStop(result);\n\n        if (!isVisualMode(this.currentMode) && !this.vimState.recordedState.operator) {\n          this.vimState.cursors[i] = this.vimState.cursors[i].withNewStart(result);\n        }\n      } else {\n        if (result.failed) {\n          this.vimState.recordedState = new RecordedState();\n          this.vimState.lastMovementFailed = true;\n        }\n\n        if (result.removed) {\n          cursorsToRemove.push(i);\n        } else {\n          this.vimState.cursors[i] = new Range(result.start, result.stop);\n        }\n\n        if (result.registerMode) {\n          this.vimState.currentRegisterMode = result.registerMode;\n        }\n      }\n    }\n\n    if (cursorsToRemove.length > 0) {\n      // Remove the cursors that no longer exist. Remove from the end to the start\n      // so that the index values don't change.\n      for (let i = cursorsToRemove.length - 1; i >= 0; i--) {\n        const idx = cursorsToRemove[i];\n        if (idx !== 0) {\n          // We should never remove the main selection! This shouldn't happen, but just\n          // in case it does, lets protect against it. Remember kids, always use protection!\n          this.vimState.cursors.splice(idx, 1);\n        }\n      }\n    }\n\n    this.vimState.recordedState.count = 0;\n\n    // Keep the cursor within bounds\n    if (this.vimState.currentMode !== Mode.Normal || recordedState.operator) {\n      const stop = this.vimState.cursorStopPosition;\n\n      // Vim does this weird thing where it allows you to select and delete\n      // the newline character, which it places 1 past the last character\n      // in the line. This is why we use > instead of >=.\n\n      if (stop.character > TextEditor.getLineLength(stop.line)) {\n        this.vimState.cursorStopPosition = stop.getLineEnd();\n      }\n    }\n\n    return recordedState;\n  }\n\n  private async executeOperator(): Promise<void> {\n    const recordedState = this.vimState.recordedState;\n    const operator = recordedState.operator!;\n\n    // TODO - if actions were more pure, this would be unnecessary.\n    const startingMode = this.vimState.currentMode;\n    const startingRegisterMode = this.vimState.currentRegisterMode;\n\n    const resultingCursors: Range[] = [];\n    for (let [i, { start, stop }] of this.vimState.cursors.entries()) {\n      operator.multicursorIndex = i;\n\n      if (start.isAfter(stop)) {\n        [start, stop] = [stop, start];\n      }\n\n      if (!isVisualMode(startingMode) && startingRegisterMode !== RegisterMode.LineWise) {\n        stop = stop.getLeftThroughLineBreaks(true);\n      }\n\n      if (this.currentMode === Mode.VisualLine) {\n        start = start.getLineBegin();\n        stop = stop.getLineEnd();\n\n        this.vimState.currentRegisterMode = RegisterMode.LineWise;\n      }\n\n      await this.vimState.setCurrentMode(startingMode);\n\n      // We run the repeat version of an operator if the last 2 operators are the same.\n      if (\n        recordedState.operators.length > 1 &&\n        recordedState.operators.reverse()[0].constructor ===\n          recordedState.operators.reverse()[1].constructor\n      ) {\n        await operator.runRepeat(this.vimState, start, recordedState.count);\n      } else {\n        await operator.run(this.vimState, start, stop);\n      }\n\n      for (const transformation of this.vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = operator.multicursorIndex;\n        }\n      }\n\n      const resultingRange = new Range(\n        this.vimState.cursorStartPosition,\n        this.vimState.cursorStopPosition\n      );\n\n      resultingCursors.push(resultingRange);\n    }\n\n    if (this.vimState.recordedState.transformer.transformations.length > 0) {\n      const transformer = this.vimState.recordedState.transformer;\n      await executeTransformations(this, transformer.transformations);\n    } else {\n      // Keep track of all cursors (in the case of multi-cursor).\n      this.vimState.cursors = resultingCursors;\n    }\n  }\n\n  public async rerunRecordedState(recordedState: RecordedState): Promise<void> {\n    const actions = [...recordedState.actionsRun];\n    const { hasRunSurround, surroundKeys } = recordedState;\n\n    this.vimState.isRunningDotCommand = true;\n\n    // If a previous visual selection exists, store it for use in replay of some commands\n    if (this.vimState.lastVisualSelection) {\n      this.vimState.dotCommandPreviousVisualSelection = new vscode.Selection(\n        this.vimState.lastVisualSelection.start,\n        this.vimState.lastVisualSelection.end\n      );\n    }\n\n    recordedState = new RecordedState();\n    this.vimState.recordedState = recordedState;\n\n    // Replay surround if applicable, otherwise rerun actions\n    if (hasRunSurround) {\n      await this.handleMultipleKeyEvents(surroundKeys);\n    } else {\n      for (const [i, action] of actions.entries()) {\n        recordedState.actionsRun = actions.slice(0, i + 1);\n        await this.runAction(recordedState, action);\n\n        if (this.vimState.lastMovementFailed) {\n          return;\n        }\n\n        await this.updateView();\n      }\n      recordedState.actionsRun = actions;\n    }\n    this.vimState.isRunningDotCommand = false;\n  }\n\n  public async runMacro(recordedMacro: RecordedState): Promise<void> {\n    let recordedState = new RecordedState();\n    this.vimState.recordedState = recordedState;\n    this.vimState.isRunningDotCommand = true;\n\n    for (const action of recordedMacro.actionsRun) {\n      const originalLocation = Jump.fromStateNow(this.vimState);\n\n      this.vimState.cursorsInitialState = this.vimState.cursors;\n\n      recordedState.actionsRun.push(action);\n      this.vimState.keyHistory = this.vimState.keyHistory.concat(action.keysPressed);\n\n      await this.runAction(recordedState, action);\n\n      // We just finished a full action; let's clear out our current state.\n      if (this.vimState.recordedState.actionsRun.length === 0) {\n        recordedState = new RecordedState();\n        this.vimState.recordedState = recordedState;\n      }\n\n      if (this.vimState.lastMovementFailed) {\n        break;\n      }\n\n      await this.updateView();\n\n      if (action.isJump) {\n        globalState.jumpTracker.recordJump(originalLocation, Jump.fromStateNow(this.vimState));\n      }\n    }\n\n    this.vimState.isRunningDotCommand = false;\n    this.vimState.cursorsInitialState = this.vimState.cursors;\n  }\n\n  public updateSearchHighlights(showHighlights: boolean) {\n    let searchRanges: vscode.Range[] = [];\n    if (showHighlights) {\n      searchRanges = globalState.searchState?.getMatchRanges(this.vimState.editor) ?? [];\n    }\n    this.vimState.editor.setDecorations(decoration.searchHighlight, searchRanges);\n  }\n\n  public async updateView(\n    args: { drawSelection: boolean; revealRange: boolean } = {\n      drawSelection: true,\n      revealRange: true,\n    }\n  ): Promise<void> {\n    // Draw selection (or cursor)\n\n    if (\n      args.drawSelection &&\n      !this.vimState.recordedState.actionsRun.some(\n        (action) => action instanceof DocumentContentChangeAction\n      )\n    ) {\n      let selectionMode: Mode = this.vimState.currentMode;\n      if (this.vimState.currentMode === Mode.SearchInProgressMode) {\n        selectionMode = globalState.searchState!.previousMode;\n      } else if (this.vimState.currentMode === Mode.CommandlineInProgress) {\n        selectionMode = commandLine.previousMode;\n      } else if (this.vimState.currentMode === Mode.SurroundInputMode) {\n        selectionMode = this.vimState.surround!.previousMode;\n      }\n\n      let selections = [] as vscode.Selection[];\n      for (const cursor of this.vimState.cursors) {\n        let { start, stop } = cursor;\n        switch (selectionMode) {\n          case Mode.Visual:\n            /**\n             * Always select the letter that we started visual mode on, no matter\n             * if we are in front or behind it. Imagine that we started visual mode\n             * with some text like this:\n             *\n             *   abc|def\n             *\n             * (The | represents the cursor.) If we now press w, we'll select def,\n             * but if we hit b we expect to select abcd, so we need to getRight() on the\n             * start of the selection when it precedes where we started visual mode.\n             */\n            if (start.isAfterOrEqual(stop)) {\n              start = start.getRight();\n            }\n\n            selections.push(new vscode.Selection(start, stop));\n            break;\n\n          case Mode.VisualLine:\n            if (start.isBeforeOrEqual(stop)) {\n              selections.push(new vscode.Selection(start.getLineBegin(), stop.getLineEnd()));\n            } else {\n              selections.push(new vscode.Selection(start.getLineEnd(), stop.getLineBegin()));\n            }\n            break;\n\n          case Mode.VisualBlock:\n            for (const line of TextEditor.iterateLinesInBlock(this.vimState, cursor)) {\n              selections.push(new vscode.Selection(line.start, line.end));\n            }\n            break;\n\n          default:\n            // Note that this collapses the selection onto one position\n            selections.push(new vscode.Selection(stop, stop));\n            break;\n        }\n      }\n\n      /**\n       * Combine instersected selections - When we have multiple cursors\n       * sometimes those cursors selections intersect and combine, we need\n       * to check that here so that we know if our currents cursors will\n       * trigger a selectionChangeEvent or not. If we didn't check for this\n       * vscode might already have the resulting combined selection selected\n       * but since that wouldn't be the same as our selections we would think\n       * there would be a selectionChangeEvent when there wouldn't be any.\n       */\n      const getSelectionsCombined = (sel: vscode.Selection[]) => {\n        const combinedSelections: vscode.Selection[] = [];\n        sel.forEach((s, i) => {\n          if (i > 0) {\n            const previousSelection = combinedSelections[combinedSelections.length - 1];\n            const overlap = s.intersection(previousSelection);\n            if (overlap) {\n              // If anchor is after active we have a backwards selection and in that case we want\n              // the anchor that is lower and/or to the right and the active that is up and/or to\n              // the left. Otherwise we want the anchor that is upper and/or to the left and the\n              // active that is lower and/or to the right.\n\n              let anchor: Position;\n              let active: Position;\n              if (s.anchor.isBeforeOrEqual(s.active)) {\n                // Forwards Selection\n\n                // Get min anchor\n                if (s.anchor.isBeforeOrEqual(previousSelection.anchor)) {\n                  anchor = s.anchor;\n                } else {\n                  anchor = previousSelection.anchor;\n                }\n\n                // Get max active\n                if (s.active.isAfterOrEqual(previousSelection.active)) {\n                  active = s.active;\n                } else {\n                  active = previousSelection.active;\n                }\n              } else {\n                // Backwards Selection\n\n                // Get max anchor\n                if (s.anchor.isAfterOrEqual(previousSelection.anchor)) {\n                  anchor = s.anchor;\n                } else {\n                  anchor = previousSelection.anchor;\n                }\n\n                // Get min active\n                if (s.active.isBeforeOrEqual(previousSelection.active)) {\n                  active = s.active;\n                } else {\n                  active = previousSelection.active;\n                }\n              }\n              combinedSelections[combinedSelections.length - 1] = new vscode.Selection(\n                anchor,\n                active\n              );\n            } else {\n              combinedSelections.push(s);\n            }\n          } else {\n            combinedSelections.push(s);\n          }\n        });\n        return combinedSelections;\n      };\n      selections = getSelectionsCombined(selections);\n\n      // Check if the selection we are going to set is different than the current one.\n      // If they are the same vscode won't trigger a selectionChangeEvent so we don't\n      // have to add it to the ignore selections.\n      const willTriggerChange =\n        selections.length !== this.vimState.editor.selections.length ||\n        selections.some(\n          (s, i) =>\n            !s.anchor.isEqual(this.vimState.editor.selections[i].anchor) ||\n            !s.active.isEqual(this.vimState.editor.selections[i].active)\n        );\n\n      if (willTriggerChange) {\n        const selectionsHash = selections.reduce(\n          (hash, s) =>\n            hash +\n            `[${s.anchor.line}, ${s.anchor.character}; ${s.active.line}, ${s.active.character}]`,\n          ''\n        );\n        this.vimState.selectionsChanged.ourSelections.push(selectionsHash);\n        ModeHandler.logger.debug(\n          `Selections: Adding Selection Change to be Ignored! Hash: ${selectionsHash}, Selections: ${selections[0].anchor.toString()}, ${selections[0].active.toString()}`\n        );\n      }\n\n      this.vimState.editor.selections = selections;\n    }\n\n    // Scroll to position of cursor\n    if (\n      this.vimState.editor.visibleRanges.length > 0 &&\n      !this.vimState.postponedCodeViewChanges.some((change) => change.command === 'editorScroll')\n    ) {\n      /**\n       * This variable decides to which cursor we scroll the view.\n       * It is meant as a patch to #880.\n       * Extend this condition if it is the desired behaviour for other actions as well.\n       */\n      const isLastCursorTracked =\n        this.vimState.recordedState.getLastActionRun() instanceof ActionOverrideCmdD;\n\n      let cursorToTrack: Range;\n      if (isLastCursorTracked) {\n        cursorToTrack = this.vimState.cursors[this.vimState.cursors.length - 1];\n      } else {\n        cursorToTrack = this.vimState.cursors[0];\n      }\n\n      const isCursorAboveRange = (visibleRange: vscode.Range): boolean =>\n        visibleRange.start.line - cursorToTrack.stop.line >= 15;\n      const isCursorBelowRange = (visibleRange: vscode.Range): boolean =>\n        cursorToTrack.stop.line - visibleRange.end.line >= 15;\n\n      const { visibleRanges } = this.vimState.editor;\n      const centerViewportAroundCursor =\n        visibleRanges.every(isCursorAboveRange) || visibleRanges.every(isCursorBelowRange);\n\n      const revealType = centerViewportAroundCursor\n        ? vscode.TextEditorRevealType.InCenter\n        : vscode.TextEditorRevealType.Default;\n\n      if (\n        this.vimState.currentMode === Mode.SearchInProgressMode &&\n        globalState.searchState &&\n        configuration.incsearch\n      ) {\n        const nextMatch = globalState.searchState.getNextSearchMatchPosition(\n          this.vimState.editor,\n          this.vimState.cursorStopPosition\n        );\n\n        if (nextMatch?.match) {\n          this.vimState.editor.revealRange(\n            new vscode.Range(nextMatch.pos, nextMatch.pos),\n            revealType\n          );\n        } else if (this.vimState.firstVisibleLineBeforeSearch !== undefined) {\n          const offset =\n            this.vimState.editor.visibleRanges[0].start.line -\n            this.vimState.firstVisibleLineBeforeSearch;\n          scrollView(this.vimState, offset);\n        }\n      } else if (args.revealRange) {\n        if (\n          !isLastCursorTracked ||\n          this.vimState.cursorsInitialState.length !== this.vimState.cursors.length\n        ) {\n          /**\n           * We scroll the view if either:\n           * 1. the cursor we want to keep in view is the main one (this is the \"standard\"\n           * (before this commit) situation)\n           * 2. if we track the last cursor, but no additional cursor was created in this step\n           * (in the Cmd+D situation this means that no other matches were found)\n           */\n          this.vimState.editor.revealRange(\n            new vscode.Range(cursorToTrack.stop, cursorToTrack.stop),\n            revealType\n          );\n        }\n      }\n    }\n\n    // cursor style\n    let cursorStyle = configuration.getCursorStyleForMode(Mode[this.currentMode]);\n    if (!cursorStyle) {\n      const cursorType = getCursorType(\n        this.vimState,\n        this.vimState.currentModeIncludingPseudoModes\n      );\n      cursorStyle = getCursorStyle(cursorType);\n      if (\n        cursorType === VSCodeVimCursorType.Native &&\n        configuration.editorCursorStyle !== undefined\n      ) {\n        cursorStyle = configuration.editorCursorStyle;\n      }\n    }\n    this.vimState.editor.options.cursorStyle = cursorStyle;\n\n    // cursor block\n    const cursorRange: vscode.Range[] = [];\n    if (\n      getCursorType(this.vimState, this.currentMode) === VSCodeVimCursorType.TextDecoration &&\n      this.currentMode !== Mode.Insert\n    ) {\n      // Fake block cursor with text decoration. Unfortunately we can't have a cursor\n      // in the middle of a selection natively, which is what we need for Visual Mode.\n      if (this.currentMode === Mode.Visual) {\n        for (const { start: cursorStart, stop: cursorStop } of this.vimState.cursors) {\n          if (cursorStart.isBefore(cursorStop)) {\n            cursorRange.push(new vscode.Range(cursorStop.getLeft(), cursorStop));\n          } else {\n            cursorRange.push(new vscode.Range(cursorStop, cursorStop.getRight()));\n          }\n        }\n      } else {\n        for (const { stop: cursorStop } of this.vimState.cursors) {\n          cursorRange.push(new vscode.Range(cursorStop, cursorStop.getRight()));\n        }\n      }\n    }\n\n    this.vimState.editor.setDecorations(decoration.default, cursorRange);\n\n    // Insert Mode virtual characters: used to temporarily show the remapping pressed keys on\n    // insert mode, to show the `\"` character after pressing `<C-r>`, and to show `?` and the\n    // first character when inserting digraphs with `<C-k>`.\n    const iModeVirtualCharDecorationOptions: vscode.DecorationOptions[] = [];\n    if (this.vimState.currentMode === Mode.Insert || this.vimState.currentMode === Mode.Replace) {\n      let virtualKey: string | undefined;\n      if (this.vimState.recordedState.bufferedKeys.length > 0) {\n        virtualKey = this.vimState.recordedState.bufferedKeys[\n          this.vimState.recordedState.bufferedKeys.length - 1\n        ];\n      } else if (this.vimState.recordedState.waitingForAnotherActionKey) {\n        virtualKey = this.vimState.recordedState.actionKeys[\n          this.vimState.recordedState.actionKeys.length - 1\n        ];\n        if (virtualKey === '<C-r>') {\n          virtualKey = '\"';\n        } else if (virtualKey === '<C-k>') {\n          virtualKey = '?';\n        }\n      }\n      // Don't show keys with `<` like `<C-x>` but show everything else\n      virtualKey = virtualKey && /<[^>]+>/.test(virtualKey) ? undefined : virtualKey;\n\n      if (virtualKey) {\n        // Normal Render Options with the key to overlap on the next character\n        const renderOptions: vscode.ThemableDecorationRenderOptions = {\n          before: {\n            contentText: virtualKey,\n          },\n        };\n\n        /**\n         * EOL Render Options:\n         * Some times when at the end of line the `currentColor` won't work, or it might be\n         * transparent, so we set the color to 'editor.foreground' when at EOL to avoid the\n         * virtualKey character not showing up.\n         */\n        const eolRenderOptions: vscode.ThemableDecorationRenderOptions = {\n          before: {\n            contentText: virtualKey,\n            color: new vscode.ThemeColor('editor.foreground'),\n          },\n        };\n\n        for (const { stop: cursorStop } of this.vimState.cursors) {\n          if (cursorStop.isLineEnd()) {\n            iModeVirtualCharDecorationOptions.push({\n              range: new vscode.Range(cursorStop, cursorStop.getLineEndIncludingEOL()),\n              renderOptions: eolRenderOptions,\n            });\n          } else {\n            iModeVirtualCharDecorationOptions.push({\n              range: new vscode.Range(cursorStop, cursorStop.getRightThroughLineBreaks(true)),\n              renderOptions,\n            });\n          }\n        }\n      }\n    }\n\n    this.vimState.editor.setDecorations(\n      decoration.insertModeVirtualCharacter,\n      iModeVirtualCharDecorationOptions\n    );\n\n    // OperatorPendingMode half block cursor\n    const opCursorDecorations: vscode.DecorationOptions[] = [];\n    const opCursorCharDecorations: vscode.DecorationOptions[] = [];\n    if (this.vimState.currentModeIncludingPseudoModes === Mode.OperatorPendingMode) {\n      for (const { stop: cursorStop } of this.vimState.cursors) {\n        let text = TextEditor.getCharAt(this.vimState.document, cursorStop);\n        // the ' ' (<space>) needs to be changed to '&nbsp;'\n        text = text === ' ' ? '\\u00a0' : text;\n        const renderOptions: vscode.ThemableDecorationRenderOptions = {\n          before: {\n            contentText: text,\n          },\n        };\n        opCursorDecorations.push({\n          range: new vscode.Range(cursorStop, cursorStop.getRight()),\n          renderOptions,\n        });\n        opCursorCharDecorations.push({\n          range: new vscode.Range(cursorStop, cursorStop.getRight()),\n          renderOptions,\n        });\n      }\n    }\n\n    this.vimState.editor.setDecorations(decoration.operatorPendingModeCursor, opCursorDecorations);\n    this.vimState.editor.setDecorations(\n      decoration.operatorPendingModeCursorChar,\n      opCursorCharDecorations\n    );\n\n    for (const markDecoration of decoration.allMarkDecorations()) {\n      this.vimState.editor.setDecorations(markDecoration, []);\n    }\n\n    if (configuration.showMarksInGutter) {\n      for (const { position, name } of this.vimState.historyTracker.getMarks()) {\n        const markDecoration = decoration.getOrCreateMarkDecoration(name);\n\n        const markLine = position.getLineBegin();\n        const markRange = new vscode.Range(markLine, markLine);\n\n        this.vimState.editor.setDecorations(markDecoration, [markRange]);\n      }\n    }\n\n    const showHighlights =\n      (configuration.incsearch && this.currentMode === Mode.SearchInProgressMode) ||\n      (configuration.hlsearch && globalState.hl);\n    for (const editor of vscode.window.visibleTextEditors) {\n      this._handlerMap\n        .get(EditorIdentity.fromEditor(editor))\n        ?.updateSearchHighlights(showHighlights);\n    }\n\n    const easyMotionDimRanges =\n      this.currentMode === Mode.EasyMotionInputMode &&\n      configuration.easymotionDimBackground &&\n      this.vimState.easyMotion.searchAction instanceof SearchByNCharCommand\n        ? [\n            new vscode.Range(\n              TextEditor.getDocumentBegin(),\n              TextEditor.getDocumentEnd(this.vimState.document)\n            ),\n          ]\n        : [];\n    const easyMotionHighlightRanges =\n      this.currentMode === Mode.EasyMotionInputMode &&\n      this.vimState.easyMotion.searchAction instanceof SearchByNCharCommand\n        ? this.vimState.easyMotion.searchAction\n            .getMatches(this.vimState.cursorStopPosition, this.vimState)\n            .map((match) => match.toRange())\n        : [];\n    this.vimState.editor.setDecorations(decoration.easyMotionDimIncSearch, easyMotionDimRanges);\n    this.vimState.editor.setDecorations(decoration.easyMotionIncSearch, easyMotionHighlightRanges);\n\n    for (const viewChange of this.vimState.postponedCodeViewChanges) {\n      vscode.commands.executeCommand(viewChange.command, viewChange.args);\n    }\n    this.vimState.postponedCodeViewChanges = [];\n\n    if (this.currentMode === Mode.EasyMotionMode) {\n      // Update all EasyMotion decorations\n      this.vimState.easyMotion.updateDecorations(this.vimState.editor);\n    }\n\n    StatusBar.clear(this.vimState, false);\n\n    await VSCodeContext.set('vim.mode', Mode[this.vimState.currentMode]);\n\n    // Tell VSCode that the cursor position changed, so it updates its highlights for\n    // `editor.occurrencesHighlight`.\n\n    const range = new vscode.Range(\n      this.vimState.cursorStartPosition,\n      this.vimState.cursorStopPosition\n    );\n    if (!/\\s+/.test(this.vimState.document.getText(range))) {\n      vscode.commands.executeCommand('editor.action.wordHighlight.trigger');\n    }\n  }\n\n  // Return true if a new undo point should be created based on brackets and parentheses\n  private createUndoPointForBrackets(): boolean {\n    // }])> keys all start a new undo state when directly next to an {[(< opening character\n    const key = this.vimState.recordedState.actionKeys[\n      this.vimState.recordedState.actionKeys.length - 1\n    ];\n\n    if (key === undefined) {\n      return false;\n    }\n\n    if (this.vimState.currentMode === Mode.Insert) {\n      // Check if the keypress is a closing bracket to a corresponding opening bracket right next to it\n      let result = PairMatcher.nextPairedChar(\n        this.vimState.cursorStopPosition,\n        key,\n        this.vimState,\n        false\n      );\n      if (result !== undefined) {\n        if (this.vimState.cursorStopPosition.isEqual(result)) {\n          return true;\n        }\n      }\n\n      result = PairMatcher.nextPairedChar(\n        this.vimState.cursorStopPosition.getLeft(),\n        key,\n        this.vimState,\n        false\n      );\n      if (result !== undefined) {\n        if (this.vimState.cursorStopPosition.getLeft(2).isEqual(result)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  dispose() {\n    this._disposables.map((d) => d.dispose());\n  }\n}\n\nfunction getCursorType(vimState: VimState, mode: Mode): VSCodeVimCursorType {\n  switch (mode) {\n    case Mode.Normal:\n      return VSCodeVimCursorType.Block;\n    case Mode.Insert:\n      return VSCodeVimCursorType.Native;\n    case Mode.Visual:\n      return VSCodeVimCursorType.TextDecoration;\n    case Mode.VisualBlock:\n      return VSCodeVimCursorType.TextDecoration;\n    case Mode.VisualLine:\n      return VSCodeVimCursorType.TextDecoration;\n    case Mode.SearchInProgressMode:\n      return VSCodeVimCursorType.UnderlineThin;\n    case Mode.CommandlineInProgress:\n      return VSCodeVimCursorType.UnderlineThin;\n    case Mode.Replace:\n      return VSCodeVimCursorType.Underline;\n    case Mode.EasyMotionMode:\n      return VSCodeVimCursorType.Block;\n    case Mode.EasyMotionInputMode:\n      return VSCodeVimCursorType.Block;\n    case Mode.SurroundInputMode:\n      return getCursorType(vimState, vimState.surround!.previousMode);\n    case Mode.OperatorPendingMode:\n      return VSCodeVimCursorType.UnderlineThin;\n    case Mode.Disabled:\n    default:\n      return VSCodeVimCursorType.Line;\n  }\n}\n","import { ModeHandler } from './modeHandler';\nimport { EditorIdentity } from '../editorIdentity';\n\n/**\n * Stores one ModeHandler (and therefore VimState) per editor.\n */\nclass ModeHandlerMapImpl {\n  private modeHandlerMap = new Map<EditorIdentity, ModeHandler>();\n\n  public async getOrCreate(editorId: EditorIdentity): Promise<[ModeHandler, boolean]> {\n    let isNew = false;\n    let modeHandler: ModeHandler | undefined = this.get(editorId);\n\n    if (!modeHandler) {\n      isNew = true;\n      modeHandler = await ModeHandler.create(this);\n      this.modeHandlerMap.set(editorId, modeHandler);\n    }\n    return [modeHandler, isNew];\n  }\n\n  public get(editorId: EditorIdentity): ModeHandler | undefined {\n    for (const [key, value] of this.modeHandlerMap.entries()) {\n      if (key.isEqual(editorId)) {\n        return value;\n      }\n    }\n    return undefined;\n  }\n\n  public getKeys(): EditorIdentity[] {\n    return [...this.modeHandlerMap.keys()];\n  }\n\n  public getAll(): ModeHandler[] {\n    return [...this.modeHandlerMap.values()];\n  }\n\n  public delete(editorId: EditorIdentity) {\n    const modeHandler = this.modeHandlerMap.get(editorId);\n    if (modeHandler) {\n      modeHandler.dispose();\n      this.modeHandlerMap.delete(editorId);\n    }\n  }\n\n  public clear() {\n    for (const key of this.modeHandlerMap.keys()) {\n      this.delete(key);\n    }\n  }\n}\n\nexport const ModeHandlerMap = new ModeHandlerMapImpl();\n","export const SUPPORT_VIMRC = false;\nexport const SUPPORT_NVIM = false;\nexport const SUPPORT_IME_SWITCHER = false;\nexport const SUPPORT_READ_COMMAND = false;\n","import * as vscode from 'vscode';\n\nexport const constants = {\n  UV_FS_SYMLINK_DIR: 1,\n  UV_FS_SYMLINK_JUNCTION: 2,\n  O_RDONLY: 0,\n  O_WRONLY: 1,\n  O_RDWR: 2,\n  UV_DIRENT_UNKNOWN: 0,\n  UV_DIRENT_FILE: 1,\n  UV_DIRENT_DIR: 2,\n  UV_DIRENT_LINK: 3,\n  UV_DIRENT_FIFO: 4,\n  UV_DIRENT_SOCKET: 5,\n  UV_DIRENT_CHAR: 6,\n  UV_DIRENT_BLOCK: 7,\n  S_IFMT: 61440,\n  S_IFREG: 32768,\n  S_IFDIR: 16384,\n  S_IFCHR: 8192,\n  S_IFBLK: 24576,\n  S_IFIFO: 4096,\n  S_IFLNK: 40960,\n  S_IFSOCK: 49152,\n  O_CREAT: 512,\n  O_EXCL: 2048,\n  UV_FS_O_FILEMAP: 0,\n  O_NOCTTY: 131072,\n  O_TRUNC: 1024,\n  O_APPEND: 8,\n  O_DIRECTORY: 1048576,\n  O_NOFOLLOW: 256,\n  O_SYNC: 128,\n  O_DSYNC: 4194304,\n  O_SYMLINK: 2097152,\n  O_NONBLOCK: 4,\n  S_IRWXU: 448,\n  S_IRUSR: 256,\n  S_IWUSR: 128,\n  S_IXUSR: 64,\n  S_IRWXG: 56,\n  S_IRGRP: 32,\n  S_IWGRP: 16,\n  S_IXGRP: 8,\n  S_IRWXO: 7,\n  S_IROTH: 4,\n  S_IWOTH: 2,\n  S_IXOTH: 1,\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n  UV_FS_COPYFILE_EXCL: 1,\n  COPYFILE_EXCL: 1,\n  UV_FS_COPYFILE_FICLONE: 2,\n  COPYFILE_FICLONE: 2,\n  UV_FS_COPYFILE_FICLONE_FORCE: 4,\n  COPYFILE_FICLONE_FORCE: 4,\n};\n\nexport async function doesFileExist(fileUri: vscode.Uri) {\n  try {\n    await vscode.workspace.fs.stat(fileUri);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function existsAsync(path: string): Promise<boolean> {\n  try {\n    await vscode.workspace.fs.stat(vscode.Uri.parse(path));\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\n\nexport async function unlink(path: string): Promise<void> {\n  await vscode.workspace.fs.delete(vscode.Uri.parse(path));\n}\n\nexport async function readFileAsync(path: string, encoding: string): Promise<string> {\n  const ret = await vscode.workspace.fs.readFile(vscode.Uri.parse(path));\n  return ret.toString();\n}\n\nexport async function mkdirAsync(path: string, options: any): Promise<void> {\n  return vscode.workspace.fs.createDirectory(vscode.Uri.parse(path));\n}\n\nexport async function writeFileAsync(\n  path: string,\n  content: string,\n  encoding: string\n): Promise<void> {\n  return vscode.workspace.fs.writeFile(vscode.Uri.parse(path), Buffer.from(content));\n}\n\nexport async function accessAsync(path: string, mode: number) {\n  // no op in nodeless\n}\n\nexport async function chmodAsync(path: string, mode: string | number) {\n  // no op in nodeless\n}\n\nexport function unlinkSync(path: string) {\n  // no op in nodeless\n}\n","import * as vscode from 'vscode';\nimport { ILogger } from '../common/logger';\n\nexport class HistoryBase {\n  private _historyFileName: string;\n  private _history: string[] = [];\n  get historyKey(): string {\n    return `vim.${this._historyFileName}`;\n  }\n  private _context: vscode.ExtensionContext;\n  private _extensionStoragePath: string;\n  private _logger: ILogger;\n\n  constructor(\n    context: vscode.ExtensionContext,\n    historyFileName: string,\n    extensionStoragePath: string,\n    logger: ILogger\n  ) {\n    this._context = context;\n    this._historyFileName = historyFileName;\n    this._extensionStoragePath = extensionStoragePath;\n    this._logger = logger;\n  }\n\n  public async add(value: string | undefined, history: number): Promise<void> {\n    if (!value || value.length === 0) {\n      return;\n    }\n\n    // remove duplicates\n    const index: number = this._history.indexOf(value);\n    if (index !== -1) {\n      this._history.splice(index, 1);\n    }\n\n    // append to the end\n    this._history.push(value);\n\n    // resize array if necessary\n    if (this._history.length > history) {\n      this._history = this._history.slice(this._history.length - history);\n    }\n\n    return this.save();\n  }\n\n  public get(history: number): string[] {\n    // resize array if necessary\n    if (this._history.length > history) {\n      this._history = this._history.slice(this._history.length - history);\n    }\n\n    return this._history;\n  }\n\n  public async clear() {\n    this._context.workspaceState.update(this.historyKey, undefined);\n    this._history = [];\n  }\n\n  public async load(): Promise<void> {\n    const data = this._context.workspaceState.get<string>(this.historyKey) || '';\n    if (data.length === 0) {\n      return;\n    }\n\n    const parsedData = JSON.parse(data);\n    if (!Array.isArray(parsedData)) {\n      throw Error('Unexpected format in history. Expected JSON.');\n    }\n    this._history = parsedData;\n  }\n\n  async save(): Promise<void> {\n    this._context.workspaceState.update(this.historyKey, JSON.stringify(this._history));\n  }\n}\n","import { IConfiguration } from '../../configuration/iconfiguration';\nimport { ILogger } from 'src/platform/common/logger';\n\n/**\n * Displays VSCode message to user\n */\nexport class VsCodeMessage implements ILogger {\n  actionMessages = ['Dismiss', 'Suppress Errors'];\n  private prefix: string;\n  configuration?: IConfiguration;\n\n  constructor(prefix: string) {\n    this.prefix = prefix;\n  }\n\n  error(errorMessage: string): void {\n    this.log({ level: 'error', message: errorMessage });\n  }\n\n  debug(debugMessage: string): void {\n    this.log({ level: 'debug', message: debugMessage });\n  }\n\n  warn(warnMessage: string): void {\n    this.log({ level: 'warn', message: warnMessage });\n  }\n\n  verbose(verboseMessage: string): void {\n    this.log({ level: 'verbose', message: verboseMessage });\n  }\n\n  private async log(info: { level: string; message: string }) {\n    if (this.configuration && this.configuration.debug.silent) {\n      return;\n    }\n    let showMessage: (message: string, ...items: string[]) => void;\n    switch (info.level) {\n      case 'error':\n        showMessage = console.error;\n        break;\n      case 'warn':\n        showMessage = console.warn;\n        break;\n      case 'info':\n      case 'verbose':\n      case 'debug':\n        showMessage = console.log;\n        break;\n      default:\n        throw Error(`Unsupported log level ${info.level}`);\n    }\n\n    showMessage(`${this.prefix}: ${info.message}`, ...this.actionMessages);\n  }\n\n  public configChanged(configuration: IConfiguration): void {\n    this.configuration = configuration;\n  }\n}\n\nexport class LoggerImpl {\n  static get(prefix: string): ILogger {\n    return new VsCodeMessage(prefix);\n  }\n}\n","import * as vscode from 'vscode';\nimport { Clipboard } from './../util/clipboard';\nimport {\n  ActionDeleteChar,\n  ActionDeleteCharWithDeleteKey,\n  ActionDeleteLastChar,\n  CommandRegister,\n  CommandYankFullLine,\n} from './../actions/commands/actions';\nimport { DeleteOperator, YankOperator } from './../actions/operator';\nimport { RecordedState } from './../state/recordedState';\nimport { VimState } from './../state/vimState';\nimport { readFileAsync, writeFileAsync } from 'platform/fs';\nimport { Globals } from '../globals';\n\n/**\n * There are two different modes of copy/paste in Vim - copy by character\n * and copy by line. Copy by line typically happens in Visual Line mode, but\n * also shows up in some other actions that work over lines (most notably dd,\n * yy).\n */\nexport enum RegisterMode {\n  AscertainFromCurrentMode,\n  CharacterWise,\n  LineWise,\n  BlockWise,\n}\n\nexport type RegisterContent = string | string[] | RecordedState;\n\nexport interface IRegisterContent {\n  text: RegisterContent;\n  registerMode: RegisterMode;\n}\n\nexport class Register {\n  /**\n   * \" is the unnamed register.\n   * * and + are special registers for accessing the system clipboard.\n   * . is the last inserted text.\n   * - is the last deleted text less than a line.\n   * / is the most recently executed search.\n   * : is the most recently executed command.\n   * % is the current file path (relative to workspace root).\n   * # is the previous file path (relative to workspace root).\n   * _ is the black hole register; it's always empty.\n   */\n  private static readonly specialRegisters = ['\"', '*', '+', '.', '-', '/', ':', '%', '#', '_'];\n\n  private static registers: Map<string, IRegisterContent>;\n\n  /**\n   * \". readonly register: last content change.\n   */\n  public static lastContentChange: RecordedState;\n\n  /**\n   * Puts content in a register. If none is specified, uses the default register \".\n   */\n  public static put(content: RegisterContent, vimState: VimState, multicursorIndex?: number): void {\n    const register = vimState.recordedState.registerName;\n\n    if (!Register.isValidRegister(register)) {\n      throw new Error(`Invalid register ${register}`);\n    }\n\n    if (Register.isBlackHoleRegister(register) || Register.isReadOnlyRegister(register)) {\n      return;\n    }\n\n    if (vimState.isMultiCursor) {\n      if (Register.isValidUppercaseRegister(register)) {\n        Register.appendMulticursorRegister(content, register, vimState, multicursorIndex as number);\n      } else {\n        Register.putMulticursorRegister(content, register, vimState, multicursorIndex as number);\n      }\n    } else {\n      if (Register.isValidUppercaseRegister(register)) {\n        Register.appendNormalRegister(content, register, vimState);\n      } else {\n        Register.putNormalRegister(content, register, vimState);\n      }\n    }\n  }\n\n  public static isValidRegister(register: string): boolean {\n    return (\n      Register.isValidLowercaseRegister(register) ||\n      Register.isValidUppercaseRegister(register) ||\n      /^[0-9]$/.test(register) ||\n      this.specialRegisters.includes(register)\n    );\n  }\n\n  public static isValidRegisterForMacro(register: string): boolean {\n    return /^[a-zA-Z0-9:]$/.test(register);\n  }\n\n  private static isBlackHoleRegister(registerName: string): boolean {\n    return registerName === '_';\n  }\n\n  private static isClipboardRegister(registerName: string): boolean {\n    return registerName === '*' || registerName === '+';\n  }\n\n  private static isReadOnlyRegister(registerName: string): boolean {\n    return ['.', '%', ':', '#', '/'].includes(registerName);\n  }\n\n  private static isValidLowercaseRegister(register: string): boolean {\n    return /^[a-z]$/.test(register);\n  }\n\n  private static isValidUppercaseRegister(register: string): boolean {\n    return /^[A-Z]$/.test(register);\n  }\n\n  /**\n   * Puts the content at the specified index of the multicursor Register.\n   *\n   * `REMARKS:` This procedure assumes that you pass an valid register.\n   */\n  private static putMulticursorRegister(\n    content: RegisterContent,\n    register: string,\n    vimState: VimState,\n    multicursorIndex: number\n  ): void {\n    if (multicursorIndex === 0) {\n      Register.registers.set(register.toLowerCase(), {\n        text: [],\n        registerMode: vimState.effectiveRegisterMode,\n      });\n    }\n\n    const registerContent = Register.registers.get(register.toLowerCase())!;\n\n    if (!Array.isArray(registerContent.text)) {\n      registerContent.text = [];\n    }\n\n    registerContent.text.push(content as string);\n\n    if (multicursorIndex === vimState.cursors.length - 1) {\n      if (this.isClipboardRegister(register)) {\n        let clipboardText: string = '';\n\n        for (const line of registerContent.text) {\n          clipboardText += line + '\\n';\n        }\n        clipboardText = clipboardText.replace(/\\n$/, '');\n\n        Clipboard.Copy(clipboardText);\n      }\n\n      Register.processNumberedRegister(registerContent.text, vimState);\n    }\n  }\n\n  /**\n   * Appends the content at the specified index of the multicursor Register.\n   *\n   * `REMARKS:` This Procedure assume that you pass an valid uppercase register.\n   */\n  private static appendMulticursorRegister(\n    content: RegisterContent,\n    register: string,\n    vimState: VimState,\n    multicursorIndex: number\n  ): void {\n    let appendToRegister = Register.registers.get(register.toLowerCase())!;\n\n    // Only append if appendToRegister is multicursor register\n    // and line count match, otherwise replace register\n    if (multicursorIndex === 0) {\n      let createEmptyRegister: boolean = false;\n\n      if (typeof appendToRegister.text === 'string') {\n        createEmptyRegister = true;\n      } else {\n        if ((appendToRegister.text as string[]).length !== vimState.cursors.length) {\n          createEmptyRegister = true;\n        }\n      }\n\n      if (createEmptyRegister) {\n        Register.registers.set(register.toLowerCase(), {\n          text: Array<string>(vimState.cursors.length).fill(''),\n          registerMode: vimState.effectiveRegisterMode,\n        });\n\n        appendToRegister = Register.registers.get(register.toLowerCase())!;\n      }\n    }\n\n    const currentRegisterMode = vimState.effectiveRegisterMode;\n    if (\n      appendToRegister.registerMode === RegisterMode.CharacterWise &&\n      currentRegisterMode === RegisterMode.CharacterWise\n    ) {\n      appendToRegister.text[multicursorIndex] += content;\n    } else {\n      appendToRegister.text[multicursorIndex] += '\\n' + content;\n      appendToRegister.registerMode = currentRegisterMode;\n    }\n  }\n\n  /**\n   * Puts the content in the specified Register.\n   *\n   * `REMARKS:` This Procedure assume that you pass an valid register.\n   */\n  private static putNormalRegister(\n    content: RegisterContent,\n    register: string,\n    vimState: VimState\n  ): void {\n    if (Register.isClipboardRegister(register)) {\n      Clipboard.Copy(content.toString());\n    }\n\n    Register.registers.set(register.toLowerCase(), {\n      text: content,\n      registerMode: vimState.effectiveRegisterMode,\n    });\n\n    Register.processNumberedRegister(content, vimState);\n  }\n\n  /**\n   * Appends the content at the specified index of the multicursor Register.\n   *\n   * `REMARKS:` This Procedure assume that you pass an valid uppercase register.\n   */\n  private static appendNormalRegister(\n    content: RegisterContent,\n    register: string,\n    vimState: VimState\n  ): void {\n    register = register.toLowerCase();\n    const currentRegisterMode = vimState.effectiveRegisterMode;\n    let appendToRegister = Register.registers.get(register);\n    if (appendToRegister === undefined) {\n      appendToRegister = { registerMode: currentRegisterMode, text: '' };\n      Register.registers.set(register, appendToRegister);\n    }\n\n    // Check if appending to a multicursor register or normal\n    if (appendToRegister.text instanceof Array) {\n      if (\n        appendToRegister.registerMode === RegisterMode.CharacterWise &&\n        currentRegisterMode === RegisterMode.CharacterWise\n      ) {\n        for (let i = 0; i < appendToRegister.text.length; i++) {\n          appendToRegister.text[i] += content;\n        }\n      } else {\n        for (let i = 0; i < appendToRegister.text.length; i++) {\n          appendToRegister.text[i] += '\\n' + content;\n        }\n        appendToRegister.registerMode = currentRegisterMode;\n      }\n    } else if (typeof appendToRegister.text === 'string') {\n      if (\n        appendToRegister.registerMode === RegisterMode.CharacterWise &&\n        currentRegisterMode === RegisterMode.CharacterWise\n      ) {\n        appendToRegister.text = appendToRegister.text + content;\n      } else {\n        appendToRegister.text += '\\n' + content;\n        appendToRegister.registerMode = currentRegisterMode;\n      }\n    }\n  }\n\n  public static putByKey(\n    content: RegisterContent,\n    register = '\"',\n    registerMode = RegisterMode.AscertainFromCurrentMode,\n    force = false\n  ): void {\n    if (!Register.isValidRegister(register)) {\n      throw new Error(`Invalid register ${register}`);\n    }\n\n    if (Register.isClipboardRegister(register)) {\n      Clipboard.Copy(content.toString());\n    }\n\n    if (Register.isBlackHoleRegister(register)) {\n      return;\n    }\n\n    if (Register.isReadOnlyRegister(register) && !force) {\n      return;\n    }\n\n    Register.registers.set(register, {\n      text: content,\n      registerMode: registerMode || RegisterMode.AscertainFromCurrentMode,\n    });\n  }\n\n  /**\n   * Handles special cases for Yank- and DeleteOperator.\n   */\n  private static processNumberedRegister(content: RegisterContent, vimState: VimState): void {\n    // Find the BaseOperator of the current actions\n    const baseOperator = vimState.recordedState.operator || vimState.recordedState.command;\n\n    if (baseOperator instanceof YankOperator || baseOperator instanceof CommandYankFullLine) {\n      // 'yank' to 0 only if no register was specified\n      const registerCommand = vimState.recordedState.actionsRun.find((value) => {\n        return value instanceof CommandRegister;\n      });\n\n      if (!registerCommand) {\n        Register.registers.set('0', {\n          text: content,\n          registerMode: vimState.effectiveRegisterMode,\n        });\n      }\n    } else if (\n      (baseOperator instanceof DeleteOperator ||\n        baseOperator instanceof ActionDeleteChar ||\n        baseOperator instanceof ActionDeleteLastChar ||\n        baseOperator instanceof ActionDeleteCharWithDeleteKey) &&\n      !(vimState.macro !== undefined || vimState.isReplayingMacro)\n    ) {\n      if (\n        !content.toString().match(/\\n/g) &&\n        vimState.currentRegisterMode !== RegisterMode.LineWise\n      ) {\n        Register.registers.set('-', {\n          text: content,\n          registerMode: RegisterMode.CharacterWise,\n        });\n      } else {\n        // shift 'delete-history' register\n        for (let index = 9; index > 1; index--) {\n          const previous = Register.registers.get(String(index - 1));\n          if (previous) {\n            Register.registers.set(String(index), { ...previous });\n          }\n        }\n\n        // Paste last delete into register '1'\n        Register.registers.set('1', {\n          text: content,\n          registerMode: vimState.effectiveRegisterMode,\n        });\n      }\n    }\n  }\n\n  /**\n   * Gets content from a register. If no register is specified, uses `vimState.recordedState.registerName`.\n   */\n  public static async get(\n    vimState?: VimState,\n    register?: string\n  ): Promise<IRegisterContent | undefined> {\n    register ??= vimState?.recordedState.registerName;\n\n    if (register === undefined) {\n      return undefined;\n    }\n\n    if (!Register.isValidRegister(register)) {\n      throw new Error(`Invalid register ${register}`);\n    }\n\n    register = register.toLowerCase();\n\n    /* Read from system clipboard */\n    if (Register.isClipboardRegister(register)) {\n      let text = await Clipboard.Paste();\n\n      // Harmonize newline character\n      text = text.replace(/\\r\\n/g, '\\n');\n\n      let registerText: string | string[];\n      if (vimState && vimState.isMultiCursor) {\n        registerText = text.split('\\n');\n        if (registerText.length !== vimState.cursors.length) {\n          registerText = text;\n        }\n      } else {\n        registerText = text;\n      }\n\n      const registerContent = {\n        text: registerText,\n        registerMode: Register.registers.get(register)?.registerMode ?? RegisterMode.CharacterWise,\n      };\n      Register.registers.set(register, registerContent);\n      return registerContent;\n    } else {\n      return Register.registers.get(register);\n    }\n  }\n\n  public static has(register: string): boolean {\n    return Register.registers.has(register);\n  }\n\n  public static getKeys(): string[] {\n    return [...Register.registers.keys()];\n  }\n\n  public static async saveToDisk(supportNode: boolean): Promise<void> {\n    if (supportNode) {\n      const serializable = new Array<[string, IRegisterContent]>();\n      for (const [key, content] of Register.registers) {\n        if (typeof content.text === 'string' || Array.isArray(content.text)) {\n          serializable.push([key, content]);\n        }\n      }\n\n      return import('path').then((path) => {\n        return writeFileAsync(\n          path.join(Globals.extensionStoragePath, '.registers'),\n          JSON.stringify(serializable),\n          'utf8'\n        );\n      });\n    }\n  }\n\n  public static loadFromDisk(supportNode: boolean): void {\n    if (supportNode) {\n      Register.registers = new Map();\n      import('path').then((path) => {\n        readFileAsync(path.join(Globals.extensionStoragePath, '.registers'), 'utf8').then(\n          (savedRegisters) => {\n            Register.registers = new Map(JSON.parse(savedRegisters));\n          }\n        );\n      });\n    } else {\n      Register.registers = new Map();\n    }\n  }\n}\n","export class CompositionState {\n  isInComposition: boolean = false;\n  insertedText: boolean = false;\n  composingText: string = '';\n\n  reset() {\n    this.isInComposition = false;\n    this.insertedText = false;\n    this.composingText = '';\n  }\n}\n","import * as vscode from 'vscode';\nimport { JumpTracker } from '../jumps/jumpTracker';\nimport { Mode } from '../mode/mode';\nimport { RecordedState } from './../state/recordedState';\nimport { SearchHistory } from '../history/historyFile';\nimport { SearchState, SearchDirection } from './searchState';\nimport { SubstituteState } from './substituteState';\nimport { configuration } from '../configuration/configuration';\nimport { Position } from 'vscode';\n\n/**\n * State which stores global state (across editors)\n */\nclass GlobalState {\n  /**\n   * Previous searches performed\n   */\n  private _searchStatePrevious: SearchState[] = [];\n\n  /**\n   * Track jumps, and traverse jump history\n   */\n  public readonly jumpTracker: JumpTracker = new JumpTracker();\n\n  /**\n   * Tracks search history\n   */\n  private _searchHistory: SearchHistory;\n\n  /**\n   * The keystroke sequence that made up our last complete action (that can be\n   * repeated with '.').\n   */\n  public previousFullAction: RecordedState | undefined = undefined;\n\n  /**\n   * Last substitute state for running :s by itself\n   */\n  public substituteState: SubstituteState | undefined = undefined;\n\n  /**\n   * Last search state for running n and N commands\n   */\n  public searchState: SearchState | undefined = undefined;\n\n  /**\n   *  Index used for navigating search history with <up> and <down> when searching\n   */\n  public searchStateIndex: number = 0;\n\n  /**\n   * Used internally for nohl.\n   */\n  public hl = true;\n\n  public async load(context: vscode.ExtensionContext) {\n    this._searchHistory = new SearchHistory(context);\n    this._searchHistory\n      .get()\n      .forEach((val) =>\n        this.searchStatePrevious.push(\n          new SearchState(SearchDirection.Forward, new Position(0, 0), val, undefined, Mode.Normal)\n        )\n      );\n  }\n\n  /**\n   * Getters and setters for changing global state\n   */\n  public get searchStatePrevious(): SearchState[] {\n    return this._searchStatePrevious;\n  }\n\n  public set searchStatePrevious(states: SearchState[]) {\n    this._searchStatePrevious = this._searchStatePrevious.concat(states);\n  }\n\n  public async addSearchStateToHistory(searchState: SearchState) {\n    const prevSearchString =\n      this.searchStatePrevious.length === 0\n        ? undefined\n        : this.searchStatePrevious[this.searchStatePrevious.length - 1].searchString;\n    // Store this search if different than previous\n    if (searchState.searchString !== prevSearchString) {\n      this.searchStatePrevious.push(searchState);\n      if (this._searchHistory !== undefined) {\n        await this._searchHistory.add(searchState.searchString);\n      }\n    }\n\n    // Make sure search history does not exceed configuration option\n    if (this.searchStatePrevious.length > configuration.history) {\n      this.searchStatePrevious.splice(0, 1);\n    }\n\n    // Update the index to the end of the search history\n    this.searchStateIndex = this.searchStatePrevious.length - 1;\n  }\n\n  /**\n   * Shows the search history as a QuickPick (popup list)\n   *\n   * @returns The SearchState that was selected by the user, if there was one.\n   */\n  public async showSearchHistory(): Promise<SearchState | undefined> {\n    const items = this._searchStatePrevious\n      .slice()\n      .reverse()\n      .map((searchState) => {\n        return {\n          label: searchState.searchString,\n          searchState,\n        };\n      });\n\n    const item = await vscode.window.showQuickPick(items, {\n      placeHolder: 'Vim search history',\n      ignoreFocusOut: false,\n    });\n\n    return item ? item.searchState : undefined;\n  }\n}\n\nexport const globalState = new GlobalState();\n","import { configuration } from '../configuration/configuration';\nimport { Mode, isVisualMode } from '../mode/mode';\nimport { PositionDiff } from './../common/motion/position';\nimport { Transformer } from './../transformations/transformer';\nimport { SpecialKeys } from '../util/specialKeys';\nimport type { VimState } from './vimState';\nimport { Position } from 'vscode';\n\n/**\n * The RecordedState class holds the current action that the user is\n * doing. Example: Imagine that the user types:\n *\n * 5\"qdw\n *\n * Then the relevant state would be\n *   * count of 5\n *   * copy into q register\n *   * delete operator\n *   * word movement\n *\n *\n * Or imagine the user types:\n *\n * vw$}}d\n *\n * Then the state would be\n *   * Visual mode action\n *   * (a list of all the motions you ran)\n *   * delete operator\n */\nexport class RecordedState {\n  constructor() {\n    this.registerName = configuration.useSystemClipboard ? '*' : '\"';\n  }\n\n  /**\n   * The keys the user has pressed that have not caused an action to be executed\n   * yet and have not been stored on action keys. Used for command remapping.\n   */\n  public commandList: string[] = [];\n\n  /**\n   * String representation of the exact keys that the user entered.\n   */\n  public get commandString(): string {\n    let result = '';\n\n    if (this.actionsRun.length > 0) {\n      result = this.actionsRunPressedKeys.join('');\n    }\n    if (this.actionKeys.length > 0) {\n      // if there are any actionKeys waiting for other key append them\n      result += this.actionKeys.join('');\n    }\n    if (this.bufferedKeys.length > 0) {\n      // if there are any bufferedKeys waiting for other key append them\n      result += this.bufferedKeys.join('');\n    }\n    if (\n      this.actionsRun.length === 0 &&\n      this.actionKeys.length === 0 &&\n      this.bufferedKeys.length === 0 &&\n      this.commandList.length > 0\n    ) {\n      // Used for the registers and macros that only record on commandList\n      result = this.commandList.join('');\n    }\n    const regexEscape = new RegExp(/[|\\\\{}()[\\]^$+*?.]/, 'g');\n    const regexLeader = new RegExp(configuration.leader.replace(regexEscape, '\\\\$&'), 'g');\n    const regexBufferedKeys = new RegExp(SpecialKeys.TimeoutFinished, 'g');\n    result = result.replace(regexLeader, '<leader>').replace(regexBufferedKeys, '');\n\n    return result;\n  }\n\n  /**\n   * String representation of the pending keys that the user entered.\n   */\n  public get pendingCommandString(): string {\n    let result = '';\n\n    if (this.actionKeys.length > 0) {\n      // if there are any actionKeys waiting for other key append them\n      result += this.actionKeys.join('');\n    }\n    if (this.bufferedKeys.length > 0) {\n      // if there are any bufferedKeys waiting for other key append them\n      result += this.bufferedKeys.join('');\n    }\n    const regexEscape = new RegExp(/[|\\\\{}()[\\]^$+*?.]/, 'g');\n    const regexLeader = new RegExp(configuration.leader.replace(regexEscape, '\\\\$&'), 'g');\n    const regexBufferedKeys = new RegExp(SpecialKeys.TimeoutFinished, 'g');\n    result = result.replace(regexLeader, '<leader>').replace(regexBufferedKeys, '');\n\n    return result;\n  }\n\n  /**\n   * Determines if the current command list is prefixed with a count\n   */\n  public get commandWithoutCountPrefix() {\n    return this.commandList.join('').replace(/^[0-9]+/g, '');\n  }\n\n  /**\n   * Reset the command list.\n   */\n  public resetCommandList() {\n    this.commandList = [];\n  }\n\n  /**\n   * Keeps track of keys pressed for the next action. Comes in handy when parsing\n   * multiple length movements, e.g. gg.\n   */\n  public actionKeys: string[] = [];\n\n  /**\n   * Waiting for another key for a potential action.\n   *\n   * Used to prevent the remapping of keys after a potential action key\n   * like @zZtTfF[]rm'`\"gq<C-r><C-w>. This is done to be able to use all\n   * the named registers and marks, even when the command with the same\n   * name has been mapped.\n   *\n   * Vim Documentation: (:help map-error)\n   * \"Note that the second character (argument) of the commands @zZtTfF[]rm'`\"v\n   * and CTRL-X is not mapped. This was done to be able to use all the named\n   * registers and marks, even when the command with the same name has been\n   * mapped.\"\n   *\n   * The documentation only specifies some keys, but from testing pretty much\n   * every key has this condition (keys like 'g', 'q', '<C-r>' and '<C-w>' all\n   * behave the same) so here we use 'waitingForAnotherActionKey' to prevent\n   * remapping on next keys. In the case of the 'v' key specified in the vim\n   * documentation, I don't really understand what they mean with that because\n   * it doesn't make much sense. The 'v' key puts you in Visual mode, it doesn't\n   * accept any character argument.\n   */\n  public waitingForAnotherActionKey: boolean = false;\n\n  /**\n   * Every action that has been run.\n   */\n  public actionsRun: IBaseAction[] = [];\n\n  /**\n   * Keeps track of keys pressed by the actionsRun. Used for the showCmd. If an action\n   * changes previous actions pressed keys it should change this list, like the <Del>\n   * key after a number key.\n   */\n  public actionsRunPressedKeys: string[] = [];\n\n  public getLastActionRun(): IBaseAction | undefined {\n    if (this.actionsRun.length === 0) {\n      return;\n    }\n\n    return this.actionsRun[this.actionsRun.length - 1];\n  }\n\n  /**\n   * Every key that was buffered to wait for a new key or the timeout to finish\n   * in order to get another potential remap or to solve an ambiguous remap.\n   */\n  public bufferedKeys: string[] = [];\n  public bufferedKeysTimeoutObj: NodeJS.Timeout | undefined = undefined;\n\n  /**\n   * This is used when the remappers are resending the keys after a potential\n   * remap without an ambiguous remap is broken, either by a new key or by the\n   * timeout finishing.\n   *\n   * It will make it so the first key sent will not be considered as a potential\n   * remap by any of the remappers, even though it is, to prevent the remappers\n   * of doing the same thing again. This way the first key will be handled as an\n   * action but the next keys can still be remapped.\n   *\n   * Example: if you map `iiii -> i<C-A><Esc>` in normal mode and map `ii -> <Esc>`\n   * in insert mode, after pressing `iii` you want the first `i` to put you in\n   * insert mode and the next `ii` to escape to normal mode.\n   */\n  public allowPotentialRemapOnFirstKey = true;\n\n  public hasRunOperator = false;\n\n  public hasRunSurround = false;\n  public surroundKeys: string[] = [];\n  public surroundKeyIndexStart = 0;\n\n  /**\n   * This is kind of a hack and should be associated with something like this:\n   *\n   * https://github.com/VSCodeVim/Vim/issues/805\n   */\n  public operatorPositionDiff: PositionDiff | undefined;\n\n  public isInsertion = false;\n\n  /**\n   * The text transformations that we want to run. They will all be run after the action has been processed.\n   *\n   * Running an individual action will generally queue up to one of these, but if you're in\n   * multi-cursor mode, you'll queue one per cursor, or more.\n   *\n   * Note that the text transformations are run in parallel. This is useful in most cases,\n   * but will get you in trouble in others.\n   */\n  public transformer = new Transformer();\n\n  /**\n   * The operator (e.g. d, y, >) the user wants to run, if there is one.\n   */\n  public get operator(): IBaseOperator | undefined {\n    const operators = this.operators;\n    return operators.length > 0 ? operators[0] : undefined;\n  }\n\n  public get operators(): IBaseOperator[] {\n    return this.actionsRun.filter((a): a is IBaseOperator => a.isOperator).reverse();\n  }\n\n  /**\n   * The command (e.g. i, ., R, /) the user wants to run, if there is one.\n   */\n  public get command(): IBaseCommand {\n    const list = this.actionsRun.filter((a): a is IBaseCommand => a.isCommand).reverse();\n\n    // TODO - disregard <Esc>, then assert this is of length 1.\n\n    return list[0];\n  }\n\n  public get hasRunAMovement(): boolean {\n    return this.actionsRun.some((a) => a.isMotion);\n  }\n\n  /**\n   * The number of times the user wants to repeat this action.\n   */\n  public count: number = 0;\n\n  /**\n   * The number of times the user wants to repeat the operator. If after the operator the user\n   * uses a motion with count that count will be multiplied by this count.\n   *\n   * Example: if user presses 2d3w it deletes 6 words.\n   */\n  public operatorCount: number = 0;\n\n  /**\n   * The register name for this action.\n   */\n  public registerName: string;\n\n  public clone(): RecordedState {\n    const res = new RecordedState();\n\n    // TODO: Actual clone.\n\n    res.actionKeys = this.actionKeys.slice(0);\n    res.actionsRun = this.actionsRun.slice(0);\n    res.hasRunOperator = this.hasRunOperator;\n    res.hasRunSurround = this.hasRunSurround;\n    res.surroundKeys = this.surroundKeys;\n\n    return res;\n  }\n\n  public operatorReadyToExecute(mode: Mode): boolean {\n    // Visual modes do not require a motion -- they ARE the motion.\n    return (\n      this.operator !== undefined &&\n      !this.hasRunOperator &&\n      mode !== Mode.SearchInProgressMode &&\n      mode !== Mode.CommandlineInProgress &&\n      (this.hasRunAMovement ||\n        isVisualMode(mode) ||\n        (this.operators.length > 1 &&\n          this.operators.reverse()[0].constructor === this.operators.reverse()[1].constructor))\n    );\n  }\n\n  public isOperatorPending(mode: Mode): boolean {\n    // Visual modes do not require a motion -- they ARE the motion.\n    return (\n      this.operator !== undefined &&\n      !this.hasRunOperator &&\n      mode !== Mode.SearchInProgressMode &&\n      mode !== Mode.CommandlineInProgress &&\n      !(\n        this.hasRunAMovement ||\n        isVisualMode(mode) ||\n        (this.operators.length > 1 &&\n          this.operators.reverse()[0].constructor === this.operators.reverse()[1].constructor)\n      )\n    );\n  }\n}\n\nexport interface IBaseAction {\n  isMotion: boolean;\n  isOperator: boolean;\n  isCommand: boolean;\n  isJump: boolean;\n  canBeRepeatedWithDot: boolean;\n\n  keysPressed: string[];\n  multicursorIndex: number | undefined;\n\n  preservesDesiredColumn(): boolean;\n}\n\nexport interface IBaseCommand extends IBaseAction {\n  exec(position: Position, vimState: VimState): Promise<void>;\n}\n\nexport interface IBaseOperator extends IBaseAction {\n  run(vimState: VimState, start: Position, stop: Position): Promise<void>;\n  runRepeat(vimState: VimState, position: Position, count: number): Promise<void>;\n}\n","import { IKeyRemapping } from '../configuration/iconfiguration';\n\n/**\n * State related to key remapping. Held by ModeHandler.\n */\nexport class RemapState {\n  /**\n   * For timing out remapped keys like jj to esc.\n   */\n  public lastKeyPressedTimestamp = 0;\n\n  /**\n   * Used to indicate that a non-recursive remap is being handled.\n   * This is used to prevent non-recursive remappings from looping.\n   */\n  public isCurrentlyPerformingNonRecursiveRemapping = false;\n\n  /**\n   * Used to indicate that a recursive remap is being handled. This is used to prevent recursive remappings\n   * from looping farther then maxMapDepth and to stop recursive remappings when an action fails.\n   */\n  public isCurrentlyPerformingRecursiveRemapping = false;\n\n  /**\n   * Used to indicate that a remap is being handled and the keys sent to modeHandler were not typed\n   * by the user.\n   */\n  public get isCurrentlyPerformingRemapping() {\n    return (\n      this.isCurrentlyPerformingNonRecursiveRemapping ||\n      this.isCurrentlyPerformingRecursiveRemapping\n    );\n  }\n\n  /**\n   * When performing a recursive remapping that has no parent remappings and that finishes while\n   * still waiting for timeout or another key to come we store that remapping here. This is used\n   * to be able to handle those buffered keys and any other key that the user might press to brake\n   * the timeout seperatly. Because if an error happens in the middle of a remap, the remaining\n   * remap keys shouldn't be handled but the user pressed ones should, but if an error happens on\n   * a user typed key, the following typed keys will still be handled.\n   *\n   * Example: having the following remapings:\n   * * `nmap <leader>lf Lfill`\n   * * `nmap Lfillc 4I<space><esc>`\n   * * `nmap Lfillp 2I<space><esc>`\n   * When user presses `<leader>lf` it remaps that to `Lfill` but because that is an ambiguous remap\n   * it creates the timeout and returns from remapper setting the performing remapping flag to false.\n   * This allows the user to then press `c` or `p` and the corresponding remap would run. But if the\n   * user presses another key or the timeout finishes we need to handle the `Lfill` keys and they\n   * need to know they were sent by a remap and not by the user so that in case the find 'i' in\n   * `Lfill` fails the last two `l` shouldn't be executed and any keys typed by the user after the\n   * remap that brake the timeout need to be handled seperatly from `Lfill`.\n   * (Check the tests for this example to understand better).\n   *\n   * To prevent this, we stored the remapping that finished waiting for timeout so that, if the\n   * timeout finishes or the user presses some keys that brake the potential remap, we will know\n   * what was the remapping waiting for timeout. So in case the timeout finishes we set the\n   * currently performing recursive remapping flag to true manually, send the <TimeoutFinished> key\n   * and in the end we set the flag back to false again and clear the stored remapping. In case\n   * the user presses one or more keys that brake the potential timeout we set the flag to true\n   * manually, handle the keys from the remapping and then set the flag back to false, clear the\n   * stored remapping and handle the keys pressed by the user seperatly.\n   * We do this because any VimError or ForceStopRemappingError are thrown only when performing a\n   * remapping.\n   */\n  public wasPerformingRemapThatFinishedWaitingForTimeout: IKeyRemapping | false = false;\n\n  /**\n   * Holds the current map depth count (number of nested remaps without using a character). In recursive remaps\n   * every time we map a key when already performing a remapping this number increases by one. When a remapping\n   * handling uses a character this number resets to 0.\n   *\n   * When it reaches the maxMapDepth it throws the VimError E223.\n   * (check vim documentation :help maxmapdepth)\n   */\n  public mapDepth: number = 0;\n\n  /**\n   * Used to reset the mapDepth on nested recursive remaps. Is set to false every time we get a remapping and is set to\n   * true when a character is used. We consider a character as being used when we get an action.\n   * (check vim documentation :help maxmapdepth).\n   *\n   * Example 1: if we remap `x -> y` and `y -> x` if we press any of those keys we will continuously find a new\n   * remap and increase the mapDepth without ever using an action until we hit maxMapDepth and we get E223 stopping\n   * it all.\n   *\n   * Example 2: if we map `a -> x`, `x -> y`, `y -> b` and `b -> w` and we set maxMapDepth to 4 we get 'E223 Recursive\n   * Mapping', because we get to the fourth remap without ever executing an action, but if we change the 'y' map to\n   * `y -> wb`, now the max mapDepth we hit is 3 and then we execute the action 'w' that resets the mapDepth and then\n   * call another remap of `b -> w` that executes another 'w', meaning that after pressing 'a' the result would be 'ww'.\n   * Another option would be to increase the maxMapDepth to 5 or more and then we could use the initial remaps that would\n   * turn the pressing of 'a' into a single 'w'.\n   *\n   * Example 3 (possible use case): if we remap `<leader>cb -> 0i//<Space><Esc>j<leader>cb` that recursively calls itself,\n   * every time the`0` key is sent we set remapUsedACharacter to true and reset mapDepth to 0 on all nested remaps so even\n   * if it calls itself more than 1000 times (on a file with more than 1000 lines) the mapDepth will always be reset to 0,\n   * which allows the remap to keep calling itself to comment all the lines until either we get to the last line and the 'j'\n   * action fails stopping the entire remap chain or the user presses `<C-c>` or `<Esc>` to forcelly stop the recursive remaps.\n   *\n   * P.S. This behavior is weird, because we should reduce the mapDepth by one when the remapping finished handling\n   * or if it failed. But this is the way Vim does it. This allows the user to create infinite looping remaps\n   * that call themselves and only stop after an error or the user pressing a key (usually <C-c> but we also\n   * allow <Esc> because the user might not allow the use of ctrl keys).\n   *\n   * P.S.2 This is a complicated explanation for a seemingly simple feature, but I wrote this because when I first read the\n   * Vim documentation it wasn't very clear to me how this worked, I first thought that mapDepth was like a map count but that\n   * is not the case because we can have thousands of nested remaps without ever hitting maxMapDepth like in Example 3, and I\n   * only started to understand it better when I tried Example 2 in Vim and some variations of it.\n   */\n  public remapUsedACharacter: boolean = false;\n\n  /**\n   * This will force Stop a recursive remapping. Used by <C-c> or <Esc> key when there is a recursive remapping\n   */\n  public forceStopRecursiveRemapping: boolean = false;\n}\n","import { Position } from 'vscode';\nimport { TextEditor } from './../textEditor';\nimport { VimState } from './vimState';\n\n/**\n * State involved with entering Replace mode (R).\n */\nexport class ReplaceState {\n  /**\n   * The cursor location where you began replacing characters.\n   */\n  public replaceCursorStartPosition: Position;\n\n  public originalChars: string[] = [];\n\n  /**\n   * The characters the user inserted in replace mode. Useful for when\n   * we repeat a replace action with .\n   */\n  public newChars: string[] = [];\n\n  /**\n   * Number of times we're going to repeat this replace action.\n   */\n  public timesToRepeat: number;\n\n  constructor(vimState: VimState, startPosition: Position, timesToRepeat: number = 1) {\n    this.replaceCursorStartPosition = startPosition;\n    this.timesToRepeat = timesToRepeat;\n\n    const text = vimState.document.lineAt(startPosition).text.substring(startPosition.character);\n    for (const [key, value] of text.split('').entries()) {\n      this.originalChars[key + startPosition.character] = value;\n    }\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nimport { configuration } from '../configuration/configuration';\nimport { PositionDiff } from './../common/motion/position';\nimport { Mode } from './../mode/mode';\n\nexport enum SearchDirection {\n  Forward = 1,\n  Backward = -1,\n}\n\n// Older browsers don't support lookbehind - in this case, use an inferior regex rather than crashing\nlet supportsLookbehind = true;\ntry {\n  // tslint:disable-next-line\n  new RegExp('(?<=x)');\n} catch {\n  supportsLookbehind = false;\n}\n\n/**\n * State involved with beginning a search (/).\n */\nexport class SearchState {\n  private static readonly MAX_SEARCH_RANGES = 1000;\n\n  private static readonly specialCharactersRegex = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n  private static readonly caseOverrideRegex = /\\\\[Cc]/g;\n  private static readonly notEscapedSlashRegex = supportsLookbehind\n    ? new RegExp('(?<=[^\\\\\\\\])\\\\/', 'g')\n    : /\\//g;\n  private static readonly notEscapedQuestionMarkRegex = supportsLookbehind\n    ? new RegExp('(?<=[^\\\\\\\\])\\\\?', 'g')\n    : /\\?/g;\n  private static readonly searchOffsetBeginRegex = /b(\\+-)?[0-9]*/;\n  private static readonly searchOffsetEndRegex = /e(\\+-)?[0-9]*/;\n\n  public readonly previousMode: Mode;\n  public readonly searchDirection: SearchDirection;\n  public readonly cursorStartPosition: Position;\n\n  /**\n   * Every range in the document that matches the search string.\n   */\n  public getMatchRanges(editor: vscode.TextEditor): vscode.Range[] {\n    return this.recalculateSearchRanges(editor);\n  }\n  private matchRanges: Map<string, { version: number; ranges: vscode.Range[] }> = new Map();\n\n  /**\n   * Whether the needle should be interpreted as a regular expression\n   */\n  private readonly isRegex: boolean;\n\n  /**\n   * If true, an all-lowercase needle will not be treated as case-insensitive, even if smartcase is enabled.\n   * This is used for [g]* and [g]#.\n   */\n  private readonly ignoreSmartcase: boolean;\n\n  /**\n   * The string being searched for\n   */\n  private needle = '';\n\n  // How to adjust the cursor's position after going to a match\n  // Some examples:\n  //   /abc/3 will jump to the third character after finding abc\n  //   /abc/b-2 will go 2 characters to the left after finding abc\n  //   /abc/e2 will go 2 characters to the right from the end of abc after finding it\n  // TODO: support the ; offset (see http://vimdoc.sourceforge.net/htmldoc/pattern.html)\n  private offset?: {\n    type: 'line' | 'beginning' | 'end';\n    num: number;\n  };\n\n  /**\n   * The raw string being searched for, including both the needle and search offset\n   */\n  private _searchString = '';\n  public get searchString(): string {\n    return this._searchString;\n  }\n\n  public set searchString(search: string) {\n    if (this._searchString !== search) {\n      this._searchString = search;\n\n      const oldNeedle = this.needle;\n      this.needle = search;\n      this.offset = undefined;\n\n      const needleSegments =\n        this.searchDirection === SearchDirection.Backward\n          ? search.split(SearchState.notEscapedQuestionMarkRegex)\n          : search.split(SearchState.notEscapedSlashRegex);\n      if (needleSegments.length > 1) {\n        this.needle = needleSegments[0];\n        const num = Number(needleSegments[1]);\n        if (isNaN(num)) {\n          if (SearchState.searchOffsetBeginRegex.test(needleSegments[1])) {\n            this.offset = {\n              type: 'beginning',\n              num: Number(needleSegments[1].slice(1)),\n            };\n          } else if (SearchState.searchOffsetEndRegex.test(needleSegments[1])) {\n            this.offset = {\n              type: 'end',\n              num: Number(needleSegments[1].slice(1)),\n            };\n          }\n        } else {\n          this.offset = {\n            type: 'line',\n            num,\n          };\n        }\n      }\n\n      if (this.needle !== oldNeedle) {\n        // Invalidate all cached results\n        this.matchRanges.clear();\n\n        this._needleRegex = undefined;\n      }\n    }\n  }\n\n  private _needleRegex: RegExp | undefined;\n  private get needleRegex(): RegExp {\n    if (this._needleRegex) {\n      return this._needleRegex;\n    }\n\n    /*\n     * Decide whether the search is case sensitive.\n     * If ignorecase is false, the search is case sensitive.\n     * If ignorecase is true, the search should be case insensitive.\n     * If both ignorecase and smartcase are true, the search is case sensitive only when the search string contains UpperCase character.\n     */\n    let ignorecase = configuration.ignorecase;\n    if (\n      ignorecase &&\n      configuration.smartcase &&\n      !this.ignoreSmartcase &&\n      /[A-Z]/.test(this.needle)\n    ) {\n      ignorecase = false;\n    }\n\n    let searchRE = this.needle;\n    const ignorecaseOverride = this.needle.match(SearchState.caseOverrideRegex);\n    if (ignorecaseOverride) {\n      // Vim strips all \\c's but uses the behavior of the first one.\n      searchRE = this.needle.replace(SearchState.caseOverrideRegex, '');\n      ignorecase = ignorecaseOverride[0][1] === 'c';\n    }\n\n    if (!this.isRegex) {\n      searchRE = this.needle.replace(SearchState.specialCharactersRegex, '\\\\$&');\n    }\n\n    const regexFlags = ignorecase ? 'gim' : 'gm';\n\n    try {\n      this._needleRegex = new RegExp(searchRE, regexFlags);\n    } catch (err) {\n      // Couldn't compile the regexp, try again with special characters escaped\n      searchRE = this.needle.replace(SearchState.specialCharactersRegex, '\\\\$&');\n      this._needleRegex = new RegExp(searchRE, regexFlags);\n    }\n\n    return this._needleRegex;\n  }\n\n  private recalculateSearchRanges(editor: vscode.TextEditor): vscode.Range[] {\n    if (this.needle === '') {\n      return [];\n    }\n\n    const document = editor.document;\n\n    const cached = this.matchRanges.get(document.fileName);\n    if (cached?.version === document.version) {\n      return cached.ranges;\n    }\n\n    // We store the entire text file as a string inside text, and run the\n    // regex against it many times to find all of our matches.\n    const text = document.getText();\n    const selection = editor.selection;\n    const startOffset = document.offsetAt(selection.active);\n    const regex = this.needleRegex;\n    regex.lastIndex = startOffset;\n\n    let result: RegExpExecArray | null;\n    let wrappedOver = false;\n    const matchRanges = [] as vscode.Range[];\n    while (true) {\n      result = regex.exec(text);\n\n      if (result) {\n        if (wrappedOver && result.index >= startOffset) {\n          // We've found our first match again\n          break;\n        }\n\n        matchRanges.push(\n          new vscode.Range(\n            document.positionAt(result.index),\n            document.positionAt(result.index + result[0].length)\n          )\n        );\n\n        if (matchRanges.length >= SearchState.MAX_SEARCH_RANGES) {\n          break;\n        }\n\n        // This happens when you find a zero-length match\n        if (result.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n      } else if (!wrappedOver) {\n        // We need to wrap around to the back if we reach the end.\n        regex.lastIndex = 0;\n        wrappedOver = true;\n      } else {\n        break;\n      }\n    }\n\n    // TODO: we know the order of matches; this sort is lazy and could become a bottleneck if we increase the max # of matches\n    matchRanges.sort((x, y) => (x.start.isBefore(y.start) ? -1 : 1));\n    this.matchRanges.set(document.fileName, {\n      version: document.version,\n      ranges: matchRanges,\n    });\n    return matchRanges;\n  }\n\n  /**\n   * The position of the next search.\n   * match == false if there is no match.\n   *\n   * Pass in -1 as direction to reverse the direction we search.\n   */\n  public getNextSearchMatchPosition(\n    editor: vscode.TextEditor,\n    startPosition: Position,\n    direction = SearchDirection.Forward\n  ): { pos: Position; match: boolean; index: number } | undefined {\n    const nextMatch = this.getNextSearchMatchRange(editor, startPosition, direction);\n    if (nextMatch === undefined) {\n      return undefined;\n    }\n    const { start, end, match, index } = nextMatch;\n\n    let pos = start;\n    if (this.offset) {\n      if (this.offset.type === 'line') {\n        pos = start.add(editor.document, PositionDiff.newBOLDiff(this.offset.num));\n      } else if (this.offset.type === 'beginning') {\n        pos = start.getOffsetThroughLineBreaks(this.offset.num);\n      } else if (this.offset.type === 'end') {\n        pos = end.getOffsetThroughLineBreaks(this.offset.num - 1);\n      }\n    }\n\n    return { pos, match, index };\n  }\n\n  /**\n   * The position of the next search.\n   * match == false if there is no match.\n   *\n   * Pass in -1 as direction to reverse the direction we search.\n   *\n   * end is exclusive; which means the index is start + matchedString.length\n   */\n  public getNextSearchMatchRange(\n    editor: vscode.TextEditor,\n    startPosition: Position,\n    direction = SearchDirection.Forward\n  ): { start: Position; end: Position; match: boolean; index: number } | undefined {\n    const matchRanges = this.recalculateSearchRanges(editor);\n\n    if (matchRanges.length === 0) {\n      // TODO(bell)\n      return { start: startPosition, end: startPosition, match: false, index: -1 };\n    }\n\n    const effectiveDirection = (direction * this.searchDirection) as SearchDirection;\n\n    if (effectiveDirection === SearchDirection.Forward) {\n      for (const [index, matchRange] of matchRanges.entries()) {\n        if (matchRange.start.isAfter(startPosition)) {\n          return {\n            start: matchRange.start,\n            end: matchRange.end,\n            match: true,\n            index,\n          };\n        }\n      }\n      // We've hit the bottom of the file. Wrap around if configured to do so, or return undefined.\n      // TODO(bell)\n      if (configuration.wrapscan) {\n        const range = matchRanges[0];\n        return {\n          start: range.start,\n          end: range.end,\n          match: true,\n          index: 0,\n        };\n      } else {\n        return undefined;\n      }\n    } else {\n      for (const [index, matchRange] of matchRanges.slice(0).reverse().entries()) {\n        if (matchRange.end.isBeforeOrEqual(startPosition)) {\n          return {\n            start: matchRange.start,\n            end: matchRange.end,\n            match: true,\n            index: matchRanges.length - index - 1,\n          };\n        }\n      }\n\n      // We've hit the top of the file. Wrap around if configured to do so, or return undefined.\n      // TODO(bell)\n      if (configuration.wrapscan) {\n        const range = matchRanges[matchRanges.length - 1];\n        return {\n          start: range.start,\n          end: range.end,\n          match: true,\n          index: matchRanges.length - 1,\n        };\n      } else {\n        return undefined;\n      }\n    }\n  }\n\n  public getSearchMatchRangeOf(\n    editor: vscode.TextEditor,\n    pos: Position\n  ): { start: Position; end: Position; match: boolean; index: number } {\n    const matchRanges = this.recalculateSearchRanges(editor);\n\n    if (matchRanges.length === 0) {\n      // TODO(bell)\n      return { start: pos, end: pos, match: false, index: -1 };\n    }\n\n    for (const [index, matchRange] of matchRanges.entries()) {\n      if (matchRange.start.isBeforeOrEqual(pos) && matchRange.end.isAfter(pos)) {\n        return {\n          start: matchRange.start,\n          end: matchRange.end,\n          match: true,\n          index,\n        };\n      }\n    }\n\n    // TODO(bell)\n    return { start: pos, end: pos, match: false, index: -1 };\n  }\n\n  constructor(\n    direction: SearchDirection,\n    startPosition: Position,\n    searchString = '',\n    { isRegex = false, ignoreSmartcase = false } = {},\n    currentMode: Mode\n  ) {\n    this.searchDirection = direction;\n    this.cursorStartPosition = startPosition;\n    this.isRegex = isRegex;\n    this.ignoreSmartcase = ignoreSmartcase;\n    this.searchString = searchString;\n    this.previousMode = currentMode;\n  }\n}\n","/**\n * State involved with Substitution commands (:s).\n */\nexport class SubstituteState {\n  /**\n   * The last pattern searched for in the substitution\n   */\n  public searchPattern: string;\n\n  /**\n   * The last replacement string in the substitution\n   */\n  public replaceString: string;\n\n  constructor(searchPattern: string, replaceString: string) {\n    this.searchPattern = searchPattern;\n    this.replaceString = replaceString;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { IMovement } from '../actions/baseMotion';\nimport { configuration } from '../configuration/configuration';\nimport { IEasyMotion } from '../actions/plugins/easymotion/types';\nimport { EditorIdentity } from './../editorIdentity';\nimport { HistoryTracker } from './../history/historyTracker';\nimport { Logger } from '../util/logger';\nimport { Mode } from '../mode/mode';\nimport { Range } from './../common/motion/range';\nimport { RecordedState } from './recordedState';\nimport { RegisterMode } from './../register/register';\nimport { ReplaceState } from './../state/replaceState';\nimport { SurroundState } from '../actions/plugins/surround';\nimport { SUPPORT_NVIM, SUPPORT_IME_SWITCHER } from 'platform/constants';\nimport { Position } from 'vscode';\n\ninterface IInputMethodSwitcher {\n  switchInputMethod(prevMode: Mode, newMode: Mode): Promise<void>;\n}\n\ninterface IBaseMovement {\n  execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement>;\n}\n\ninterface INVim {\n  run(vimState: VimState, command: string): Promise<{ statusBarText: string; error: boolean }>;\n\n  dispose(): void;\n}\n\n/**\n * The VimState class holds permanent state that carries over from action\n * to action.\n *\n * Actions defined in actions.ts are only allowed to mutate a VimState in order to\n * indicate what they want to do.\n *\n * Each ModeHandler holds a VimState, so there is one for each open editor.\n */\nexport class VimState implements vscode.Disposable {\n  private static readonly logger = Logger.get('VimState');\n\n  /**\n   * The column the cursor wants to be at, or Number.POSITIVE_INFINITY if it should always\n   * be the rightmost column.\n   *\n   * Example: If you go to the end of a 20 character column, this value\n   * will be 20, even if you press j and the next column is only 5 characters.\n   * This is because if the third column is 25 characters, the cursor will go\n   * back to the 20th column.\n   */\n  public desiredColumn = 0;\n\n  public historyTracker: HistoryTracker;\n\n  public easyMotion: IEasyMotion;\n\n  public identity: EditorIdentity;\n\n  public editor: vscode.TextEditor;\n\n  public get document(): vscode.TextDocument {\n    return this.editor.document;\n  }\n\n  /**\n   * Are multiple cursors currently present?\n   */\n  // TODO: why isn't this a function?\n  public isMultiCursor = false;\n\n  /**\n   * Is the multicursor something like visual block \"multicursor\", where\n   * natively in vim there would only be one cursor whose changes were applied\n   * to all lines after edit.\n   */\n  public isFakeMultiCursor = false;\n\n  /**\n   * Tracks movements that can be repeated with ; (e.g. t, T, f, and F).\n   */\n  public lastSemicolonRepeatableMovement: IBaseMovement | undefined = undefined;\n\n  /**\n   * Tracks movements that can be repeated with , (e.g. t, T, f, and F).\n   */\n  public lastCommaRepeatableMovement: IBaseMovement | undefined = undefined;\n\n  // TODO: move into ModeHandler\n  public lastMovementFailed: boolean = false;\n\n  public alteredHistory = false;\n\n  public isRunningDotCommand = false;\n  public isReplayingMacro: boolean = false;\n\n  /**\n   * The last visual selection before running the dot command\n   */\n  public dotCommandPreviousVisualSelection: vscode.Selection | undefined = undefined;\n\n  /**\n   * The first line number that was visible when SearchInProgressMode began (undefined if not searching)\n   */\n  public firstVisibleLineBeforeSearch: number | undefined = undefined;\n\n  // TODO: move into ModeHandler\n  public focusChanged = false;\n\n  public surround: SurroundState | undefined = undefined;\n\n  /**\n   * Used for `<C-o>` in insert mode, which allows you run one normal mode\n   * command, then go back to insert mode.\n   */\n  public returnToInsertAfterCommand = false;\n  public actionCount = 0;\n\n  /**\n   * Every time we invoke a VSCode command which might trigger a view update.\n   * We should postpone its view updating phase to avoid conflicting with our internal view updating mechanism.\n   * This array is used to cache every VSCode view updating event and they will be triggered once we run the inhouse `viewUpdate`.\n   */\n  public postponedCodeViewChanges: ViewChange[] = [];\n\n  /**\n   * All the keys we've pressed so far.\n   */\n  public keyHistory: string[] = [];\n\n  /**\n   * The cursor position (start, stop) when this action finishes.\n   */\n  public get cursorStartPosition(): Position {\n    return this.cursors[0].start;\n  }\n  public set cursorStartPosition(value: Position) {\n    if (!value.isValid(this.editor)) {\n      VimState.logger.warn(`invalid cursor start position. ${value.toString()}.`);\n    }\n    this.cursors[0] = this.cursors[0].withNewStart(value);\n  }\n\n  public get cursorStopPosition(): Position {\n    return this.cursors[0].stop;\n  }\n  public set cursorStopPosition(value: Position) {\n    if (!value.isValid(this.editor)) {\n      VimState.logger.warn(`invalid cursor stop position. ${value.toString()}.`);\n    }\n    this.cursors[0] = this.cursors[0].withNewStop(value);\n  }\n\n  /**\n   * The position of every cursor. Will never be empty.\n   */\n  private _cursors: Range[] = [new Range(new Position(0, 0), new Position(0, 0))];\n\n  public get cursors(): Range[] {\n    return this._cursors;\n  }\n  public set cursors(value: Range[]) {\n    if (value.length === 0) {\n      VimState.logger.warn('Tried to set VimState.cursors to an empty array');\n      return;\n    }\n\n    const map = new Map<string, Range>();\n    for (const cursor of value) {\n      if (!cursor.isValid(this.editor)) {\n        VimState.logger.warn(`invalid cursor position. ${cursor.toString()}.`);\n      }\n\n      // use a map to ensure no two cursors are at the same location.\n      map.set(cursor.toString(), cursor);\n    }\n\n    this._cursors = [...map.values()];\n    this.isMultiCursor = this._cursors.length > 1;\n  }\n\n  /**\n   * Initial state of cursors prior to any action being performed\n   */\n  private _cursorsInitialState: Range[];\n  public get cursorsInitialState(): Range[] {\n    return this._cursorsInitialState;\n  }\n  public set cursorsInitialState(cursors: Range[]) {\n    this._cursorsInitialState = [...cursors];\n  }\n\n  public replaceState: ReplaceState | undefined = undefined;\n\n  /**\n   * Stores last visual mode as well as what was selected for `gv`\n   */\n  public lastVisualSelection:\n    | {\n        mode: Mode;\n        start: Position;\n        end: Position;\n      }\n    | undefined = undefined;\n\n  /**\n   * Was the previous mouse click past EOL\n   */\n  public lastClickWasPastEol: boolean = false;\n\n  /**\n   * Used internally to ignore selection changes that were performed by us.\n   * 'ignoreIntermediateSelections': set to true when running an action, during this time\n   * all selections change events will be ignored.\n   * 'ourSelections': keeps track of our selections that will trigger a selection change event\n   * so that we can ignore them.\n   */\n  public selectionsChanged = {\n    /**\n     * Set to true when running an action, during this time\n     * all selections change events will be ignored.\n     */\n    ignoreIntermediateSelections: false,\n    /**\n     * keeps track of our selections that will trigger a selection change event\n     * so that we can ignore them.\n     */\n    ourSelections: Array<string>(),\n  };\n\n  /**\n   * The mode Vim will be in once this action finishes.\n   */\n  private _currentMode: Mode = Mode.Normal;\n\n  public get currentMode(): Mode {\n    return this._currentMode;\n  }\n\n  private _inputMethodSwitcher?: IInputMethodSwitcher;\n  /**\n   * The mode Vim is currently including pseudo-modes like OperatorPendingMode\n   * This is to be used only by the Remappers when getting the remappings so don't\n   * use it anywhere else.\n   */\n  public get currentModeIncludingPseudoModes(): Mode {\n    return this.recordedState.isOperatorPending(this._currentMode)\n      ? Mode.OperatorPendingMode\n      : this._currentMode;\n  }\n\n  public async setCurrentMode(mode: Mode): Promise<void> {\n    await this._inputMethodSwitcher?.switchInputMethod(this._currentMode, mode);\n    if (this.returnToInsertAfterCommand && mode === Mode.Insert) {\n      this.returnToInsertAfterCommand = false;\n    }\n    this._currentMode = mode;\n\n    if (configuration.smartRelativeLine) {\n      this.editor.options.lineNumbers =\n        mode === Mode.Insert\n          ? vscode.TextEditorLineNumbersStyle.On\n          : vscode.TextEditorLineNumbersStyle.Relative;\n    }\n\n    if (mode === Mode.SearchInProgressMode) {\n      this.firstVisibleLineBeforeSearch = this.editor.visibleRanges[0].start.line;\n    } else {\n      this.firstVisibleLineBeforeSearch = undefined;\n    }\n  }\n\n  public currentRegisterMode = RegisterMode.AscertainFromCurrentMode;\n\n  public get effectiveRegisterMode(): RegisterMode {\n    if (this.currentRegisterMode !== RegisterMode.AscertainFromCurrentMode) {\n      return this.currentRegisterMode;\n    }\n    switch (this.currentMode) {\n      case Mode.VisualLine:\n        return RegisterMode.LineWise;\n      case Mode.VisualBlock:\n        return RegisterMode.BlockWise;\n      default:\n        return RegisterMode.CharacterWise;\n    }\n  }\n\n  public currentCommandlineText = '';\n  public statusBarCursorCharacterPos = 0;\n\n  public recordedState = new RecordedState();\n\n  /** The macro currently being recorded, if one exists. */\n  public macro: RecordedState | undefined;\n\n  public lastInvokedMacro: RecordedState | undefined;\n\n  public nvim?: INVim;\n\n  public constructor(editor: vscode.TextEditor, easyMotion: IEasyMotion) {\n    this.editor = editor;\n    this.identity = EditorIdentity.fromEditor(editor);\n    this.historyTracker = new HistoryTracker(this);\n    this.easyMotion = easyMotion;\n  }\n\n  async load() {\n    if (SUPPORT_NVIM) {\n      const m = await import('../neovim/neovim');\n      this.nvim = new m.NeovimWrapper();\n    }\n\n    if (SUPPORT_IME_SWITCHER) {\n      const ime = await import('../actions/plugins/imswitcher');\n      this._inputMethodSwitcher = new ime.InputMethodSwitcher();\n    }\n  }\n\n  dispose() {\n    this.nvim?.dispose();\n  }\n}\n\nexport class ViewChange {\n  public command: string;\n  public args: any;\n}\n","import * as vscode from 'vscode';\nimport { Mode } from './mode/mode';\nimport { globalState } from './state/globalState';\nimport { SearchDirection } from './state/searchState';\nimport { configuration } from './configuration/configuration';\nimport { VimState } from './state/vimState';\nimport { Logger } from './util/logger';\nimport { VimError } from './error';\n\nclass StatusBarImpl implements vscode.Disposable {\n  // Displays the current state (mode, recording macro, etc.) and messages to the user\n  private _statusBarItem: vscode.StatusBarItem;\n\n  // Displays the keys you've typed so far when they haven't yet resolved to a command\n  private _recordedStateStatusBarItem: vscode.StatusBarItem;\n\n  private _previousModeName: Mode | undefined = undefined;\n  private _showingDefaultMessage = true;\n\n  constructor() {\n    this._statusBarItem = vscode.window.createStatusBarItem(\n      vscode.StatusBarAlignment.Left,\n      Number.MIN_SAFE_INTEGER // Furthest right on the left\n    );\n    this._statusBarItem.show();\n\n    this._recordedStateStatusBarItem = vscode.window.createStatusBarItem(\n      vscode.StatusBarAlignment.Right,\n      Number.MAX_SAFE_INTEGER // Furthest left on the right\n    );\n    this._recordedStateStatusBarItem.show();\n  }\n\n  dispose() {\n    this._statusBarItem.dispose();\n    this._recordedStateStatusBarItem.dispose();\n  }\n\n  public updateShowCmd(vimState: VimState) {\n    this._recordedStateStatusBarItem.text = configuration.showcmd\n      ? statusBarCommandText(vimState)\n      : '';\n  }\n\n  /**\n   * Updates the status bar text\n   * @param isError If true, text rendered in red\n   */\n  public setText(vimState: VimState, text: string, isError = false) {\n    const hasModeChanged = vimState.currentMode !== this._previousModeName;\n\n    // Text\n    this.updateText(text);\n\n    // Foreground color\n    if (!configuration.statusBarColorControl) {\n      this._statusBarItem.color = isError ? new vscode.ThemeColor('errorForeground') : undefined;\n    }\n\n    // Background color\n    const shouldUpdateColor = configuration.statusBarColorControl && hasModeChanged;\n    if (shouldUpdateColor) {\n      this.updateColor(vimState.currentMode);\n    }\n\n    this._previousModeName = vimState.currentMode;\n    this._showingDefaultMessage = false;\n  }\n\n  public displayError(vimState: VimState, error: VimError) {\n    StatusBar.setText(vimState, error.toString(), true);\n  }\n\n  public getText() {\n    return this._statusBarItem.text.replace(/\\^M/g, '\\n');\n  }\n\n  /**\n   * Clears any messages from the status bar, leaving the default info, such as\n   * the current mode and macro being recorded.\n   * @param force If true, will clear even high priority messages like errors.\n   */\n  public clear(vimState: VimState, force = true) {\n    if (!this._showingDefaultMessage && !force) {\n      return;\n    }\n\n    const text: string[] = [];\n\n    if (configuration.showmodename) {\n      text.push(statusBarText(vimState));\n      if (vimState.isMultiCursor) {\n        text.push(' MULTI CURSOR ');\n      }\n    }\n\n    if (vimState.macro) {\n      const macroText = 'Recording @' + vimState.macro.registerName;\n      text.push(macroText);\n    }\n\n    StatusBar.setText(vimState, text.join(' '));\n\n    this._showingDefaultMessage = true;\n  }\n\n  private updateText(text: string) {\n    const escaped = text.replace(/\\n/g, '^M');\n    this._statusBarItem.text = escaped || '';\n  }\n\n  private updateColor(mode: Mode) {\n    let foreground: string | undefined;\n    let background: string | undefined;\n\n    const colorToSet = configuration.statusBarColors[Mode[mode].toLowerCase()];\n\n    if (colorToSet !== undefined) {\n      if (typeof colorToSet === 'string') {\n        background = colorToSet;\n      } else {\n        [background, foreground] = colorToSet;\n      }\n    }\n\n    const workbenchConfiguration = configuration.getConfiguration('workbench');\n    const currentColorCustomizations: {\n      [index: string]: string;\n    } = workbenchConfiguration.get('colorCustomizations') ?? {};\n\n    const colorCustomizations = { ...currentColorCustomizations };\n\n    // If colors are undefined, return to VSCode defaults\n    if (background !== undefined) {\n      colorCustomizations['statusBar.background'] = background;\n      colorCustomizations['statusBar.noFolderBackground'] = background;\n      colorCustomizations['statusBar.debuggingBackground'] = background;\n    }\n\n    if (foreground !== undefined) {\n      colorCustomizations['statusBar.foreground'] = foreground;\n    }\n\n    if (currentColorCustomizations !== colorCustomizations) {\n      workbenchConfiguration.update('colorCustomizations', colorCustomizations, true);\n    }\n  }\n}\n\nexport const StatusBar = new StatusBarImpl();\n\nexport function statusBarText(vimState: VimState) {\n  const cursorChar =\n    vimState.recordedState.actionKeys[vimState.recordedState.actionKeys.length - 1] === '<C-r>'\n      ? '\"'\n      : '|';\n  switch (vimState.currentMode) {\n    case Mode.Normal:\n      return '-- NORMAL --';\n    case Mode.Insert:\n      return '-- INSERT --';\n    case Mode.Visual:\n      return '-- VISUAL --';\n    case Mode.VisualBlock:\n      return '-- VISUAL BLOCK --';\n    case Mode.VisualLine:\n      return '-- VISUAL LINE --';\n    case Mode.Replace:\n      return '-- REPLACE --';\n    case Mode.EasyMotionMode:\n      return '-- EASYMOTION --';\n    case Mode.EasyMotionInputMode:\n      return '-- EASYMOTION INPUT --';\n    case Mode.SurroundInputMode:\n      return '-- SURROUND INPUT --';\n    case Mode.Disabled:\n      return '-- VIM: DISABLED --';\n    case Mode.SearchInProgressMode:\n      if (globalState.searchState === undefined) {\n        const logger = Logger.get('StatusBar');\n        logger.warn(`globalState.searchState is undefined in SearchInProgressMode.`);\n        return '';\n      }\n      const leadingChar =\n        globalState.searchState.searchDirection === SearchDirection.Forward ? '/' : '?';\n\n      const searchWithCursor = globalState.searchState.searchString.split('');\n      searchWithCursor.splice(vimState.statusBarCursorCharacterPos, 0, cursorChar);\n\n      return `${leadingChar}${searchWithCursor.join('')}`;\n    case Mode.CommandlineInProgress:\n      const commandWithCursor = vimState.currentCommandlineText.split('');\n      commandWithCursor.splice(vimState.statusBarCursorCharacterPos, 0, cursorChar);\n\n      return `:${commandWithCursor.join('')}`;\n    default:\n      return '';\n  }\n}\n\nexport function statusBarCommandText(vimState: VimState): string {\n  switch (vimState.currentMode) {\n    case Mode.SurroundInputMode:\n      return vimState.surround && vimState.surround.replacement\n        ? vimState.surround.replacement\n        : '';\n    case Mode.EasyMotionMode:\n      return `Target key: ${vimState.easyMotion.accumulation}`;\n    case Mode.EasyMotionInputMode:\n      if (!vimState.easyMotion) {\n        return '';\n      }\n\n      const searchCharCount = vimState.easyMotion.searchAction.searchCharCount;\n      const message =\n        searchCharCount > 0\n          ? `Search for ${searchCharCount} character(s): `\n          : 'Search for characters: ';\n      return message + vimState.easyMotion.searchAction.searchString;\n    case Mode.Visual: {\n      // TODO: holy shit, this is SO much more complicated than it should be because\n      // our representation of a visual selection is so weird and inconsistent\n      let [start, end] = [vimState.cursorStartPosition, vimState.cursorStopPosition];\n      let wentOverEOL = false;\n      if (start.isAfter(end)) {\n        start = start.getRightThroughLineBreaks();\n        [start, end] = [end, start];\n      } else if (end.isAfter(start) && end.character === 0) {\n        end = end.getLeftThroughLineBreaks(true);\n        wentOverEOL = true;\n      }\n      const lines = end.line - start.line + 1;\n      if (lines > 1) {\n        return `${lines} ${vimState.recordedState.pendingCommandString}`;\n      } else {\n        const chars = Math.max(end.character - start.character, 1) + (wentOverEOL ? 1 : 0);\n        return `${chars} ${vimState.recordedState.pendingCommandString}`;\n      }\n    }\n    case Mode.VisualLine:\n      return `${\n        Math.abs(vimState.cursorStopPosition.line - vimState.cursorStartPosition.line) + 1\n      } ${vimState.recordedState.pendingCommandString}`;\n    case Mode.VisualBlock: {\n      const lines =\n        Math.abs(vimState.cursorStopPosition.line - vimState.cursorStartPosition.line) + 1;\n      const chars =\n        Math.abs(vimState.cursorStopPosition.character - vimState.cursorStartPosition.character) +\n        1;\n      return `${lines}x${chars} ${vimState.recordedState.pendingCommandString}`;\n    }\n    case Mode.Insert:\n    case Mode.Replace:\n      return vimState.recordedState.pendingCommandString;\n    case Mode.Normal:\n    case Mode.Disabled:\n      return vimState.recordedState.commandString;\n    default:\n      return '';\n  }\n}\n","import * as vscode from 'vscode';\nimport { Logger } from './util/logger';\nimport { extensionVersion } from './configuration/configuration';\n\ninterface IEnqueuedTask {\n  promise: () => Promise<void>;\n  isRunning: boolean;\n  queue: string;\n  isHighPriority: boolean;\n}\n\nclass TaskQueue {\n  private readonly _logger = Logger.get('TaskQueue');\n  private readonly _taskQueue: {\n    [key: string]: {\n      tasks: IEnqueuedTask[];\n    };\n  } = {};\n\n  private isRunning(queueName: string): boolean {\n    return this._taskQueue[queueName] && this._taskQueue[queueName].tasks.some((x) => x.isRunning);\n  }\n\n  private numHighPriority(queueName: string): number {\n    if (!this._taskQueue[queueName]) {\n      return 0;\n    }\n    return this._taskQueue[queueName].tasks.filter((x) => x.isHighPriority).length;\n  }\n\n  private async runTasks(queueName: string): Promise<void> {\n    while (this._taskQueue[queueName].tasks.length > 0) {\n      const task: IEnqueuedTask = this._taskQueue[queueName].tasks[0];\n\n      try {\n        task.isRunning = true;\n        await task.promise();\n        task.isRunning = false;\n      } catch (e) {\n        if (e instanceof Error) {\n          const reportButton = 'Report bug';\n          const stack = e.stack;\n          vscode.window\n            .showErrorMessage(e.message, reportButton)\n            .then((picked: string | undefined) => {\n              if (picked === reportButton) {\n                let body = `**To Reproduce**\\nSteps to reproduce the behavior:\\n\\n1.  Go to '...'\\n2.  Click on '....'\\n3.  Scroll down to '....'\\n4.  See error\\n\\n**VSCodeVim version**: ${extensionVersion}`;\n                if (stack) {\n                  body += `\\n\\n<details><summary>Stack trace</summary>\\n\\n\\`\\`\\`\\n${stack}\\n\\`\\`\\`\\n\\n</details>`;\n                }\n                vscode.commands.executeCommand(\n                  'vscode.open',\n                  vscode.Uri.parse(\n                    `https://github.com/VSCodeVim/Vim/issues/new?title=${e.message}&body=${body}`\n                  )\n                );\n              }\n            });\n        } else {\n          this._logger.error(`Error running task due to an unknown error: ${e}.`);\n        }\n      } finally {\n        this.dequeueTask(task);\n      }\n    }\n  }\n\n  /**\n   * Dequeues a task from the task queue.\n   *\n   * Note: If the task is already running, the semantics of\n   *       promises don't allow you to stop it.\n   */\n  private dequeueTask(task: IEnqueuedTask): void {\n    this._taskQueue[task.queue].tasks = this._taskQueue[task.queue].tasks.filter((t) => t !== task);\n  }\n\n  /**\n   * Adds a task to the task queue.\n   */\n  public enqueueTask(\n    action: () => Promise<void>,\n    queueName: string = 'default',\n    isHighPriority: boolean = false\n  ): void {\n    const task: IEnqueuedTask = {\n      promise: action,\n      queue: queueName,\n      isHighPriority,\n      isRunning: false,\n    };\n\n    if (!this._taskQueue[queueName]) {\n      this._taskQueue[queueName] = {\n        tasks: [],\n      };\n    }\n\n    if (isHighPriority) {\n      // Insert task as the last high priority task.\n      const numHighPriority = this.numHighPriority(queueName);\n      this._taskQueue[queueName].tasks.splice(numHighPriority, 0, task);\n    } else {\n      this._taskQueue[queueName].tasks.push(task);\n    }\n\n    if (!this.isRunning(queueName)) {\n      this.runTasks(queueName);\n    }\n  }\n}\n\nexport let taskQueue = new TaskQueue();\n","import * as vscode from 'vscode';\n\nimport { configuration } from './configuration/configuration';\nimport { VimState } from './state/vimState';\nimport { visualBlockGetTopLeftPosition, visualBlockGetBottomRightPosition } from './mode/mode';\nimport { Range } from './common/motion/range';\nimport { Position } from 'vscode';\nimport { Logger } from './util/logger';\n\n/**\n * Collection of helper functions around vscode.window.activeTextEditor\n */\nexport class TextEditor {\n  static readonly whitespaceRegExp = new RegExp('\\\\s+');\n  private static readonly logger = Logger.get('TextEditor');\n\n  // TODO: Refactor args\n\n  /**\n   * @deprecated Use InsertTextTransformation (or InsertTextVSCodeTransformation) instead.\n   */\n  static async insert(\n    editor: vscode.TextEditor,\n    text: string,\n    at?: Position,\n    letVSCodeHandleKeystrokes?: boolean\n  ): Promise<void> {\n    // If we insert \"blah(\" with default:type, VSCode will insert the closing ).\n    // We *probably* don't want that to happen if we're inserting a lot of text.\n    letVSCodeHandleKeystrokes ??= text.length === 1;\n\n    if (!letVSCodeHandleKeystrokes) {\n      // const selections = editor.selections.slice(0);\n\n      await editor.edit((editBuilder) => {\n        if (!at) {\n          at = editor.selection.active;\n        }\n\n        editBuilder.insert(at, text);\n      });\n\n      // maintain all selections in multi-cursor mode.\n      // editor.selections = selections;\n    } else {\n      await vscode.commands.executeCommand('default:type', { text });\n    }\n  }\n\n  /**\n   * @deprecated Use InsertTextTransformation (or InsertTextVSCodeTransformation) instead.\n   */\n  static async insertAt(\n    editor: vscode.TextEditor,\n    text: string,\n    position: Position\n  ): Promise<boolean> {\n    return editor.edit((editBuilder) => {\n      editBuilder.insert(position, text);\n    });\n  }\n\n  /**\n   * @deprecated Use DeleteTextTransformation or DeleteTextRangeTransformation instead.\n   */\n  static async delete(editor: vscode.TextEditor, range: vscode.Range): Promise<boolean> {\n    return editor.edit((editBuilder) => {\n      editBuilder.delete(range);\n    });\n  }\n\n  /**\n   * @deprecated. Use ReplaceTextTransformation instead.\n   */\n  static async replace(\n    editor: vscode.TextEditor,\n    range: vscode.Range,\n    text: string\n  ): Promise<boolean> {\n    return editor.edit((editBuilder) => {\n      editBuilder.replace(range, text);\n    });\n  }\n\n  /** @deprecated Use vimState.document.lineCount */\n  static getLineCount(textEditor?: vscode.TextEditor): number {\n    textEditor ??= vscode.window.activeTextEditor;\n    return textEditor?.document.lineCount ?? -1;\n  }\n\n  public static getLineLength(line: number): number {\n    if (line < 0 || line >= TextEditor.getLineCount()) {\n      this.logger.warn(`getLineLength() called with out-of-bounds line ${line}`);\n      return 0;\n    }\n\n    return vscode.window.activeTextEditor!.document.lineAt(line).text.length;\n  }\n\n  /** @deprecated Use `vimState.document.lineAt()` directly */\n  static getLine(lineNumber: number): vscode.TextLine {\n    return vscode.window.activeTextEditor!.document.lineAt(lineNumber);\n  }\n\n  static getCharAt(document: vscode.TextDocument, position: Position): string {\n    return document.lineAt(position).text[position.character];\n  }\n\n  /**\n   * Retrieves the word at the given position.\n   *\n   * Respects `iskeyword`:\n   *    - Will go right (but not over line boundaries) until it finds a \"real\" word\n   *    - Will settle for a \"fake\" word only if it hits the line end\n   */\n  static getWord(document: vscode.TextDocument, position: Position): string | undefined {\n    const line = document.lineAt(position).text;\n\n    // Skip over whitespace\n    let firstNonBlank = position.character;\n    while (this.whitespaceRegExp.test(line[firstNonBlank])) {\n      firstNonBlank++;\n      if (firstNonBlank === line.length) {\n        // Hit end of line without finding a non-whitespace character\n        return undefined;\n      }\n    }\n\n    // Now skip over word separators and whitespace to find a \"real\" word\n    let start = firstNonBlank;\n    while (\n      configuration.iskeyword.includes(line[start]) ||\n      this.whitespaceRegExp.test(line[start])\n    ) {\n      start++;\n      if (start === line.length) {\n        // No keyword found - just settle for the word we're on\n        start = firstNonBlank;\n        break;\n      }\n    }\n\n    const foundRealWord = !configuration.iskeyword.includes(line[start]);\n    const includeInWord = (char: string) =>\n      !this.whitespaceRegExp.test(char) && configuration.iskeyword.includes(char) !== foundRealWord;\n\n    // Expand left and right to find the whole word\n    let end = start;\n    while (start > 0 && includeInWord(line[start - 1])) {\n      start--;\n    }\n    while (end < line.length && includeInWord(line[end + 1])) {\n      end++;\n    }\n\n    return line.substring(start, end + 1);\n  }\n\n  static getTabCharacter(editor: vscode.TextEditor): string {\n    if (editor.options.insertSpaces) {\n      // This will always be a number when we're getting it from the options\n      const tabSize = editor.options.tabSize as number;\n      return ' '.repeat(tabSize);\n    }\n    return '\\t';\n  }\n\n  /**\n   * @returns the number of visible columns that the given line begins with\n   */\n  static getIndentationLevel(line: string): number {\n    let visibleColumn = 0;\n    for (const char of line) {\n      switch (char) {\n        case '\\t':\n          visibleColumn += configuration.tabstop;\n          break;\n        case ' ':\n          visibleColumn += 1;\n          break;\n        default:\n          return visibleColumn;\n      }\n    }\n\n    return visibleColumn;\n  }\n\n  /**\n   * @returns `line` with its indentation replaced with `screenCharacters` visible columns of whitespace\n   */\n  static setIndentationLevel(line: string, screenCharacters: number): string {\n    const tabSize = configuration.tabstop;\n\n    if (screenCharacters < 0) {\n      screenCharacters = 0;\n    }\n\n    const indentString = configuration.expandtab\n      ? ' '.repeat(screenCharacters)\n      : '\\t'.repeat(screenCharacters / tabSize) + ' '.repeat(screenCharacters % tabSize);\n\n    return line.replace(/^\\s*/, indentString);\n  }\n\n  static getDocumentBegin(): Position {\n    return new Position(0, 0);\n  }\n\n  static getDocumentEnd(document: vscode.TextDocument): Position {\n    const line = Math.max(document.lineCount, 1) - 1;\n    return document.lineAt(line).range.end;\n  }\n\n  /**\n   * @returns the Position of the first character on the given line which is not whitespace.\n   * If it's all whitespace, will return the Position of the EOL character.\n   */\n  public static getFirstNonWhitespaceCharOnLine(\n    document: vscode.TextDocument,\n    line: number\n  ): Position {\n    return new Position(line, document.lineAt(line).firstNonWhitespaceCharacterIndex);\n  }\n\n  /**\n   * Iterate over every line in the block defined by the two positions (Range) passed in.\n   * If no range is given, the primary cursor will be used as the block.\n   *\n   * This is intended for visual block mode.\n   */\n  public static *iterateLinesInBlock(\n    vimState: VimState,\n    range?: Range,\n    options: { reverse?: boolean } = { reverse: false }\n  ): Iterable<{ line: string; start: Position; end: Position }> {\n    const { reverse } = options;\n\n    range ??= vimState.cursors[0];\n\n    const topLeft = visualBlockGetTopLeftPosition(range.start, range.stop);\n    const bottomRight = visualBlockGetBottomRightPosition(range.start, range.stop);\n\n    const [itrStart, itrEnd] = reverse\n      ? [bottomRight.line, topLeft.line]\n      : [topLeft.line, bottomRight.line];\n\n    const runToLineEnd = vimState.desiredColumn === Number.POSITIVE_INFINITY;\n\n    for (\n      let lineIndex = itrStart;\n      reverse ? lineIndex >= itrEnd : lineIndex <= itrEnd;\n      reverse ? lineIndex-- : lineIndex++\n    ) {\n      const line = vimState.document.lineAt(lineIndex).text;\n      const endCharacter = runToLineEnd\n        ? line.length + 1\n        : Math.min(line.length, bottomRight.character + 1);\n\n      yield {\n        line: line.substring(topLeft.character, endCharacter),\n        start: new Position(lineIndex, topLeft.character),\n        end: new Position(lineIndex, endCharacter),\n      };\n    }\n  }\n\n  /**\n   * Iterates through words on the same line, starting from the current position.\n   */\n  public static *iterateWords(\n    document: vscode.TextDocument,\n    start: Position\n  ): Iterable<{ start: Position; end: Position; word: string }> {\n    const text = document.lineAt(start).text;\n    if (/\\s/.test(text[start.character])) {\n      start = start.getWordRight();\n    }\n    let wordEnd = start.getCurrentWordEnd(true);\n    do {\n      const word = text.substring(start.character, wordEnd.character + 1);\n      yield {\n        start,\n        end: wordEnd,\n        word,\n      };\n\n      if (wordEnd.getRight().isLineEnd()) {\n        return;\n      }\n      start = start.getWordRight();\n      wordEnd = start.getCurrentWordEnd(true);\n    } while (true);\n  }\n}\n\n/**\n * Directions in the view for editor scroll command.\n */\nexport type EditorScrollDirection = 'up' | 'down';\n\n/**\n * Units for editor scroll 'by' argument\n */\nexport type EditorScrollByUnit = 'line' | 'wrappedLine' | 'page' | 'halfPage';\n\n/**\n * Positions in the view for cursor move command.\n */\nexport type CursorMovePosition =\n  | 'left'\n  | 'right'\n  | 'up'\n  | 'down'\n  | 'wrappedLineStart'\n  | 'wrappedLineFirstNonWhitespaceCharacter'\n  | 'wrappedLineColumnCenter'\n  | 'wrappedLineEnd'\n  | 'wrappedLineLastNonWhitespaceCharacter'\n  | 'viewPortTop'\n  | 'viewPortCenter'\n  | 'viewPortBottom'\n  | 'viewPortIfOutside';\n\n/**\n * Units for Cursor move 'by' argument\n */\nexport type CursorMoveByUnit = 'line' | 'wrappedLine' | 'character' | 'halfLine';\n","import { Position } from 'vscode';\nimport { TextEditor } from '../textEditor';\n\n/**\n * Get the end of the current paragraph.\n */\nexport function getCurrentParagraphEnd(pos: Position, trimWhite: boolean = false): Position {\n  const lastLine = TextEditor.getLineCount() - 1;\n\n  let line = pos.line;\n\n  // If we're not in a paragraph yet, go down until we are.\n  while (line < lastLine && isLineBlank(line, trimWhite)) {\n    line++;\n  }\n\n  // Go until we're outside of the paragraph, or at the end of the document.\n  while (line < lastLine && !isLineBlank(line, trimWhite)) {\n    line++;\n  }\n\n  return pos.with({ line }).getLineEnd();\n}\n\n/**\n * Get the beginning of the current paragraph.\n */\nexport function getCurrentParagraphBeginning(pos: Position, trimWhite: boolean = false): Position {\n  let line = pos.line;\n\n  // If we're not in a paragraph yet, go up until we are.\n  while (line > 0 && isLineBlank(line, trimWhite)) {\n    line--;\n  }\n\n  // Go until we're outside of the paragraph, or at the beginning of the document.\n  while (line > 0 && !isLineBlank(line, trimWhite)) {\n    line--;\n  }\n\n  return new Position(line, 0);\n}\n\nfunction isLineBlank(line: number, trimWhite: boolean = false): boolean {\n  const text = TextEditor.getLine(line).text;\n  return (trimWhite ? text.trim() : text) === '';\n}\n","import { Position } from 'vscode';\nimport { TextEditor } from '../textEditor';\nimport { getCurrentParagraphBeginning, getCurrentParagraphEnd } from './paragraph';\nimport { getAllPositions, getAllEndPositions } from './util';\n\nconst sentenceEndRegex = /[\\.!\\?]{1}([ \\n\\t]+|$)/g;\n\nexport function getSentenceBegin(position: Position, args: { forward: boolean }): Position {\n  if (args.forward) {\n    return getNextSentenceBegin(position);\n  } else {\n    return getPreviousSentenceBegin(position);\n  }\n}\n\nexport function getSentenceEnd(pos: Position): Position {\n  const paragraphEnd = getCurrentParagraphEnd(pos);\n  for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n    const allPositions = getAllPositions(TextEditor.getLine(currentLine).text, sentenceEndRegex);\n    const newCharacter = allPositions.find(\n      (index) => index > pos.character || currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return getFirstNonWhitespaceInParagraph(pos, paragraphEnd, false);\n}\n\nfunction getPreviousSentenceBegin(pos: Position): Position {\n  const paragraphBegin = getCurrentParagraphBeginning(pos);\n  for (let currentLine = pos.line; currentLine >= paragraphBegin.line; currentLine--) {\n    const endPositions = getAllEndPositions(TextEditor.getLine(currentLine).text, sentenceEndRegex);\n    const newCharacter = endPositions.reverse().find((index) => {\n      const newPositionBeforeThis = new Position(currentLine, index)\n        .getRightThroughLineBreaks()\n        .compareTo(pos);\n\n      return newPositionBeforeThis && (index < pos.character || currentLine < pos.line);\n    });\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter).getRightThroughLineBreaks();\n    }\n  }\n\n  if (paragraphBegin.line + 1 === pos.line || paragraphBegin.line === pos.line) {\n    return paragraphBegin;\n  } else {\n    return new Position(paragraphBegin.line + 1, 0);\n  }\n}\n\nfunction getNextSentenceBegin(pos: Position): Position {\n  // A paragraph and section boundary is also a sentence boundary.\n  const paragraphEnd = getCurrentParagraphEnd(pos);\n  for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n    const endPositions = getAllEndPositions(TextEditor.getLine(currentLine).text, sentenceEndRegex);\n    const newCharacter = endPositions.find(\n      (index) => index > pos.character || currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter).getRightThroughLineBreaks();\n    }\n  }\n\n  return getFirstNonWhitespaceInParagraph(pos, paragraphEnd, false);\n}\n\nfunction getFirstNonWhitespaceInParagraph(\n  pos: Position,\n  paragraphEnd: Position,\n  inclusive: boolean\n): Position {\n  // If the cursor is at an empty line, it's the end of a paragraph and the begin of another paragraph\n  // Find the first non-whitespace character.\n  if (TextEditor.getLine(pos.line).text) {\n    return paragraphEnd;\n  } else {\n    for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n      const nonWhitePositions = getAllPositions(TextEditor.getLine(currentLine).text, /\\S/g);\n      const newCharacter = nonWhitePositions.find(\n        (index) =>\n          (index > pos.character && !inclusive) ||\n          (index >= pos.character && inclusive) ||\n          currentLine !== pos.line\n      );\n\n      if (newCharacter !== undefined) {\n        return new Position(currentLine, newCharacter);\n      }\n    }\n  }\n\n  // Only happens at end of document\n  return pos;\n}\n","import { Range } from '../common/motion/range';\nimport { Mode } from '../mode/mode';\nimport { RegisterMode } from '../register/register';\nimport { VimState } from '../state/vimState';\nimport { TextEditor } from '../textEditor';\nimport { RegisterAction } from '../actions/base';\nimport { BaseMovement, IMovement, failedMovement } from '../actions/baseMotion';\nimport {\n  MoveAroundDoubleQuotes,\n  MoveAroundParentheses,\n  MoveAroundSingleQuotes,\n  MoveAroundSquareBracket,\n  MoveAroundBacktick,\n  MoveAroundTag,\n  ExpandingSelection,\n  MoveAroundCurlyBrace,\n} from '../actions/motion';\nimport { ChangeOperator } from '../actions/operator';\nimport { configuration } from '../configuration/configuration';\nimport { getCurrentParagraphBeginning, getCurrentParagraphEnd } from './paragraph';\nimport { Position, TextDocument } from 'vscode';\n\nexport abstract class TextObjectMovement extends BaseMovement {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<IMovement> {\n    const res = await this.execAction(position, vimState);\n    // Since we need to handle leading spaces, we cannot use MoveWordBegin.execActionForOperator\n    // In normal mode, the character on the stop position will be the first character after the operator executed\n    // and we do left-shifting in operator-pre-execution phase, here we need to right-shift the stop position accordingly.\n    res.stop = new Position(res.stop.line, res.stop.character + 1);\n\n    return res;\n  }\n\n  public abstract execAction(position: Position, vimState: VimState): Promise<IMovement>;\n}\n\n@RegisterAction\nexport class SelectWord extends TextObjectMovement {\n  keys = ['a', 'w'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n    const currentChar = TextEditor.getCharAt(vimState.document, position);\n\n    if (/\\s/.test(currentChar)) {\n      start = position.getLastWordEnd().getRight();\n      stop = position.getCurrentWordEnd();\n    } else {\n      stop = position.getWordRight();\n      // If the next word is not at the beginning of the next line, we want to pretend it is.\n      // This is because 'aw' has two fundamentally different behaviors distinguished by whether\n      // the next word is directly after the current word, as described in the following comment.\n      // The only case that's not true is in cases like #1350.\n      if (stop.isEqual(TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, stop.line))) {\n        stop = stop.getLineBegin();\n      }\n      stop = stop.getLeftThroughLineBreaks().getLeftIfEOL();\n      // If we aren't separated from the next word by whitespace(like in \"horse ca|t,dog\" or at the end of the line)\n      // then we delete the spaces to the left of the current word. Otherwise, we delete to the right.\n      // Also, if the current word is the leftmost word, we only delete from the start of the word to the end.\n      if (\n        stop.isEqual(position.getCurrentWordEnd(true)) &&\n        !position\n          .getWordLeft(true)\n          .isEqual(TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, stop.line)) &&\n        vimState.recordedState.count === 0\n      ) {\n        start = position.getLastWordEnd().getRight();\n      } else {\n        start = position.getWordLeft(true);\n      }\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor position is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.getWordLeft(true);\n        } else {\n          stop = position.getLastWordEnd().getRight();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectABigWord extends TextObjectMovement {\n  keys = ['a', 'W'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n\n    const currentChar = vimState.document.lineAt(position).text[position.character];\n\n    if (/\\s/.test(currentChar)) {\n      start = position.getLastBigWordEnd().getRight();\n      stop = position.getCurrentBigWordEnd();\n    } else {\n      // Check 'aw' code for much of the reasoning behind this logic.\n      const nextWord = position.getBigWordRight();\n      if (\n        (nextWord.line > position.line || nextWord.isAtDocumentEnd()) &&\n        vimState.recordedState.count === 0\n      ) {\n        if (position.getLastBigWordEnd().isLineBeginning()) {\n          start = position.getLastBigWordEnd();\n        } else {\n          start = position.getLastBigWordEnd().getRight();\n        }\n        stop = position.getLineEnd();\n      } else if (\n        (nextWord.isEqual(\n          TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, nextWord.line)\n        ) ||\n          nextWord.isLineEnd()) &&\n        vimState.recordedState.count === 0\n      ) {\n        start = position.getLastWordEnd().getRight();\n        stop = position.getLineEnd();\n      } else {\n        start = position.getBigWordLeft(true);\n        stop = position.getBigWordRight().getLeft();\n      }\n    }\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.getBigWordLeft();\n        } else {\n          stop = position.getLastBigWordEnd().getRight();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n/**\n * This is a custom action that I (johnfn) added. It selects procedurally\n * larger blocks. e.g. if you had \"blah (foo [bar 'ba|z'])\" then it would\n * select 'baz' first. If you pressed af again, it'd then select [bar 'baz'],\n * and if you did it a third time it would select \"(foo [bar 'baz'])\".\n *\n * Very similar is the now built-in `editor.action.smartSelect.expand`\n */\n@RegisterAction\nexport class SelectAnExpandingBlock extends ExpandingSelection {\n  keys = ['a', 'f'];\n  modes = [Mode.Visual, Mode.VisualLine];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const blocks = [\n      new MoveAroundDoubleQuotes(),\n      new MoveAroundSingleQuotes(),\n      new MoveAroundBacktick(),\n      new MoveAroundCurlyBrace(),\n      new MoveAroundParentheses(),\n      new MoveAroundSquareBracket(),\n      new MoveAroundTag(),\n    ];\n    // ideally no state would change as we test each of the possible expansions\n    // a deep copy of vimState could work here but may be expensive\n    let ranges: IMovement[] = [];\n    for (const block of blocks) {\n      const cursorPos = new Position(position.line, position.character);\n      const cursorStartPos = new Position(\n        vimState.cursorStartPosition.line,\n        vimState.cursorStartPosition.character\n      );\n      ranges.push(await block.execAction(cursorPos, vimState));\n      vimState.cursorStartPosition = cursorStartPos;\n    }\n\n    ranges = ranges.filter((range) => {\n      return !range.failed;\n    });\n\n    let smallestRange: Range | undefined;\n\n    for (const iMotion of ranges) {\n      const currentSelectedRange = new Range(\n        vimState.cursorStartPosition,\n        vimState.cursorStopPosition\n      );\n      if (iMotion.failed) {\n        continue;\n      }\n\n      const range = new Range(iMotion.start, iMotion.stop);\n      let contender: Range | undefined;\n\n      if (\n        range.start.isBefore(currentSelectedRange.start) &&\n        range.stop.isAfter(currentSelectedRange.stop)\n      ) {\n        if (!smallestRange) {\n          contender = range;\n        } else {\n          if (range.start.isAfter(smallestRange.start) && range.stop.isBefore(smallestRange.stop)) {\n            contender = range;\n          }\n        }\n      }\n\n      if (contender) {\n        const areTheyEqual =\n          contender.equals(new Range(vimState.cursorStartPosition, vimState.cursorStopPosition)) ||\n          (vimState.currentMode === Mode.VisualLine &&\n            contender.start.line === vimState.cursorStartPosition.line &&\n            contender.stop.line === vimState.cursorStopPosition.line);\n\n        if (!areTheyEqual) {\n          smallestRange = contender;\n        }\n      }\n    }\n    if (!smallestRange) {\n      return {\n        start: vimState.cursorStartPosition,\n        stop: vimState.cursorStopPosition,\n      };\n    } else {\n      // revert relevant state changes\n      vimState.cursorStartPosition = new Position(\n        smallestRange.start.line,\n        smallestRange.start.character\n      );\n      vimState.cursorStopPosition = new Position(\n        smallestRange.stop.line,\n        smallestRange.stop.character\n      );\n      vimState.recordedState.operatorPositionDiff = undefined;\n      return {\n        start: smallestRange.start,\n        stop: smallestRange.stop,\n      };\n    }\n  }\n}\n\n@RegisterAction\nexport class SelectInnerWord extends TextObjectMovement {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = ['i', 'w'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n    const currentChar = vimState.document.lineAt(position).text[position.character];\n\n    if (/\\s/.test(currentChar)) {\n      start = position.getLastWordEnd().getRight();\n      stop = position.getWordRight().getLeftThroughLineBreaks();\n    } else {\n      start = position.getWordLeft(true);\n      stop = position.getCurrentWordEnd(true);\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.getLastWordEnd().getRight();\n        } else {\n          stop = position.getWordLeft(true);\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectInnerBigWord extends TextObjectMovement {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = ['i', 'W'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n    const currentChar = vimState.document.lineAt(position).text[position.character];\n\n    if (/\\s/.test(currentChar)) {\n      start = position.getLastBigWordEnd().getRight();\n      stop = position.getBigWordRight().getLeft();\n    } else {\n      start = position.getBigWordLeft(true);\n      stop = position.getCurrentBigWordEnd(true);\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.getLastBigWordEnd().getRight();\n        } else {\n          stop = position.getBigWordLeft();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectSentence extends TextObjectMovement {\n  keys = ['a', 's'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n\n    const currentSentenceBegin = position.getSentenceBegin({ forward: false });\n    const currentSentenceNonWhitespaceEnd = currentSentenceBegin.getSentenceEnd();\n\n    if (currentSentenceNonWhitespaceEnd.isBefore(position)) {\n      // The cursor is on a trailing white space.\n      start = currentSentenceNonWhitespaceEnd.getRight();\n      stop = currentSentenceBegin.getSentenceBegin({ forward: true }).getSentenceEnd();\n    } else {\n      const nextSentenceBegin = currentSentenceBegin.getSentenceBegin({ forward: true });\n\n      // If the sentence has no trailing white spaces, `as` should include its leading white spaces.\n      if (nextSentenceBegin.isEqual(currentSentenceBegin.getSentenceEnd())) {\n        start = currentSentenceBegin\n          .getSentenceBegin({ forward: false })\n          .getSentenceEnd()\n          .getRight();\n        stop = nextSentenceBegin;\n      } else {\n        start = currentSentenceBegin;\n        stop = nextSentenceBegin.getLeft();\n      }\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting sentences in reverser order.\n        if (currentSentenceNonWhitespaceEnd.isAfter(vimState.cursorStopPosition)) {\n          stop = currentSentenceBegin\n            .getSentenceBegin({ forward: false })\n            .getSentenceEnd()\n            .getRight();\n        } else {\n          stop = currentSentenceBegin;\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectInnerSentence extends TextObjectMovement {\n  keys = ['i', 's'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n\n    const currentSentenceBegin = position.getSentenceBegin({ forward: false });\n    const currentSentenceNonWhitespaceEnd = currentSentenceBegin.getSentenceEnd();\n\n    if (currentSentenceNonWhitespaceEnd.isBefore(position)) {\n      // The cursor is on a trailing white space.\n      start = currentSentenceNonWhitespaceEnd.getRight();\n      stop = currentSentenceBegin.getSentenceBegin({ forward: true }).getLeft();\n    } else {\n      start = currentSentenceBegin;\n      stop = currentSentenceNonWhitespaceEnd;\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting sentences in reverser order.\n        if (currentSentenceNonWhitespaceEnd.isAfter(vimState.cursorStopPosition)) {\n          stop = currentSentenceBegin;\n        } else {\n          stop = currentSentenceNonWhitespaceEnd.getRight();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectParagraph extends TextObjectMovement {\n  keys = ['a', 'p'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    let start: Position;\n    const currentParagraphBegin = getCurrentParagraphBeginning(position, true);\n\n    if (vimState.document.lineAt(position).isEmptyOrWhitespace) {\n      // The cursor is at an empty line, it can be both the start of next paragraph and the end of previous paragraph\n      start = getCurrentParagraphEnd(getCurrentParagraphBeginning(position, true), true);\n    } else {\n      if (currentParagraphBegin.isLineBeginning() && currentParagraphBegin.isLineEnd()) {\n        start = currentParagraphBegin.getRightThroughLineBreaks();\n      } else {\n        start = currentParagraphBegin;\n      }\n    }\n\n    // Include additional blank lines.\n    let stop = getCurrentParagraphEnd(position, true);\n    while (\n      stop.line < vimState.document.lineCount - 1 &&\n      vimState.document.lineAt(stop.getDown()).isEmptyOrWhitespace\n    ) {\n      stop = stop.with({ character: 0 }).getDown();\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectInnerParagraph extends TextObjectMovement {\n  keys = ['i', 'p'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    let start: Position;\n    let stop: Position;\n\n    if (vimState.document.lineAt(position).isEmptyOrWhitespace) {\n      // The cursor is at an empty line, so white lines are the paragraph.\n      start = position.getLineBegin();\n      stop = position.getLineEnd();\n      while (start.line > 0 && vimState.document.lineAt(start.getUp()).isEmptyOrWhitespace) {\n        start = start.getUp();\n      }\n      while (\n        stop.line < vimState.document.lineCount - 1 &&\n        vimState.document.lineAt(stop.getDown()).isEmptyOrWhitespace\n      ) {\n        stop = stop.with({ character: 0 }).getDown();\n      }\n    } else {\n      const currentParagraphBegin = getCurrentParagraphBeginning(position, true);\n      stop = getCurrentParagraphEnd(position, true);\n      if (vimState.document.lineAt(currentParagraphBegin).isEmptyOrWhitespace) {\n        start = currentParagraphBegin.getRightThroughLineBreaks();\n      } else {\n        start = currentParagraphBegin;\n      }\n\n      // Exclude additional blank lines.\n      while (stop.line > 0 && vimState.document.lineAt(stop).isEmptyOrWhitespace) {\n        stop = stop.getUp().getLineEnd();\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectEntire extends TextObjectMovement {\n  keys = ['a', 'e'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    return {\n      start: TextEditor.getDocumentBegin(),\n      stop: TextEditor.getDocumentEnd(vimState.document),\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectEntireIgnoringLeadingTrailing extends TextObjectMovement {\n  keys = ['i', 'e'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position = TextEditor.getDocumentBegin();\n    let stop: Position = TextEditor.getDocumentEnd(vimState.document);\n\n    while (start.line < stop.line && vimState.document.lineAt(start).isEmptyOrWhitespace) {\n      start = start.getDown();\n    }\n\n    while (stop.line > start.line && vimState.document.lineAt(stop).isEmptyOrWhitespace) {\n      stop = stop.getUp();\n    }\n    stop = stop.getLineEnd();\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\nabstract class IndentObjectMatch extends TextObjectMovement {\n  setsDesiredColumnToEOL = true;\n\n  protected includeLineAbove = false;\n  protected includeLineBelow = false;\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const isChangeOperator = vimState.recordedState.operator instanceof ChangeOperator;\n    const firstValidLineNumber = IndentObjectMatch.findFirstValidLine(vimState.document, position);\n    const firstValidLine = vimState.document.lineAt(firstValidLineNumber);\n    const cursorIndent = firstValidLine.firstNonWhitespaceCharacterIndex;\n\n    let startLineNumber = IndentObjectMatch.findRangeStartOrEnd(\n      vimState.document,\n      firstValidLineNumber,\n      cursorIndent,\n      -1\n    );\n    let endLineNumber = IndentObjectMatch.findRangeStartOrEnd(\n      vimState.document,\n      firstValidLineNumber,\n      cursorIndent,\n      1\n    );\n\n    // Adjust the start line as needed.\n    if (this.includeLineAbove) {\n      startLineNumber -= 1;\n    }\n    // Check for OOB.\n    if (startLineNumber < 0) {\n      startLineNumber = 0;\n    }\n\n    // Adjust the end line as needed.\n    if (this.includeLineBelow) {\n      endLineNumber += 1;\n    }\n    // Check for OOB.\n    if (endLineNumber > vimState.document.lineCount - 1) {\n      endLineNumber = vimState.document.lineCount - 1;\n    }\n\n    // If initiated by a change operation, adjust the cursor to the indent level\n    // of the block.\n    let startCharacter = 0;\n    if (isChangeOperator) {\n      startCharacter = vimState.document.lineAt(startLineNumber).firstNonWhitespaceCharacterIndex;\n    }\n    // TextEditor.getLineMaxColumn throws when given line 0, which we don't\n    // care about here since it just means this text object wouldn't work on a\n    // single-line document.\n    let endCharacter: number;\n    if (endLineNumber === vimState.document.lineCount - 1 || vimState.currentMode === Mode.Visual) {\n      endCharacter = TextEditor.getLineLength(endLineNumber);\n    } else {\n      endCharacter = 0;\n      endLineNumber++;\n    }\n    return {\n      start: new Position(startLineNumber, startCharacter),\n      stop: new Position(endLineNumber, endCharacter),\n    };\n  }\n\n  public async execActionForOperator(position: Position, vimState: VimState): Promise<IMovement> {\n    return this.execAction(position, vimState);\n  }\n\n  /**\n   * Searches up from the cursor for the first non-empty line.\n   */\n  public static findFirstValidLine(document: TextDocument, cursorPosition: Position): number {\n    for (let i = cursorPosition.line; i >= 0; i--) {\n      if (!document.lineAt(i).isEmptyOrWhitespace) {\n        return i;\n      }\n    }\n\n    return cursorPosition.line;\n  }\n\n  /**\n   * Searches up or down from a line finding the first with a lower indent level.\n   */\n  public static findRangeStartOrEnd(\n    document: TextDocument,\n    startIndex: number,\n    cursorIndent: number,\n    step: -1 | 1\n  ): number {\n    let i = startIndex;\n    let ret = startIndex;\n    const end = step === 1 ? document.lineCount : -1;\n\n    for (; i !== end; i += step) {\n      const line = document.lineAt(i);\n      if (line.firstNonWhitespaceCharacterIndex < cursorIndent && !line.isEmptyOrWhitespace) {\n        break;\n      }\n\n      ret = i;\n    }\n\n    return ret;\n  }\n}\n\n@RegisterAction\nclass InsideIndentObject extends IndentObjectMatch {\n  keys = ['i', 'i'];\n}\n\n@RegisterAction\nclass InsideIndentObjectAbove extends IndentObjectMatch {\n  keys = ['a', 'i'];\n  includeLineAbove = true;\n}\n\n@RegisterAction\nclass InsideIndentObjectBoth extends IndentObjectMatch {\n  keys = ['a', 'I'];\n  includeLineAbove = true;\n  includeLineBelow = true;\n}\n\nabstract class SelectArgument extends TextObjectMovement {\n  modes = [Mode.Normal, Mode.Visual];\n\n  private static openingDelimiterCharacters(): string[] {\n    return configuration.argumentObjectOpeningDelimiters;\n  }\n  private static closingDelimiterCharacters(): string[] {\n    return configuration.argumentObjectClosingDelimiters;\n  }\n  private static separatorCharacters(): string[] {\n    return configuration.argumentObjectSeparators;\n  }\n\n  // SelectArgument supports two select types: inner and around.\n  //\n  // Inner will adjust start/stop positions, so that they are inside\n  // the delimiters (excluding the delimiters themselves).\n  // Around will adjust start/stop positions, so that ONE of them includes\n  // a separator character (optionally including extra whitespace).\n  protected selectAround = false;\n\n  // Requirement is that below example still works as expected, i.e.\n  // when we have nested pairs of parens\n  //\n  //        ( a, b, (void*) | c(void*, void*), a)\n  //\n  // Warning: For now, mismatched opening and closing delimiters, e.g.\n  // in (foo] will still be matched by this movement.\n  //\n  // Procedure:\n  //\n  // 1   Find boundaries left/right (i.e. where the argument starts/ends)\n  // 1.1 Walk left until we find a comma or an opening paren, that does not\n  //     have a matching closed one. This way we can ignore pairs\n  //     of parentheses which are part of the current argument.\n  // 1.2 Vice versa for walking right.\n  // 2   Depending on our mode (inner or around), improve the start/stop\n  //     locations for most consistent behaviour, especially in case of\n  //     multi-line statements.\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const failure = failedMovement(vimState);\n\n    let leftSearchStartPosition = position;\n    let rightSearchStartPosition = position;\n\n    const charAtPos = TextEditor.getCharAt(vimState.document, position);\n\n    // When the cursor is on a delimiter already, pre-advance the cursor,\n    // so that our search actually spans a range. We will advance to the next argument,\n    // in case of opening delimiters or separators, and advance to the\n    // previous on closing delimiters.\n    if (\n      SelectArgument.separatorCharacters().includes(charAtPos) ||\n      SelectArgument.openingDelimiterCharacters().includes(charAtPos)\n    ) {\n      rightSearchStartPosition = position.getRightThroughLineBreaks(true);\n    } else if (SelectArgument.closingDelimiterCharacters().includes(charAtPos)) {\n      leftSearchStartPosition = position.getLeftThroughLineBreaks(true);\n    }\n\n    // Early abort, if no delimiters (i.e. (), [], etc.) surround us.\n    // This prevents applying the movement to surrounding separators across the buffer.\n    if (\n      SelectInnerArgument.findLeftArgumentBoundary(\n        vimState.document,\n        leftSearchStartPosition,\n        true\n      ) === undefined ||\n      SelectInnerArgument.findRightArgumentBoundary(\n        vimState.document,\n        rightSearchStartPosition,\n        true\n      ) === undefined\n    ) {\n      return failure;\n    }\n\n    const leftArgumentBoundary = SelectInnerArgument.findLeftArgumentBoundary(\n      vimState.document,\n      leftSearchStartPosition\n    );\n    if (leftArgumentBoundary === undefined) {\n      return failure;\n    }\n\n    const rightArgumentBoundary = SelectInnerArgument.findRightArgumentBoundary(\n      vimState.document,\n      rightSearchStartPosition\n    );\n    if (rightArgumentBoundary === undefined) {\n      return failure;\n    }\n\n    let start: Position;\n    let stop: Position;\n\n    if (this.selectAround) {\n      const isLeftOnOpening: boolean = SelectArgument.openingDelimiterCharacters().includes(\n        TextEditor.getCharAt(vimState.document, leftArgumentBoundary)\n      );\n      const isRightOnClosing: boolean = SelectArgument.closingDelimiterCharacters().includes(\n        TextEditor.getCharAt(vimState.document, rightArgumentBoundary)\n      );\n\n      // Edge-case:\n      // Ensure we do not select anything if we have an empty argument list, e.g. \"()\"\n      const isEmptyArgumentList =\n        leftArgumentBoundary.getRight().isEqual(rightArgumentBoundary) &&\n        isLeftOnOpening &&\n        isRightOnClosing;\n      if (isEmptyArgumentList) {\n        return failure;\n      }\n\n      // Only when we are in the first argument we outset the right boundary\n      // until the first non-whitespace, so we do not end up with whitespace\n      // at the beginning of the parens.\n      const isInFirstArgument = isLeftOnOpening && !isRightOnClosing;\n      if (isInFirstArgument) {\n        stop = rightArgumentBoundary.getRight();\n        // Walk right until non-whitespace\n        while (/\\s/.test(TextEditor.getCharAt(vimState.document, stop.getRight()))) {\n          stop = stop.getRight();\n        }\n      } else {\n        // In any other case, we inset\n        stop = rightArgumentBoundary.getLeftThroughLineBreaks(true);\n      }\n\n      // In case the left boundary is on a opening delimiter, move that position inwards\n      if (isLeftOnOpening) {\n        start = leftArgumentBoundary.getRightThroughLineBreaks(true);\n      } else {\n        start = leftArgumentBoundary;\n      }\n    } else {\n      // Inset the start once to get off the boundary and then keep\n      // going until the first non whitespace.\n      // This ensures that indented argument-lists keep the indentation.\n      start = leftArgumentBoundary.getRightThroughLineBreaks(false);\n      while (/\\s/.test(TextEditor.getCharAt(vimState.document, start))) {\n        start = start.getRightThroughLineBreaks(false);\n      }\n\n      // Same procedure for stop.\n      stop = rightArgumentBoundary.getLeftThroughLineBreaks(false);\n      while (/\\s/.test(TextEditor.getCharAt(vimState.document, stop))) {\n        stop = stop.getLeftThroughLineBreaks(false);\n      }\n\n      // Edge-case: Seems there is only whitespace in this argument.\n      // Omit any weird handling and just clear all whitespace.\n      if (stop.isBeforeOrEqual(start)) {\n        start = leftArgumentBoundary.getRightThroughLineBreaks(true);\n        stop = rightArgumentBoundary.getLeftThroughLineBreaks(true);\n      }\n    }\n\n    // Handle case when cursor is not inside the anticipated movement range\n    if (position.isBefore(start)) {\n      vimState.recordedState.operatorPositionDiff = start.subtract(position);\n    }\n    vimState.cursorStartPosition = start;\n\n    return {\n      start,\n      stop,\n    };\n  }\n\n  private static findLeftArgumentBoundary(\n    document: TextDocument,\n    position: Position,\n    ignoreSeparators: boolean = false\n  ): Position | undefined {\n    let delimiterPosition: Position | undefined;\n    let walkingPosition = position;\n    let closedParensCount = 0;\n\n    while (true) {\n      const char = TextEditor.getCharAt(document, walkingPosition);\n      if (closedParensCount === 0) {\n        let isOnBoundary: boolean = SelectArgument.openingDelimiterCharacters().includes(char);\n        if (!ignoreSeparators) {\n          isOnBoundary ||= SelectArgument.separatorCharacters().includes(char);\n        }\n\n        if (isOnBoundary) {\n          // We have found the left most delimiter or the first proper delimiter\n          // in our cursor's list 'depth' and thus can abort.\n          delimiterPosition = walkingPosition;\n          break;\n        }\n      }\n      if (SelectArgument.closingDelimiterCharacters().includes(char)) {\n        closedParensCount++;\n      }\n      if (SelectArgument.openingDelimiterCharacters().includes(char)) {\n        closedParensCount--;\n      }\n\n      if (walkingPosition.isAtDocumentBegin()) {\n        break;\n      }\n\n      walkingPosition = walkingPosition.getLeftThroughLineBreaks(true);\n    }\n\n    return delimiterPosition;\n  }\n\n  private static findRightArgumentBoundary(\n    document: TextDocument,\n    position: Position,\n    ignoreSeparators: boolean = false\n  ): Position | undefined {\n    let delimiterPosition: Position | undefined;\n    let walkingPosition = position;\n    let openedParensCount = 0;\n\n    while (true) {\n      const char = TextEditor.getCharAt(document, walkingPosition);\n      if (openedParensCount === 0) {\n        let isOnBoundary: boolean = SelectArgument.closingDelimiterCharacters().includes(char);\n        if (!ignoreSeparators) {\n          isOnBoundary ||= SelectArgument.separatorCharacters().includes(char);\n        }\n\n        if (isOnBoundary) {\n          delimiterPosition = walkingPosition;\n          break;\n        }\n      }\n      if (SelectArgument.openingDelimiterCharacters().includes(char)) {\n        openedParensCount++;\n      }\n      if (SelectArgument.closingDelimiterCharacters().includes(char)) {\n        openedParensCount--;\n      }\n\n      if (walkingPosition.isAtDocumentEnd()) {\n        break;\n      }\n\n      // We need to include the EOL so that isAtDocumentEnd actually\n      // becomes true.\n      walkingPosition = walkingPosition.getRightThroughLineBreaks(true);\n    }\n\n    return delimiterPosition;\n  }\n}\n\n@RegisterAction\nexport class SelectInnerArgument extends SelectArgument {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = ['i', 'a'];\n}\n\n@RegisterAction\nexport class SelectAroundArgument extends SelectArgument {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = ['a', 'a'];\n  selectAround = true;\n}\n","export function getAllPositions(line: string, regex: RegExp): number[] {\n  const positions: number[] = [];\n  let result = regex.exec(line);\n\n  while (result) {\n    positions.push(result.index);\n\n    // Handles the case where an empty string match causes lastIndex not to advance,\n    // which gets us in an infinite loop.\n    if (result.index === regex.lastIndex) {\n      regex.lastIndex++;\n    }\n    result = regex.exec(line);\n  }\n\n  return positions;\n}\n\nexport function getAllEndPositions(line: string, regex: RegExp): number[] {\n  const positions: number[] = [];\n  let result = regex.exec(line);\n\n  while (result) {\n    if (result[0].length) {\n      positions.push(result.index + result[0].length - 1);\n    }\n\n    // Handles the case where an empty string match causes lastIndex not to advance,\n    // which gets us in an infinite loop.\n    if (result.index === regex.lastIndex) {\n      regex.lastIndex++;\n    }\n    result = regex.exec(line);\n  }\n\n  return positions;\n}\n","import * as _ from 'lodash';\nimport { Position } from 'vscode';\nimport { configuration } from '../configuration/configuration';\nimport { TextEditor } from '../textEditor';\nimport { getAllPositions, getAllEndPositions } from './util';\n\nexport enum WordType {\n  Normal,\n  Big,\n  CamelCase,\n  FileName,\n}\n\nconst nonWordCharRegex = makeUnicodeWordRegex(configuration.iskeyword);\nconst nonBigWordCharRegex = makeWordRegex('');\nconst nonCamelCaseWordCharRegex = makeCamelCaseWordRegex(configuration.iskeyword);\nconst nonFileNameRegex = makeWordRegex('\"\\'`;<>{}[]()');\n\nfunction regexForWordType(wordType: WordType): RegExp {\n  switch (wordType) {\n    case WordType.Normal:\n      return nonWordCharRegex;\n    case WordType.Big:\n      return nonBigWordCharRegex;\n    case WordType.CamelCase:\n      return nonCamelCaseWordCharRegex;\n    case WordType.FileName:\n      return nonFileNameRegex;\n  }\n}\n\n/**\n * Get the position of the word counting from the position specified.\n * @param text The string to search from.\n * @param pos The position of text to search from.\n * @returns The character position of the word to the left relative to the text and the pos.\n *          undefined if there is no word to the left of the postion.\n */\nexport function getWordLeftInText(\n  text: string,\n  pos: number,\n  wordType: WordType\n): number | undefined {\n  return getWordLeftOnLine(text, pos, wordType);\n}\n\nexport function getWordRightInText(\n  text: string,\n  pos: number,\n  wordType: WordType\n): number | undefined {\n  return getAllPositions(text, regexForWordType(wordType)).find((index) => index > pos);\n}\n\n/**\n * Inclusive is true if we consider the current position a valid result, false otherwise.\n */\nexport function getWordLeft(\n  pos: Position,\n  wordType: WordType,\n  inclusive: boolean = false\n): Position {\n  for (let currentLine = pos.line; currentLine >= 0; currentLine--) {\n    const newCharacter = getWordLeftOnLine(\n      TextEditor.getLine(currentLine).text,\n      pos.character,\n      wordType,\n      currentLine !== pos.line,\n      inclusive\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(0, 0);\n}\n\nfunction getWordLeftOnLine(\n  text: string,\n  pos: number,\n  wordType: WordType,\n  forceFirst: boolean = false,\n  inclusive: boolean = false\n): number | undefined {\n  return getAllPositions(text, regexForWordType(wordType))\n    .reverse()\n    .find((index) => (index < pos && !inclusive) || (index <= pos && inclusive) || forceFirst);\n}\n\n/**\n * Inclusive is true if we consider the current position a valid result, false otherwise.\n */\nexport function getWordRight(\n  pos: Position,\n  wordType: WordType,\n  inclusive: boolean = false\n): Position {\n  for (let currentLine = pos.line; currentLine < TextEditor.getLineCount(); currentLine++) {\n    const positions = getAllPositions(\n      TextEditor.getLine(currentLine).text,\n      regexForWordType(wordType)\n    );\n    const newCharacter = positions.find(\n      (index) =>\n        (index > pos.character && !inclusive) ||\n        (index >= pos.character && inclusive) ||\n        currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(TextEditor.getLineCount() - 1, 0).getLineEnd();\n}\n\n/**\n * Inclusive is true if we consider the current position a valid result, false otherwise.\n */\nexport function getCurrentWordEnd(\n  pos: Position,\n  wordType: WordType,\n  inclusive: boolean = false\n): Position {\n  for (let currentLine = pos.line; currentLine < TextEditor.getLineCount(); currentLine++) {\n    const positions = getAllEndPositions(\n      TextEditor.getLine(currentLine).text,\n      regexForWordType(wordType)\n    );\n    const newCharacter = positions.find(\n      (index) =>\n        (index > pos.character && !inclusive) ||\n        (index >= pos.character && inclusive) ||\n        currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(TextEditor.getLineCount() - 1, 0).getLineEnd();\n}\n\nexport function getLastWordEnd(pos: Position, wordType: WordType): Position {\n  for (let currentLine = pos.line; currentLine > -1; currentLine--) {\n    let positions = getAllEndPositions(\n      TextEditor.getLine(currentLine).text,\n      regexForWordType(wordType)\n    );\n    // if one line is empty, use the 0 position as the default value\n    if (positions.length === 0) {\n      positions.push(0);\n    }\n    // reverse the list to find the biggest element smaller than pos.character\n    positions = positions.reverse();\n    const index = positions.findIndex((i) => i < pos.character || currentLine !== pos.line);\n    let newCharacter = 0;\n    if (index === -1) {\n      if (currentLine > -1) {\n        continue;\n      }\n      newCharacter = positions[positions.length - 1];\n    } else {\n      newCharacter = positions[index];\n    }\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(0, 0);\n}\n\nfunction makeWordRegex(characterSet: string): RegExp {\n  const escaped = characterSet && _.escapeRegExp(characterSet).replace(/-/g, '\\\\-');\n  const segments = [`([^\\\\s${escaped}]+)`, `[${escaped}]+`, `$^`];\n\n  return new RegExp(segments.join('|'), 'g');\n}\n\nfunction makeCamelCaseWordRegex(characterSet: string): RegExp {\n  const escaped = characterSet && _.escapeRegExp(characterSet).replace(/-/g, '\\\\-');\n  const segments: string[] = [];\n\n  // Older browsers don't support lookbehind - in this case, use an inferior regex rather than crashing\n  let supportsLookbehind = true;\n  try {\n    // tslint:disable-next-line\n    new RegExp('(?<=x)');\n  } catch {\n    supportsLookbehind = false;\n  }\n\n  // prettier-ignore\n  const firstSegment =\n      '(' +                                             // OPEN: group for matching camel case words\n      `[^\\\\s${escaped}]` +                              //   words can start with any word character\n      '(?:' +                                           //   OPEN: group for characters after initial char\n      `(?:${supportsLookbehind ? '(?<=[A-Z_])' : ''}` + //     If first char was a capital\n      `[A-Z](?=[\\\\sA-Z0-9${escaped}_]))+` +             //       the word can continue with all caps\n      '|' +                                             //     OR\n      `(?:${supportsLookbehind ? '(?<=[0-9_])' : ''}` + //     If first char was a digit\n      `[0-9](?=[\\\\sA-Z0-9${escaped}_]))+` +             //       the word can continue with all digits\n      '|' +                                             //     OR\n      `(?:${supportsLookbehind ? '(?<=[_])' : ''}` +    //     If first char was an underscore\n      `[_](?=[\\\\s${escaped}_]))+`  +                    //       the word can continue with all underscores\n      '|' +                                             //     OR\n      `[^\\\\sA-Z0-9${escaped}_]*` +                      //     Continue with regular characters\n      ')' +                                             //   END: group for characters after initial char\n      ')' +                                             // END: group for matching camel case words\n      '';\n\n  segments.push(firstSegment);\n  segments.push(`[${escaped}]+`);\n  segments.push(`$^`);\n\n  // it can be difficult to grok the behavior of the above regex\n  // feel free to check out https://regex101.com/r/mkVeiH/1 as a live example\n  return new RegExp(segments.join('|'), 'g');\n}\n\nfunction makeUnicodeWordRegex(keywordChars: string): RegExp {\n  // Distinct categories of characters\n  enum CharKind {\n    Punctuation,\n    Superscript,\n    Subscript,\n    Braille,\n    Ideograph,\n    Hiragana,\n    Katakana,\n    Hangul,\n  }\n\n  // List of printable characters (code point intervals) and their character kinds.\n  // Latin alphabets (e.g., ASCII alphabets and numbers,  Latin-1 Supplement, European Latin) are excluded.\n  // Imported from utf_class_buf in src/mbyte.c of Vim.\n  const symbolTable: Array<[[number, number], CharKind]> = [\n    [[0x00a1, 0x00bf], CharKind.Punctuation], // Latin-1 punctuation\n    [[0x037e, 0x037e], CharKind.Punctuation], // Greek question mark\n    [[0x0387, 0x0387], CharKind.Punctuation], // Greek ano teleia\n    [[0x055a, 0x055f], CharKind.Punctuation], // Armenian punctuation\n    [[0x0589, 0x0589], CharKind.Punctuation], // Armenian full stop\n    [[0x05be, 0x05be], CharKind.Punctuation],\n    [[0x05c0, 0x05c0], CharKind.Punctuation],\n    [[0x05c3, 0x05c3], CharKind.Punctuation],\n    [[0x05f3, 0x05f4], CharKind.Punctuation],\n    [[0x060c, 0x060c], CharKind.Punctuation],\n    [[0x061b, 0x061b], CharKind.Punctuation],\n    [[0x061f, 0x061f], CharKind.Punctuation],\n    [[0x066a, 0x066d], CharKind.Punctuation],\n    [[0x06d4, 0x06d4], CharKind.Punctuation],\n    [[0x0700, 0x070d], CharKind.Punctuation], // Syriac punctuation\n    [[0x0964, 0x0965], CharKind.Punctuation],\n    [[0x0970, 0x0970], CharKind.Punctuation],\n    [[0x0df4, 0x0df4], CharKind.Punctuation],\n    [[0x0e4f, 0x0e4f], CharKind.Punctuation],\n    [[0x0e5a, 0x0e5b], CharKind.Punctuation],\n    [[0x0f04, 0x0f12], CharKind.Punctuation],\n    [[0x0f3a, 0x0f3d], CharKind.Punctuation],\n    [[0x0f85, 0x0f85], CharKind.Punctuation],\n    [[0x104a, 0x104f], CharKind.Punctuation], // Myanmar punctuation\n    [[0x10fb, 0x10fb], CharKind.Punctuation], // Georgian punctuation\n    [[0x1361, 0x1368], CharKind.Punctuation], // Ethiopic punctuation\n    [[0x166d, 0x166e], CharKind.Punctuation], // Canadian Syl. punctuation\n    [[0x169b, 0x169c], CharKind.Punctuation],\n    [[0x16eb, 0x16ed], CharKind.Punctuation],\n    [[0x1735, 0x1736], CharKind.Punctuation],\n    [[0x17d4, 0x17dc], CharKind.Punctuation], // Khmer punctuation\n    [[0x1800, 0x180a], CharKind.Punctuation], // Mongolian punctuation\n    [[0x200c, 0x2027], CharKind.Punctuation], // punctuation and symbols\n    [[0x202a, 0x202e], CharKind.Punctuation], // punctuation and symbols\n    [[0x2030, 0x205e], CharKind.Punctuation], // punctuation and symbols\n    [[0x2060, 0x27ff], CharKind.Punctuation], // punctuation and symbols\n    [[0x2070, 0x207f], CharKind.Superscript], // superscript\n    [[0x2080, 0x2094], CharKind.Subscript], // subscript\n    [[0x20a0, 0x27ff], CharKind.Punctuation], // all kinds of symbols\n    [[0x2800, 0x28ff], CharKind.Braille], // braille\n    [[0x2900, 0x2998], CharKind.Punctuation], // arrows, brackets, etc.\n    [[0x29d8, 0x29db], CharKind.Punctuation],\n    [[0x29fc, 0x29fd], CharKind.Punctuation],\n    [[0x2e00, 0x2e7f], CharKind.Punctuation], // supplemental punctuation\n    [[0x3001, 0x3020], CharKind.Punctuation], // ideographic punctuation\n    [[0x3030, 0x3030], CharKind.Punctuation],\n    [[0x303d, 0x303d], CharKind.Punctuation],\n    [[0x3040, 0x309f], CharKind.Hiragana], // Hiragana\n    [[0x30a0, 0x30ff], CharKind.Katakana], // Katakana\n    [[0x3300, 0x9fff], CharKind.Ideograph], // CJK Ideographs\n    [[0xac00, 0xd7a3], CharKind.Hangul], // Hangul Syllables\n    [[0xf900, 0xfaff], CharKind.Ideograph], // CJK Ideographs\n    [[0xfd3e, 0xfd3f], CharKind.Punctuation],\n    [[0xfe30, 0xfe6b], CharKind.Punctuation], // punctuation forms\n    [[0xff00, 0xff0f], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0xff1a, 0xff20], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0xff3b, 0xff40], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0xff5b, 0xff65], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0x20000, 0x2a6df], CharKind.Ideograph], // CJK Ideographs\n    [[0x2a700, 0x2b73f], CharKind.Ideograph], // CJK Ideographs\n    [[0x2b740, 0x2b81f], CharKind.Ideograph], // CJK Ideographs\n    [[0x2f800, 0x2fa1f], CharKind.Ideograph], // CJK Ideographs\n  ];\n\n  const codePointRangePatterns: string[][] = [];\n  for (const kind in CharKind) {\n    if (!isNaN(Number(kind))) {\n      codePointRangePatterns[kind] = [];\n    }\n  }\n\n  for (const [[first, last], kind] of symbolTable) {\n    if (first === last) {\n      // '\\u{hhhh}'\n      codePointRangePatterns[kind].push(`\\\\u{${first.toString(16)}}`);\n    } else {\n      // '\\u{hhhh}-\\u{hhhh}'\n      codePointRangePatterns[kind].push(`\\\\u{${first.toString(16)}}-\\\\u{${last.toString(16)}}`);\n    }\n  }\n\n  // Symbols in vim.iskeyword or editor.wordSeparators\n  // are treated as CharKind.Punctuation\n  const escapedKeywordChars = _.escapeRegExp(keywordChars).replace(/-/g, '\\\\-');\n  codePointRangePatterns[Number(CharKind.Punctuation)].push(escapedKeywordChars);\n\n  const codePointRanges = codePointRangePatterns.map((patterns) => patterns.join(''));\n  const symbolSegments = codePointRanges.map((range) => `([${range}]+)`);\n\n  // wordSegment matches word characters.\n  // A word character is a symbol which is neither\n  // - space\n  // - a symbol listed in the table\n  // - a keyword (vim.iskeyword)\n  const wordSegment = `([^\\\\s${codePointRanges.join('')}]+)`;\n\n  // https://regex101.com/r/X1agK6/2\n  const segments = symbolSegments.concat(wordSegment, '$^');\n  return new RegExp(segments.join('|'), 'ug');\n}\n","import * as vscode from 'vscode';\nimport { Logger } from '../util/logger';\nimport {\n  isTextTransformation,\n  TextTransformations,\n  Transformation,\n  isMultiCursorTextTransformation,\n  InsertTextVSCodeTransformation,\n  areAllSameTransformation,\n  areAnyTransformationsOverlapping,\n} from './transformations';\nimport { commandLine } from '../cmd_line/commandLine';\nimport { PairMatcher } from '../common/matching/matcher';\nimport { PositionDiff } from '../common/motion/position';\nimport { VimError, ErrorCode } from '../error';\nimport { Mode } from '../mode/mode';\nimport { Register } from '../register/register';\nimport { globalState } from '../state/globalState';\nimport { RecordedState } from '../state/recordedState';\nimport { TextEditor } from '../textEditor';\nimport { reportSearch } from '../util/statusBarTextUtils';\nimport { Range } from '../common/motion/range';\nimport { Position } from 'vscode';\nimport { VimState } from '../state/vimState';\nimport { Transformer } from './transformer';\n\nexport interface IModeHandler {\n  vimState: VimState;\n\n  updateView(args?: { drawSelection: boolean; revealRange: boolean }): Promise<void>;\n  runMacro(recordedMacro: RecordedState): Promise<void>;\n  handleMultipleKeyEvents(keys: string[]): Promise<void>;\n  rerunRecordedState(recordedState: RecordedState): Promise<void>;\n}\n\nconst logger = Logger.get('Parser');\n\nexport async function executeTransformations(\n  modeHandler: IModeHandler,\n  transformations: Transformation[]\n) {\n  if (transformations.length === 0) {\n    return;\n  }\n\n  const vimState = modeHandler.vimState;\n\n  const textTransformations: TextTransformations[] = transformations.filter((x) =>\n    isTextTransformation(x)\n  ) as any;\n  const multicursorTextTransformations: InsertTextVSCodeTransformation[] = transformations.filter(\n    (x) => isMultiCursorTextTransformation(x)\n  ) as any;\n\n  const otherTransformations = transformations.filter(\n    (x) => !isTextTransformation(x) && !isMultiCursorTextTransformation(x)\n  );\n\n  const accumulatedPositionDifferences: { [key: number]: PositionDiff[] } = {};\n\n  const doTextEditorEdit = (command: TextTransformations, edit: vscode.TextEditorEdit) => {\n    switch (command.type) {\n      case 'insertText':\n        edit.insert(command.position, command.text);\n        break;\n      case 'replaceText':\n        edit.replace(new vscode.Selection(command.range.start, command.range.stop), command.text);\n        break;\n      case 'deleteText':\n        const matchRange = PairMatcher.immediateMatchingBracket(vimState, command.position);\n        if (matchRange) {\n          edit.delete(matchRange);\n        }\n        edit.delete(\n          new vscode.Range(command.position, command.position.getLeftThroughLineBreaks())\n        );\n        break;\n      case 'deleteRange':\n        edit.delete(new vscode.Selection(command.range.start, command.range.stop));\n        break;\n      case 'moveCursor':\n        break;\n      default:\n        logger.warn(`Unhandled text transformation type: ${command.type}.`);\n        break;\n    }\n\n    if (command.cursorIndex === undefined) {\n      throw new Error('No cursor index - this should never ever happen!');\n    }\n\n    if (command.diff) {\n      if (!accumulatedPositionDifferences[command.cursorIndex]) {\n        accumulatedPositionDifferences[command.cursorIndex] = [];\n      }\n\n      accumulatedPositionDifferences[command.cursorIndex].push(command.diff);\n    }\n  };\n\n  if (textTransformations.length > 0) {\n    if (areAnyTransformationsOverlapping(textTransformations)) {\n      logger.debug(\n        `Text transformations are overlapping. Falling back to serial\n          transformations. This is generally a very bad sign. Try to make\n          your text transformations operate on non-overlapping ranges.`\n      );\n\n      // TODO: Select one transformation for every cursor and run them all\n      // in parallel. Repeat till there are no more transformations.\n      for (const transformation of textTransformations) {\n        await vimState.editor.edit((edit) => doTextEditorEdit(transformation, edit));\n      }\n    } else {\n      // This is the common case!\n\n      /**\n       * batch all text operations together as a single operation\n       * (this is primarily necessary for multi-cursor mode, since most\n       * actions will trigger at most one text operation).\n       */\n      await vimState.editor.edit((edit) => {\n        for (const command of textTransformations) {\n          doTextEditorEdit(command, edit);\n        }\n      });\n    }\n  }\n\n  if (multicursorTextTransformations.length > 0) {\n    if (areAllSameTransformation(multicursorTextTransformations)) {\n      /**\n       * Apply the transformation only once instead of to each cursor\n       * if they are all the same.\n       *\n       * This lets VSCode do multicursor snippets, auto braces and\n       * all the usual jazz VSCode does on text insertion.\n       */\n      const { text } = multicursorTextTransformations[0];\n\n      // await vscode.commands.executeCommand('default:type', { text });\n      await TextEditor.insert(vimState.editor, text);\n    } else {\n      logger.warn(`Unhandled multicursor transformations. Not all transformations are the same!`);\n    }\n  }\n\n  for (const transformation of otherTransformations) {\n    switch (transformation.type) {\n      case 'insertTextVSCode':\n        await TextEditor.insert(vimState.editor, transformation.text);\n        vimState.cursors[0] = Range.FromVSCodeSelection(vimState.editor.selection);\n        break;\n\n      case 'showCommandHistory':\n        const cmd = await commandLine.showHistory(vimState.currentCommandlineText);\n        if (cmd && cmd.length !== 0) {\n          await commandLine.Run(cmd, vimState);\n          modeHandler.updateView();\n        }\n        break;\n\n      case 'showSearchHistory':\n        const searchState = await globalState.showSearchHistory();\n        if (searchState) {\n          globalState.searchState = searchState;\n          const nextMatch = searchState.getNextSearchMatchPosition(\n            vimState.editor,\n            vimState.cursorStartPosition,\n            transformation.direction\n          );\n\n          if (!nextMatch) {\n            throw VimError.fromCode(\n              transformation.direction > 0 ? ErrorCode.SearchHitBottom : ErrorCode.SearchHitTop,\n              searchState.searchString\n            );\n          }\n\n          vimState.cursorStopPosition = nextMatch.pos;\n          modeHandler.updateView();\n          reportSearch(\n            nextMatch.index,\n            searchState.getMatchRanges(vimState.editor).length,\n            vimState\n          );\n        }\n        break;\n\n      case 'dot':\n        if (!globalState.previousFullAction) {\n          return; // TODO(bell)\n        }\n\n        await modeHandler.rerunRecordedState(globalState.previousFullAction.clone());\n        break;\n\n      case 'macro':\n        const recordedMacro = (await Register.get(vimState, transformation.register))?.text;\n        if (!(recordedMacro instanceof RecordedState)) {\n          return;\n        }\n\n        vimState.isReplayingMacro = true;\n\n        if (transformation.register === ':') {\n          await commandLine.Run(recordedMacro.commandString, vimState);\n        } else if (transformation.replay === 'contentChange') {\n          await modeHandler.runMacro(recordedMacro);\n        } else {\n          let keyStrokes: string[] = [];\n          for (const action of recordedMacro.actionsRun) {\n            keyStrokes = keyStrokes.concat(action.keysPressed);\n          }\n          vimState.recordedState = new RecordedState();\n          await modeHandler.handleMultipleKeyEvents(keyStrokes);\n        }\n\n        vimState.isReplayingMacro = false;\n        vimState.lastInvokedMacro = recordedMacro;\n\n        if (vimState.lastMovementFailed) {\n          // movement in last invoked macro failed then we should stop all following repeating macros.\n          // Besides, we should reset `lastMovementFailed`.\n          vimState.lastMovementFailed = false;\n          return;\n        }\n        break;\n\n      case 'contentChange':\n        for (const change of transformation.changes) {\n          await TextEditor.insert(vimState.editor, change.text);\n          vimState.cursorStopPosition = vimState.editor.selection.start;\n        }\n        const newPos = vimState.cursorStopPosition.add(vimState.document, transformation.diff);\n        vimState.editor.selection = new vscode.Selection(newPos, newPos);\n        break;\n\n      case 'tab':\n        await vscode.commands.executeCommand('tab');\n        if (transformation.diff) {\n          if (transformation.cursorIndex === undefined) {\n            throw new Error('No cursor index - this should never ever happen!');\n          }\n\n          if (!accumulatedPositionDifferences[transformation.cursorIndex]) {\n            accumulatedPositionDifferences[transformation.cursorIndex] = [];\n          }\n\n          accumulatedPositionDifferences[transformation.cursorIndex].push(transformation.diff);\n        }\n        break;\n\n      case 'reindent':\n        await vscode.commands.executeCommand('editor.action.reindentselectedlines');\n        if (transformation.diff) {\n          if (transformation.cursorIndex === undefined) {\n            throw new Error('No cursor index - this should never ever happen!');\n          }\n\n          if (!accumulatedPositionDifferences[transformation.cursorIndex]) {\n            accumulatedPositionDifferences[transformation.cursorIndex] = [];\n          }\n\n          accumulatedPositionDifferences[transformation.cursorIndex].push(transformation.diff);\n        }\n        break;\n\n      default:\n        logger.warn(`Unhandled text transformation type: ${transformation.type}.`);\n        break;\n    }\n  }\n\n  const selections = vimState.editor.selections.map((sel) => {\n    let range = Range.FromVSCodeSelection(sel);\n    if (range.start.isBefore(range.stop)) {\n      range = range.withNewStop(range.stop.getLeftThroughLineBreaks(true));\n    }\n    return new vscode.Selection(range.start, range.stop);\n  });\n  const firstTransformation = transformations[0];\n  const manuallySetCursorPositions =\n    (firstTransformation.type === 'deleteRange' ||\n      firstTransformation.type === 'replaceText' ||\n      firstTransformation.type === 'insertText') &&\n    firstTransformation.manuallySetCursorPositions;\n\n  // We handle multiple cursors in a different way in visual block mode, unfortunately.\n  // TODO - refactor that out!\n  if (vimState.currentMode !== Mode.VisualBlock && !manuallySetCursorPositions) {\n    vimState.cursors = selections.map((sel, idx) => {\n      const diffs = accumulatedPositionDifferences[idx] ?? [];\n      if (vimState.recordedState.operatorPositionDiff) {\n        diffs.push(vimState.recordedState.operatorPositionDiff);\n      }\n\n      return diffs.reduce(\n        (cursor, diff) =>\n          new Range(\n            cursor.start.add(vimState.document, diff),\n            cursor.stop.add(vimState.document, diff)\n          ),\n        Range.FromVSCodeSelection(sel)\n      );\n    });\n\n    vimState.recordedState.operatorPositionDiff = undefined;\n  } else if (accumulatedPositionDifferences[0]?.length > 0) {\n    const diff = accumulatedPositionDifferences[0][0];\n    vimState.cursorStopPosition = vimState.cursorStopPosition.add(vimState.document, diff);\n    vimState.cursorStartPosition = vimState.cursorStartPosition.add(vimState.document, diff);\n  }\n\n  /**\n   * This is a bit of a hack because Visual Block Mode isn't fully on board with\n   * the new text transformation style yet.\n   *\n   * (TODO)\n   */\n  if (firstTransformation.type === 'deleteRange') {\n    if (firstTransformation.collapseRange) {\n      vimState.cursorStopPosition = new Position(\n        vimState.cursorStopPosition.line,\n        vimState.cursorStartPosition.character\n      );\n    }\n  }\n\n  vimState.recordedState.transformer = new Transformer();\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nimport { PositionDiff } from './../common/motion/position';\nimport { Range } from './../common/motion/range';\n\n/**\n * This file contains definitions of objects that represent text\n * additions/deletions/replacements on the document. You'll add them\n * to vimState.recordedState.transformer.transformations and then they will be applied\n * later on.\n *\n * We do it in this way so they can all be processed in parallel and merged\n * if necessary.\n */\n\n/**\n * Represents inserting text at a position in the document.\n */\nexport interface InsertTextTransformation {\n  /**\n   * Type of this insertion (used for type checking with discriminated\n   * union types).\n   */\n  type: 'insertText';\n\n  /**\n   * Text content of this insertion.\n   */\n  text: string;\n\n  /**\n   * The location to insert the text.\n   */\n  position: Position;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n\n  manuallySetCursorPositions?: boolean;\n}\n\nexport interface ReplaceTextTransformation {\n  type: 'replaceText';\n\n  /**\n   * Text to insert.\n   */\n  text: string;\n\n  /**\n   * Range of characters to replace.\n   */\n  range: Range;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n\n  /**\n   * Please don't use this! It's a hack.\n   */\n  manuallySetCursorPositions?: boolean;\n}\n\n/**\n * Represents inserting a character and allowing visual studio to do\n * its post-character stuff if it wants. (e.g., if you type \"(\" this\n * will automatically add the closing \")\").\n */\nexport interface InsertTextVSCodeTransformation {\n  type: 'insertTextVSCode';\n\n  /**\n   * Text to insert.\n   */\n  text: string;\n\n  /**\n   * Whether this transformation was created in multicursor mode.\n   */\n  isMultiCursor?: boolean;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n}\n\n/**\n * Represents deleting a character at a position in the document.\n */\nexport interface DeleteTextTransformation {\n  type: 'deleteText';\n\n  /**\n   * Position at which to delete a character.\n   */\n  position: Position;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n}\n\n/**\n * Represents deleting a range of characters.\n */\nexport interface DeleteTextRangeTransformation {\n  type: 'deleteRange';\n\n  /**\n   * Range of characters to delete.\n   */\n  range: Range;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n\n  collapseRange?: boolean;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * Please don't use this! It's a hack.\n   */\n  manuallySetCursorPositions?: boolean;\n}\n\nexport interface MoveCursorTransformation {\n  type: 'moveCursor';\n\n  cursorIndex?: number;\n\n  /**\n   * Move the cursor this much.\n   */\n  diff: PositionDiff;\n}\n\n/**\n * Represents pressing ':'\n */\nexport interface ShowCommandHistory {\n  type: 'showCommandHistory';\n}\n\nexport interface ShowSearchHistory {\n  type: 'showSearchHistory';\n  direction: number;\n}\n\n/**\n * Represents pressing '.'\n */\nexport interface Dot {\n  type: 'dot';\n}\n\n/**\n * Represents Tab\n */\nexport interface Tab {\n  type: 'tab';\n  cursorIndex?: number;\n\n  /**\n   * Move the cursor this much.\n   */\n  diff?: PositionDiff;\n}\n\n/**\n * Represents reindenting the selected line\n */\nexport interface Reindent {\n  type: 'reindent';\n  cursorIndex?: number;\n\n  /**\n   * Move the cursor this much.\n   */\n  diff?: PositionDiff;\n}\n\n/**\n * Represents macro\n */\nexport interface Macro {\n  type: 'macro';\n  register: string;\n  replay: 'contentChange' | 'keystrokes';\n}\n\n/**\n * Represents updating document content changes\n */\nexport interface ContentChangeTransformation {\n  type: 'contentChange';\n  changes: vscode.TextDocumentContentChangeEvent[];\n  diff: PositionDiff;\n}\n\nexport type Transformation =\n  | InsertTextTransformation\n  | InsertTextVSCodeTransformation\n  | ReplaceTextTransformation\n  | DeleteTextRangeTransformation\n  | DeleteTextTransformation\n  | MoveCursorTransformation\n  | ShowCommandHistory\n  | ShowSearchHistory\n  | Dot\n  | Macro\n  | ContentChangeTransformation\n  | DeleteTextTransformation\n  | Tab\n  | Reindent;\n\n/**\n * Text Transformations\n *\n * Using these indicates that you want Visual Studio Code to execute your text\n * actions as a batch operation. It's a bit tricky because we defer cursor updating\n * behavior to whatever the batch operation returns, so if you update the cursor in your\n * Action, VSCode will override whatever you did.\n *\n * If your cursor isn't ending up in the right place, you can adjust it by passing along\n * a PositionDiff.\n *\n * (There are a LOT of weird edge cases with cursor behavior that we don't want to have to reimplement. Trust\n * me... I tried.)\n */\nexport type TextTransformations =\n  | InsertTextTransformation\n  | InsertTextVSCodeTransformation\n  | DeleteTextRangeTransformation\n  | MoveCursorTransformation\n  | DeleteTextTransformation\n  | ReplaceTextTransformation;\n\nexport const isTextTransformation = (x: Transformation): x is TextTransformations => {\n  return (\n    x.type === 'insertText' ||\n    x.type === 'replaceText' ||\n    x.type === 'deleteText' ||\n    x.type === 'deleteRange' ||\n    x.type === 'moveCursor'\n  );\n};\nexport const isMultiCursorTextTransformation = (x: Transformation): boolean => {\n  return (x.type === 'insertTextVSCode' && x.isMultiCursor) ?? false;\n};\n\nconst getRangeFromTextTransformation = (transformation: TextTransformations): Range | undefined => {\n  switch (transformation.type) {\n    case 'insertText':\n      return new Range(transformation.position, transformation.position);\n    case 'replaceText':\n      return transformation.range;\n    case 'deleteText':\n      return new Range(transformation.position, transformation.position);\n    case 'deleteRange':\n      return transformation.range;\n    case 'moveCursor':\n      return undefined;\n  }\n\n  throw new Error('Unhandled text transformation: ' + transformation);\n};\n\nexport const areAnyTransformationsOverlapping = (transformations: TextTransformations[]) => {\n  for (let i = 0; i < transformations.length; i++) {\n    for (let j = i + 1; j < transformations.length; j++) {\n      const first = transformations[i];\n      const second = transformations[j];\n\n      const firstRange = getRangeFromTextTransformation(first);\n      const secondRange = getRangeFromTextTransformation(second);\n\n      if (!firstRange || !secondRange) {\n        continue;\n      }\n\n      if (firstRange.overlaps(secondRange)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nexport const areAllSameTransformation = (transformations: Transformation[]): boolean => {\n  const firstTransformation = transformations[0];\n\n  return transformations.every((t) => {\n    return Object.entries(t).every(([key, value]) => {\n      return firstTransformation[key] === value;\n    });\n  });\n};\n","import { Logger } from '../util/logger';\nimport { Transformation } from './transformations';\n\nexport class Transformer {\n  public readonly transformations: Transformation[] = [];\n\n  private logger = Logger.get('Transformer');\n\n  public addTransformation(transformation: Transformation) {\n    this.logger.debug(`Adding Transformation ${JSON.stringify(transformation)}`);\n    this.transformations.push(transformation);\n  }\n}\n","import * as vscode from 'vscode';\nimport { Logger } from './logger';\n\n/**\n * A thin wrapper around `vscode.env.clipboard`\n */\nexport class Clipboard {\n  private static readonly logger = Logger.get('Clipboard');\n\n  public static async Copy(text: string): Promise<void> {\n    try {\n      await vscode.env.clipboard.writeText(text);\n    } catch (e) {\n      this.logger.error(`Error copying to clipboard. err=${e}`);\n    }\n  }\n\n  public static async Paste(): Promise<string> {\n    return vscode.env.clipboard.readText();\n  }\n}\n","import { readFileAsync, writeFileAsync, unlink } from 'platform/fs';\nimport { tmpdir } from '../util/os';\nimport { join } from '../util/path';\nimport { VimError, ErrorCode } from '../error';\nimport { promisify } from 'util';\nimport * as process from 'process';\n\nclass ExternalCommand {\n  private previousExternalCommand: string | undefined;\n\n  private getRandomFileName(): string {\n    return Math.random()\n      .toString(36)\n      .replace(/[^a-z]+/g, '')\n      .substr(0, 10);\n  }\n\n  /**\n   * Expands the given command by replacing any '!' with the previous external\n   * command. The '!' can be escaped if there is a backslash preceeding the\n   * '!', then the backslash is removed and the '!' is kept.\n   *\n   * If a '!' is present but there is no previous external command, then a\n   * VimError is thrown.\n   * @param command the command to expand\n   */\n  private expandCommand(command: string): string {\n    const result: string[] = [];\n\n    for (let i = 0; i < command.length; i++) {\n      if (command[i] === '!') {\n        if (i > 0 && command[i - 1] === '\\\\') {\n          // escape the '!' and keep it\n          result.pop();\n          result.push('!');\n        } else if (!this.previousExternalCommand) {\n          // no previous command available to substitute\n          throw VimError.fromCode(ErrorCode.NoPreviousCommand);\n        } else {\n          result.push(this.previousExternalCommand);\n        }\n      } else {\n        result.push(command[i]);\n      }\n    }\n    return result.join('');\n  }\n\n  /**\n   * Creates a shell command from a command string, and redirects stdin and\n   * stdout/stderr to the given input/output files.\n   *\n   * @param command the command to redirect\n   * @param inputFile path to the input file\n   * @param outputFile path to the output file\n   */\n  private redirectCommand(command: string, inputFile: string, outputFile: string): string {\n    let result: string;\n    if (process.platform === 'win32') {\n      // need to put the '<' redirection after the first command in the pipe\n      const pipeIndex = command.indexOf('|');\n\n      if (pipeIndex !== -1) {\n        const firstCommand = command.slice(0, pipeIndex);\n        const restOfCommand = command.slice(pipeIndex);\n        result = `${firstCommand} < ${inputFile} ${restOfCommand} > ${outputFile}`;\n      } else {\n        result = `${command} < ${inputFile} > ${outputFile}`;\n      }\n    } else if (process.env.SHELL === 'fish') {\n      result = `begin; ${command}; end < ${inputFile} > ${outputFile}`;\n    } else {\n      result = `(${command}) < ${inputFile} > ${outputFile}`;\n    }\n\n    // combines stdout and stderr (compatible for all platforms)\n    result += ' 2>&1';\n    return result;\n  }\n\n  /**\n   * Runs the given command and returns the output (stdout and stderr).\n   * Optionally, `stdin` can be piped into stdin during execution.\n   *\n   * @param command the command to run\n   * @param stdin string to pipe into stdin, by default the empty string\n   */\n  public async run(command: string, stdin: string = ''): Promise<string> {\n    const inputFile = join(tmpdir(), this.getRandomFileName());\n    const outputFile = join(tmpdir(), this.getRandomFileName());\n    let result = '';\n\n    try {\n      await writeFileAsync(inputFile, stdin, 'utf8');\n\n      command = this.expandCommand(command);\n      this.previousExternalCommand = command;\n      command = this.redirectCommand(command, inputFile, outputFile);\n      try {\n        await import('child_process').then((cp) => {\n          return promisify(cp.exec)(command);\n        });\n      } catch (e) {\n        // exec throws an error if exit code != 0\n        // keep going and read the output anyway (just like vim)\n      }\n\n      result = await readFileAsync(outputFile, 'utf8');\n      // vim behavior: always trim newlines\n      if (result.endsWith('\\n')) {\n        result = result.slice(0, -1);\n      }\n    } finally {\n      // always delete tmp files at the end\n      await unlink(inputFile);\n      await unlink(outputFile);\n    }\n\n    return result;\n  }\n}\n\nexport const externalCommand = new ExternalCommand();\n","import { ILogger } from 'src/platform/common/logger';\nimport { LoggerImpl } from 'platform/loggerImpl';\nimport { IConfiguration } from 'src/configuration/iconfiguration';\n\nexport class Logger {\n  private static readonly cache = new Map<string, ILogger>();\n  private static configuration: IConfiguration | undefined = undefined;\n\n  static get(prefix: string): ILogger {\n    let logger = Logger.cache.get(prefix);\n    if (logger === undefined) {\n      logger = LoggerImpl.get(prefix);\n      if (Logger.configuration) {\n        logger.configChanged(Logger.configuration);\n      }\n      Logger.cache.set(prefix, logger);\n    }\n\n    return logger;\n  }\n\n  static configChanged(configuration: IConfiguration) {\n    Logger.configuration = configuration;\n    for (const logger of this.cache.values()) {\n      logger.configChanged(configuration);\n    }\n  }\n}\n","import * as os from 'os';\n\nexport function tmpdir(): string {\n  return os.tmpdir();\n}\n","import * as vscode from 'vscode';\nimport * as path from 'path';\nimport untildify = require('untildify');\n\n/**\n * A interface to the path in the node.js.\n */\ninterface Path {\n  normalize(p: string): string;\n  join(...paths: string[]): string;\n  resolve(...pathSegments: string[]): string;\n  isAbsolute(p: string): boolean;\n  relative(from: string, to: string): string;\n  dirname(p: string): string;\n  basename(p: string, ext?: string): string;\n  extname(p: string): string;\n  sep: string;\n  delimiter: string;\n}\n\n/**\n * Separate a partial path or full path into dirname and the basename.\n * @param searchPath The path to separate.\n * @param sep The separator of the searchPath.\n * @return A two-element array where the first element is the dirname and the second\n * is the basename.\n */\nexport function separatePath(searchPath: string, sep: string) {\n  // Special handle for UNC path on windows\n  if (sep === path.win32.sep) {\n    if (searchPath[0] === sep && searchPath[1] === sep) {\n      const idx = searchPath.indexOf(sep, 2);\n      if (idx === -1) {\n        // If there isn't a complete UNC path,\n        // return the incomplete UNC as baseName\n        // e.g. \\\\test-server is an incomplete path\n        // and \\\\test-server\\ is a complete path\n        return [searchPath, ''];\n      }\n    }\n  }\n\n  const baseNameIndex = searchPath.lastIndexOf(sep) + 1;\n  const baseName = searchPath.slice(baseNameIndex);\n  const dirName = searchPath.slice(0, baseNameIndex);\n  return [dirName, baseName];\n}\n\n/**\n * The comment is used conjunction with getPathDetails.\n */\ninterface PathDetails {\n  /**\n   * A full absolute path resolved from directory of the currently active document.\n   * If the active document is an untitled document, full path will be dirName of\n   * the input partialPath.\n   */\n  fullPath: string;\n  /**\n   * A full absolute path of the directory of fullPath.\n   * If the active document is an untitled document, full path will be the input partialPath.\n   */\n  fullDirPath: string;\n  /**\n   * The dir name of partialPath.\n   * If the partialPath is an absolute path, this will be equal to fullDirPat\n   * If partialPath is ./abc/xyz.txt, baseName will be './abc/'\n   * If partialPath is /abc/xyz.txt, baseName will be '/abc/'\n   */\n  dirName: string;\n  /**\n   * A base name of the partialPath.\n   * If partialPath is ./abc/xyz.txt, baseName will be 'xyz.txt'\n   * If partialPath is /abc/xyz.txt, baseName will be 'xyz.txt'\n   */\n  baseName: string;\n  /**\n   * An updated partialPath which has its / changed to \\ on Windows.\n   */\n  partialPath: string;\n  /**\n   * The correct node js path for the partial path. This will be either\n   * path.win32 or path.posix for further processing.\n   */\n  path: Path;\n}\n\n/**\n * Get path detail.\n *\n * If the currently active document is an untitled document, we will assume the partialPath\n * is a Windows path only when the VS Code is running on Windows, and not remote session; else, posix path.\n *\n * If the currently active document is not an untitled document, we will assume the partialPath\n * is a Windows path when the current uri is local file where the first character of fsPath of the\n * current uri is not \"/\"; otherwise, posix path. fsPath can return C:\\path\\avc.txt or \\\\drive\\location\\abc.txt\n * on Windows.\n *\n * This is to maximize usability of the combination of Windows and posix machine using remote while browsing\n * file on both local and remote.\n *\n * @param partialPath A string of relative path to the directory of the currentUri,\n * or an absolute path in the environment of the currentUri.\n * ~/ can be used only if active document is local document, or local untitled document.\n * @param currentUri A uri of the currently active document.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @return A PathDetail.\n */\nexport function getPathDetails(\n  partialPath: string,\n  currentUri: vscode.Uri,\n  isRemote: boolean\n): PathDetails {\n  let isWindows: boolean;\n  if (currentUri.scheme === 'untitled') {\n    // Assume remote server is nix only\n    isWindows = path === path.win32 && !isRemote;\n  } else {\n    // Assuming other schemes return full path\n    // e.g. 'file' and 'vscode-remote' both return full path\n    // Also only scheme that support Windows is 'file', so we can\n    // safely check if fsPath returns '/' as the first character\n    // (fsPath in 'vscode-remote' on Windows return \\ as separator instead of /)\n    isWindows = currentUri.scheme === 'file' && currentUri.fsPath[0] !== '/';\n  }\n\n  const p = isWindows ? path.win32 : path.posix;\n  if (isWindows) {\n    // normalize / to \\ on windows\n    partialPath = partialPath.replace(/\\//g, '\\\\');\n  }\n  const updatedPartialPath = partialPath;\n\n  if (currentUri.scheme === 'file' || (currentUri.scheme === 'untitled' && !isRemote)) {\n    // We can untildify when the scheme is 'file' or 'untitled' on local fs because\n    // because we only support opening files mounted locally.\n    partialPath = untildify(partialPath);\n  }\n\n  const [dirName, baseName] = separatePath(partialPath, p.sep);\n  let fullDirPath: string;\n  if (p.isAbsolute(dirName)) {\n    fullDirPath = dirName;\n  } else {\n    fullDirPath = p.join(\n      // On Windows machine:\n      // fsPath returns Windows drive path (C:\\xxx\\) or UNC path (\\\\server\\xxx)\n      // fsPath returns path with \\ as separator even if 'vscode-remote' is connect to a linux box\n      //\n      // path will return /home/user for example even 'vscode-remote' is used on windows\n      // as we relied of our isWindows detection\n      separatePath(isWindows ? currentUri.fsPath : currentUri.path, p.sep)[0],\n      dirName\n    );\n  }\n\n  const fullPath = p.join(fullDirPath, baseName);\n  return {\n    fullPath,\n    fullDirPath,\n    dirName,\n    baseName,\n    partialPath: updatedPartialPath,\n    path: p,\n  };\n}\n\n/**\n * Resolve the absolutePath to Uri.\n *\n * @param absolutePath A string of absolute path.\n * @param sep The separator of the absolutePath.\n * This is used to determine we should consider absolutePath a Windows path.\n * @param currentUri A uri to resolve the absolutePath to Uri.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @return null if the absolutePath is invalid. A uri resolved with the currentUri.\n */\nexport function resolveUri(\n  absolutePath: string,\n  sep: string,\n  currentUri: vscode.Uri,\n  isRemote: boolean\n) {\n  const isWindows = sep === path.win32.sep;\n  if (isWindows && !/^(\\\\\\\\.+\\\\)|([a-zA-Z]:\\\\)/.test(absolutePath)) {\n    // if it is windows and but don't have either\n    // UNC path or the windows drive\n    return null;\n  }\n  if (!isWindows && absolutePath[0] !== sep) {\n    // if it is not windows, but the absolute path doesn't begin with /\n    return null;\n  }\n\n  const isLocalUntitled = !isRemote && currentUri.scheme === 'untitled';\n  return isWindows\n    ? // Create new local Uri when it's on windows.\n      // Only local resource is support (vscode-remote doesn't have windows path)\n      // UNC path like //server1/folder should also work.\n      vscode.Uri.file(absolutePath)\n    : currentUri.with({\n        // search local file with currently active document is a local untitled doc\n        scheme: isLocalUntitled ? 'file' : currentUri.scheme,\n        path: absolutePath,\n      });\n}\n\n/**\n * Get the name of the items in a directory.\n * @param absolutePath A string of absolute path.\n * @param sep The separator of the absolutePath.\n * @param currentUri A uri of the currently active document.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @param addCurrentAndUp A boolean to indicate if .{$sep} and ..${sep} should be add to the result\n * @return A Promise which resolves to an array of string. The array can be empty if the path specified is actual\n * empty, of if the absolutePath specified is invalid, or if any error occurred during directory reading.\n * The string in the array will have sep appended if it is a directory.\n */\nexport async function readDirectory(\n  absolutePath: string,\n  sep: string,\n  currentUri: vscode.Uri,\n  isRemote: boolean,\n  addCurrentAndUp: boolean\n) {\n  try {\n    const directoryUri = resolveUri(absolutePath, sep, currentUri, isRemote);\n    if (directoryUri === null) {\n      return [];\n    }\n    const directoryResult = await vscode.workspace.fs.readDirectory(directoryUri);\n    return (\n      directoryResult\n        // Add the separator at the end to the path if it is a directory\n        .map((d) => d[0] + (d[1] === vscode.FileType.Directory ? sep : ''))\n        // Add ./ and ../ to the result if specified\n        .concat(addCurrentAndUp ? [`.${sep}`, `..${sep}`] : [])\n    );\n  } catch {\n    return [];\n  }\n}\n\nexport function join(...paths: string[]): string {\n  return path.join(...paths);\n}\n","export enum SpecialKeys {\n  ExtensionEnable = '<ExtensionEnable>',\n  ExtensionDisable = '<ExtensionDisable>',\n  TimeoutFinished = '<TimeoutFinished>',\n}\n","import { Mode } from '../mode/mode';\nimport { StatusBar } from '../statusBar';\nimport { VimState } from '../state/vimState';\nimport { configuration } from '../configuration/configuration';\nimport { Position } from 'vscode';\n\n/**\n * Shows the number of lines you just changed (with `dG`, for instance), if it\n * crosses a configured threshold.\n * @param numLinesChanged The number of lines changed\n */\nexport function reportLinesChanged(numLinesChanged: number, vimState: VimState) {\n  if (numLinesChanged > configuration.report) {\n    StatusBar.setText(vimState, `${numLinesChanged} more lines`);\n  } else if (-numLinesChanged > configuration.report) {\n    StatusBar.setText(vimState, `${Math.abs(numLinesChanged)} fewer lines`);\n  } else {\n    StatusBar.clear(vimState);\n  }\n}\n\n/**\n * Shows the number of lines you just yanked, if it crosses a configured threshold.\n * @param numLinesYanked The number of lines yanked\n */\nexport function reportLinesYanked(numLinesYanked: number, vimState: VimState) {\n  if (numLinesYanked > configuration.report) {\n    if (vimState.currentMode === Mode.VisualBlock) {\n      StatusBar.setText(vimState, `block of ${numLinesYanked} lines yanked`);\n    } else {\n      StatusBar.setText(vimState, `${numLinesYanked} lines yanked`);\n    }\n  } else {\n    StatusBar.clear(vimState);\n  }\n}\n\n/**\n * Shows the active file's path and line count as well as position in the file as a percentage.\n * Triggered via `<C-g>` or `:f[ile]`.\n */\nexport function reportFileInfo(position: Position, vimState: VimState) {\n  const doc = vimState.document;\n  const progress = Math.floor(((position.line + 1) / doc.lineCount) * 100);\n\n  StatusBar.setText(vimState, `\"${doc.fileName}\" ${doc.lineCount} lines --${progress}%--`);\n}\n\n/**\n * Shows the number of matches and current match index of a search.\n * @param matchIdx Index of current match, starting at 0\n * @param numMatches Total number of matches\n * @param vimState The current `VimState`\n */\nexport function reportSearch(matchIdx: number, numMatches: number, vimState: VimState) {\n  StatusBar.setText(vimState, `match ${matchIdx + 1} of ${numMatches}`);\n}\n","import * as vscode from 'vscode';\nimport { Range } from '../common/motion/range';\nimport { VimState } from '../state/vimState';\n\n/**\n * We used to have an issue where we would do something like execute a VSCode\n * command, and would encounter race conditions because the cursor positions\n * wouldn't yet be updated. So we waited for a selection change event, but\n * this doesn't seem to be necessary any more.\n */\nexport function getCursorsAfterSync(): Range[] {\n  return vscode.window.activeTextEditor!.selections.map((x) => Range.FromVSCodeSelection(x));\n}\n\nexport function clamp(num: number, min: number, max: number) {\n  return Math.min(Math.max(num, min), max);\n}\n\nexport function scrollView(vimState: VimState, offset: number) {\n  if (offset !== 0) {\n    vimState.postponedCodeViewChanges.push({\n      command: 'editorScroll',\n      args: {\n        to: offset > 0 ? 'up' : 'down',\n        by: 'line',\n        value: Math.abs(offset),\n        revealCursor: false,\n        select: false,\n      },\n    });\n  }\n}\n","import * as vscode from 'vscode';\nimport { Logger } from './logger';\n\ntype ContextValue = boolean | string;\n\n/**\n * Wrapper around VS Code's `setContext`.\n * The API call takes several milliseconds to seconds to complete,\n * so let's cache the values and only call the API when necessary.\n */\nexport abstract class VSCodeContext {\n  private static readonly cache: Map<string, ContextValue> = new Map();\n\n  public static async set(key: string, value: ContextValue): Promise<void> {\n    const prev = this.get(key);\n    if (prev !== value) {\n      Logger.get('vscode-context').debug(`Setting key='${key}' to value='${value}'`);\n      this.cache.set(key, value);\n      await vscode.commands.executeCommand('setContext', key, value);\n    }\n  }\n\n  public static get(key: string): ContextValue | undefined {\n    return this.cache.get(key);\n  }\n}\n","'use strict';\nconst os = require('os');\n\nconst homeDirectory = os.homedir();\n\nmodule.exports = pathWithTilde => {\n\tif (typeof pathWithTilde !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof pathWithTilde}`);\n\t}\n\n\treturn homeDirectory ? pathWithTilde.replace(/^~(?=$|\\/|\\\\)/, homeDirectory) : pathWithTilde;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","module.exports = require(\"vscode\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","/**\n * Extension.ts is a lightweight wrapper around ModeHandler. It converts key\n * events to their string names and passes them on to ModeHandler via\n * handleKeyEvent().\n */\nimport './src/actions/include-main';\n\n/**\n * Load configuration validator\n */\n\nimport './src/configuration/validators/inputMethodSwitcherValidator';\nimport './src/configuration/validators/remappingValidator';\n\nimport * as vscode from 'vscode';\nimport { activate as activateFunc } from './extensionBase';\n\n// tslint:disable-next-line: no-var-requires\nrequire('setimmediate');\n\nexport async function activate(context: vscode.ExtensionContext) {\n  activateFunc(context, false);\n}\n"],"sourceRoot":""}